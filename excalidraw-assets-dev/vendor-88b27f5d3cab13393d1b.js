/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkExcalidrawLib"] = globalThis["webpackChunkExcalidrawLib"] || []).push([["vendor"],{

/***/ "../../../node_modules/.pnpm/pica@7.1.1/node_modules/pica/dist/pica.js":
/*!*****************************************************************************!*\
  !*** ../../../node_modules/.pnpm/pica@7.1.1/node_modules/pica/dist/pica.js ***!
  \*****************************************************************************/
/***/ ((module) => {

eval("/*!\n\npica\nhttps://github.com/nodeca/pica\n\n*/\n\n(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(_dereq_,module,exports){\n// Collection of math functions\n//\n// 1. Combine components together\n// 2. Has async init to load wasm modules\n//\n'use strict';\n\nvar inherits = _dereq_('inherits');\n\nvar Multimath = _dereq_('multimath');\n\nvar mm_unsharp_mask = _dereq_('./mm_unsharp_mask');\n\nvar mm_resize = _dereq_('./mm_resize');\n\nfunction MathLib(requested_features) {\n  var __requested_features = requested_features || [];\n\n  var features = {\n    js: __requested_features.indexOf('js') >= 0,\n    wasm: __requested_features.indexOf('wasm') >= 0\n  };\n  Multimath.call(this, features);\n  this.features = {\n    js: features.js,\n    wasm: features.wasm && this.has_wasm()\n  };\n  this.use(mm_unsharp_mask);\n  this.use(mm_resize);\n}\n\ninherits(MathLib, Multimath);\n\nMathLib.prototype.resizeAndUnsharp = function resizeAndUnsharp(options, cache) {\n  var result = this.resize(options, cache);\n\n  if (options.unsharpAmount) {\n    this.unsharp_mask(result, options.toWidth, options.toHeight, options.unsharpAmount, options.unsharpRadius, options.unsharpThreshold);\n  }\n\n  return result;\n};\n\nmodule.exports = MathLib;\n\n},{\"./mm_resize\":4,\"./mm_unsharp_mask\":9,\"inherits\":19,\"multimath\":20}],2:[function(_dereq_,module,exports){\n// Resize convolvers, pure JS implementation\n//\n'use strict'; // Precision of fixed FP values\n//var FIXED_FRAC_BITS = 14;\n\nfunction clampTo8(i) {\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n} // Convolve image in horizontal directions and transpose output. In theory,\n// transpose allow:\n//\n// - use the same convolver for both passes (this fails due different\n//   types of input array and temporary buffer)\n// - making vertical pass by horisonltal lines inprove CPU cache use.\n//\n// But in real life this doesn't work :)\n//\n\n\nfunction convolveHorizontally(src, dest, srcW, srcH, destW, filters) {\n  var r, g, b, a;\n  var filterPtr, filterShift, filterSize;\n  var srcPtr, srcY, destX, filterVal;\n  var srcOffset = 0,\n      destOffset = 0; // For each row\n\n  for (srcY = 0; srcY < srcH; srcY++) {\n    filterPtr = 0; // Apply precomputed filters to each destination row point\n\n    for (destX = 0; destX < destW; destX++) {\n      // Get the filter that determines the current output pixel.\n      filterShift = filters[filterPtr++];\n      filterSize = filters[filterPtr++];\n      srcPtr = srcOffset + filterShift * 4 | 0;\n      r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a\n\n      for (; filterSize > 0; filterSize--) {\n        filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)\n        // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.\n\n        a = a + filterVal * src[srcPtr + 3] | 0;\n        b = b + filterVal * src[srcPtr + 2] | 0;\n        g = g + filterVal * src[srcPtr + 1] | 0;\n        r = r + filterVal * src[srcPtr] | 0;\n        srcPtr = srcPtr + 4 | 0;\n      } // Bring this value back in range. All of the filter scaling factors\n      // are in fixed point with FIXED_FRAC_BITS bits of fractional part.\n      //\n      // (!) Add 1/2 of value before clamping to get proper rounding. In other\n      // case brightness loss will be noticeable if you resize image with white\n      // border and place it on white background.\n      //\n\n\n      dest[destOffset + 3] = clampTo8(a + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      dest[destOffset] = clampTo8(r + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      destOffset = destOffset + srcH * 4 | 0;\n    }\n\n    destOffset = (srcY + 1) * 4 | 0;\n    srcOffset = (srcY + 1) * srcW * 4 | 0;\n  }\n} // Technically, convolvers are the same. But input array and temporary\n// buffer can be of different type (especially, in old browsers). So,\n// keep code in separate functions to avoid deoptimizations & speed loss.\n\n\nfunction convolveVertically(src, dest, srcW, srcH, destW, filters) {\n  var r, g, b, a;\n  var filterPtr, filterShift, filterSize;\n  var srcPtr, srcY, destX, filterVal;\n  var srcOffset = 0,\n      destOffset = 0; // For each row\n\n  for (srcY = 0; srcY < srcH; srcY++) {\n    filterPtr = 0; // Apply precomputed filters to each destination row point\n\n    for (destX = 0; destX < destW; destX++) {\n      // Get the filter that determines the current output pixel.\n      filterShift = filters[filterPtr++];\n      filterSize = filters[filterPtr++];\n      srcPtr = srcOffset + filterShift * 4 | 0;\n      r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a\n\n      for (; filterSize > 0; filterSize--) {\n        filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)\n        // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.\n\n        a = a + filterVal * src[srcPtr + 3] | 0;\n        b = b + filterVal * src[srcPtr + 2] | 0;\n        g = g + filterVal * src[srcPtr + 1] | 0;\n        r = r + filterVal * src[srcPtr] | 0;\n        srcPtr = srcPtr + 4 | 0;\n      } // Bring this value back in range. All of the filter scaling factors\n      // are in fixed point with FIXED_FRAC_BITS bits of fractional part.\n      //\n      // (!) Add 1/2 of value before clamping to get proper rounding. In other\n      // case brightness loss will be noticeable if you resize image with white\n      // border and place it on white background.\n      //\n\n\n      dest[destOffset + 3] = clampTo8(a + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      dest[destOffset] = clampTo8(r + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      destOffset = destOffset + srcH * 4 | 0;\n    }\n\n    destOffset = (srcY + 1) * 4 | 0;\n    srcOffset = (srcY + 1) * srcW * 4 | 0;\n  }\n}\n\nmodule.exports = {\n  convolveHorizontally: convolveHorizontally,\n  convolveVertically: convolveVertically\n};\n\n},{}],3:[function(_dereq_,module,exports){\n// This is autogenerated file from math.wasm, don't edit.\n//\n'use strict';\n/* eslint-disable max-len */\n\nmodule.exports = 'AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEXA2AAAGAGf39/f39/AGAHf39/f39/fwACDwEDZW52Bm1lbW9yeQIAAAMEAwABAgYGAX8AQQALB1cFEV9fd2FzbV9jYWxsX2N0b3JzAAAIY29udm9sdmUAAQpjb252b2x2ZUhWAAIMX19kc29faGFuZGxlAwAYX193YXNtX2FwcGx5X2RhdGFfcmVsb2NzAAAK7AMDAwABC8YDAQ9/AkAgA0UNACAERQ0AA0AgDCENQQAhE0EAIQcDQCAHQQJqIQYCfyAHQQF0IAVqIgcuAQIiFEUEQEGAwAAhCEGAwAAhCUGAwAAhCkGAwAAhCyAGDAELIBIgBy4BAGohCEEAIQsgFCEHQQAhDiAGIQlBACEPQQAhEANAIAUgCUEBdGouAQAiESAAIAhBAnRqKAIAIgpBGHZsIBBqIRAgCkH/AXEgEWwgC2ohCyAKQRB2Qf8BcSARbCAPaiEPIApBCHZB/wFxIBFsIA5qIQ4gCEEBaiEIIAlBAWohCSAHQQFrIgcNAAsgC0GAQGshCCAOQYBAayEJIA9BgEBrIQogEEGAQGshCyAGIBRqCyEHIAEgDUECdGogCUEOdSIGQf8BIAZB/wFIGyIGQQAgBkEAShtBCHRBgP4DcSAKQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG0EQdEGAgPwHcSALQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG0EYdHJyIAhBDnUiBkH/ASAGQf8BSBsiBkEAIAZBAEobcjYCACADIA1qIQ0gE0EBaiITIARHDQALIAxBAWoiDCACbCESIAMgDEcNAAsLCx4AQQAgAiADIAQgBSAAEAEgAkEAIAQgBSAGIAEQAQs=';\n\n},{}],4:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = {\n  name: 'resize',\n  fn: _dereq_('./resize'),\n  wasm_fn: _dereq_('./resize_wasm'),\n  wasm_src: _dereq_('./convolve_wasm_base64')\n};\n\n},{\"./convolve_wasm_base64\":3,\"./resize\":5,\"./resize_wasm\":8}],5:[function(_dereq_,module,exports){\n'use strict';\n\nvar createFilters = _dereq_('./resize_filter_gen');\n\nvar convolveHorizontally = _dereq_('./convolve').convolveHorizontally;\n\nvar convolveVertically = _dereq_('./convolve').convolveVertically;\n\nfunction resetAlpha(dst, width, height) {\n  var ptr = 3,\n      len = width * height * 4 | 0;\n\n  while (ptr < len) {\n    dst[ptr] = 0xFF;\n    ptr = ptr + 4 | 0;\n  }\n}\n\nmodule.exports = function resize(options) {\n  var src = options.src;\n  var srcW = options.width;\n  var srcH = options.height;\n  var destW = options.toWidth;\n  var destH = options.toHeight;\n  var scaleX = options.scaleX || options.toWidth / options.width;\n  var scaleY = options.scaleY || options.toHeight / options.height;\n  var offsetX = options.offsetX || 0;\n  var offsetY = options.offsetY || 0;\n  var dest = options.dest || new Uint8Array(destW * destH * 4);\n  var quality = typeof options.quality === 'undefined' ? 3 : options.quality;\n  var alpha = options.alpha || false;\n  var filtersX = createFilters(quality, srcW, destW, scaleX, offsetX),\n      filtersY = createFilters(quality, srcH, destH, scaleY, offsetY);\n  var tmp = new Uint8Array(destW * srcH * 4); // To use single function we need src & tmp of the same type.\n  // But src can be CanvasPixelArray, and tmp - Uint8Array. So, keep\n  // vertical and horizontal passes separately to avoid deoptimization.\n\n  convolveHorizontally(src, tmp, srcW, srcH, destW, filtersX);\n  convolveVertically(tmp, dest, srcH, destW, destH, filtersY); // That's faster than doing checks in convolver.\n  // !!! Note, canvas data is not premultipled. We don't need other\n  // alpha corrections.\n\n  if (!alpha) resetAlpha(dest, destW, destH);\n  return dest;\n};\n\n},{\"./convolve\":2,\"./resize_filter_gen\":6}],6:[function(_dereq_,module,exports){\n// Calculate convolution filters for each destination point,\n// and pack data to Int16Array:\n//\n// [ shift, length, data..., shift2, length2, data..., ... ]\n//\n// - shift - offset in src image\n// - length - filter length (in src points)\n// - data - filter values sequence\n//\n'use strict';\n\nvar FILTER_INFO = _dereq_('./resize_filter_info'); // Precision of fixed FP values\n\n\nvar FIXED_FRAC_BITS = 14;\n\nfunction toFixedPoint(num) {\n  return Math.round(num * ((1 << FIXED_FRAC_BITS) - 1));\n}\n\nmodule.exports = function resizeFilterGen(quality, srcSize, destSize, scale, offset) {\n  var filterFunction = FILTER_INFO[quality].filter;\n  var scaleInverted = 1.0 / scale;\n  var scaleClamped = Math.min(1.0, scale); // For upscale\n  // Filter window (averaging interval), scaled to src image\n\n  var srcWindow = FILTER_INFO[quality].win / scaleClamped;\n  var destPixel, srcPixel, srcFirst, srcLast, filterElementSize, floatFilter, fxpFilter, total, pxl, idx, floatVal, filterTotal, filterVal;\n  var leftNotEmpty, rightNotEmpty, filterShift, filterSize;\n  var maxFilterElementSize = Math.floor((srcWindow + 1) * 2);\n  var packedFilter = new Int16Array((maxFilterElementSize + 2) * destSize);\n  var packedFilterPtr = 0;\n  var slowCopy = !packedFilter.subarray || !packedFilter.set; // For each destination pixel calculate source range and built filter values\n\n  for (destPixel = 0; destPixel < destSize; destPixel++) {\n    // Scaling should be done relative to central pixel point\n    srcPixel = (destPixel + 0.5) * scaleInverted + offset;\n    srcFirst = Math.max(0, Math.floor(srcPixel - srcWindow));\n    srcLast = Math.min(srcSize - 1, Math.ceil(srcPixel + srcWindow));\n    filterElementSize = srcLast - srcFirst + 1;\n    floatFilter = new Float32Array(filterElementSize);\n    fxpFilter = new Int16Array(filterElementSize);\n    total = 0.0; // Fill filter values for calculated range\n\n    for (pxl = srcFirst, idx = 0; pxl <= srcLast; pxl++, idx++) {\n      floatVal = filterFunction((pxl + 0.5 - srcPixel) * scaleClamped);\n      total += floatVal;\n      floatFilter[idx] = floatVal;\n    } // Normalize filter, convert to fixed point and accumulate conversion error\n\n\n    filterTotal = 0;\n\n    for (idx = 0; idx < floatFilter.length; idx++) {\n      filterVal = floatFilter[idx] / total;\n      filterTotal += filterVal;\n      fxpFilter[idx] = toFixedPoint(filterVal);\n    } // Compensate normalization error, to minimize brightness drift\n\n\n    fxpFilter[destSize >> 1] += toFixedPoint(1.0 - filterTotal); //\n    // Now pack filter to useable form\n    //\n    // 1. Trim heading and tailing zero values, and compensate shitf/length\n    // 2. Put all to single array in this format:\n    //\n    //    [ pos shift, data length, value1, value2, value3, ... ]\n    //\n\n    leftNotEmpty = 0;\n\n    while (leftNotEmpty < fxpFilter.length && fxpFilter[leftNotEmpty] === 0) {\n      leftNotEmpty++;\n    }\n\n    if (leftNotEmpty < fxpFilter.length) {\n      rightNotEmpty = fxpFilter.length - 1;\n\n      while (rightNotEmpty > 0 && fxpFilter[rightNotEmpty] === 0) {\n        rightNotEmpty--;\n      }\n\n      filterShift = srcFirst + leftNotEmpty;\n      filterSize = rightNotEmpty - leftNotEmpty + 1;\n      packedFilter[packedFilterPtr++] = filterShift; // shift\n\n      packedFilter[packedFilterPtr++] = filterSize; // size\n\n      if (!slowCopy) {\n        packedFilter.set(fxpFilter.subarray(leftNotEmpty, rightNotEmpty + 1), packedFilterPtr);\n        packedFilterPtr += filterSize;\n      } else {\n        // fallback for old IE < 11, without subarray/set methods\n        for (idx = leftNotEmpty; idx <= rightNotEmpty; idx++) {\n          packedFilter[packedFilterPtr++] = fxpFilter[idx];\n        }\n      }\n    } else {\n      // zero data, write header only\n      packedFilter[packedFilterPtr++] = 0; // shift\n\n      packedFilter[packedFilterPtr++] = 0; // size\n    }\n  }\n\n  return packedFilter;\n};\n\n},{\"./resize_filter_info\":7}],7:[function(_dereq_,module,exports){\n// Filter definitions to build tables for\n// resizing convolvers.\n//\n// Presets for quality 0..3. Filter functions + window size\n//\n'use strict';\n\nmodule.exports = [{\n  // Nearest neibor (Box)\n  win: 0.5,\n  filter: function filter(x) {\n    return x >= -0.5 && x < 0.5 ? 1.0 : 0.0;\n  }\n}, {\n  // Hamming\n  win: 1.0,\n  filter: function filter(x) {\n    if (x <= -1.0 || x >= 1.0) {\n      return 0.0;\n    }\n\n    if (x > -1.19209290E-07 && x < 1.19209290E-07) {\n      return 1.0;\n    }\n\n    var xpi = x * Math.PI;\n    return Math.sin(xpi) / xpi * (0.54 + 0.46 * Math.cos(xpi / 1.0));\n  }\n}, {\n  // Lanczos, win = 2\n  win: 2.0,\n  filter: function filter(x) {\n    if (x <= -2.0 || x >= 2.0) {\n      return 0.0;\n    }\n\n    if (x > -1.19209290E-07 && x < 1.19209290E-07) {\n      return 1.0;\n    }\n\n    var xpi = x * Math.PI;\n    return Math.sin(xpi) / xpi * Math.sin(xpi / 2.0) / (xpi / 2.0);\n  }\n}, {\n  // Lanczos, win = 3\n  win: 3.0,\n  filter: function filter(x) {\n    if (x <= -3.0 || x >= 3.0) {\n      return 0.0;\n    }\n\n    if (x > -1.19209290E-07 && x < 1.19209290E-07) {\n      return 1.0;\n    }\n\n    var xpi = x * Math.PI;\n    return Math.sin(xpi) / xpi * Math.sin(xpi / 3.0) / (xpi / 3.0);\n  }\n}];\n\n},{}],8:[function(_dereq_,module,exports){\n'use strict';\n\nvar createFilters = _dereq_('./resize_filter_gen');\n\nfunction resetAlpha(dst, width, height) {\n  var ptr = 3,\n      len = width * height * 4 | 0;\n\n  while (ptr < len) {\n    dst[ptr] = 0xFF;\n    ptr = ptr + 4 | 0;\n  }\n}\n\nfunction asUint8Array(src) {\n  return new Uint8Array(src.buffer, 0, src.byteLength);\n}\n\nvar IS_LE = true; // should not crash everything on module load in old browsers\n\ntry {\n  IS_LE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;\n} catch (__) {}\n\nfunction copyInt16asLE(src, target, target_offset) {\n  if (IS_LE) {\n    target.set(asUint8Array(src), target_offset);\n    return;\n  }\n\n  for (var ptr = target_offset, i = 0; i < src.length; i++) {\n    var data = src[i];\n    target[ptr++] = data & 0xFF;\n    target[ptr++] = data >> 8 & 0xFF;\n  }\n}\n\nmodule.exports = function resize_wasm(options) {\n  var src = options.src;\n  var srcW = options.width;\n  var srcH = options.height;\n  var destW = options.toWidth;\n  var destH = options.toHeight;\n  var scaleX = options.scaleX || options.toWidth / options.width;\n  var scaleY = options.scaleY || options.toHeight / options.height;\n  var offsetX = options.offsetX || 0.0;\n  var offsetY = options.offsetY || 0.0;\n  var dest = options.dest || new Uint8Array(destW * destH * 4);\n  var quality = typeof options.quality === 'undefined' ? 3 : options.quality;\n  var alpha = options.alpha || false;\n  var filtersX = createFilters(quality, srcW, destW, scaleX, offsetX),\n      filtersY = createFilters(quality, srcH, destH, scaleY, offsetY); // destination is 0 too.\n\n  var src_offset = 0; // buffer between convolve passes\n\n  var tmp_offset = this.__align(src_offset + Math.max(src.byteLength, dest.byteLength));\n\n  var filtersX_offset = this.__align(tmp_offset + srcH * destW * 4);\n\n  var filtersY_offset = this.__align(filtersX_offset + filtersX.byteLength);\n\n  var alloc_bytes = filtersY_offset + filtersY.byteLength;\n\n  var instance = this.__instance('resize', alloc_bytes); //\n  // Fill memory block with data to process\n  //\n\n\n  var mem = new Uint8Array(this.__memory.buffer);\n  var mem32 = new Uint32Array(this.__memory.buffer); // 32-bit copy is much faster in chrome\n\n  var src32 = new Uint32Array(src.buffer);\n  mem32.set(src32); // We should guarantee LE bytes order. Filters are not big, so\n  // speed difference is not significant vs direct .set()\n\n  copyInt16asLE(filtersX, mem, filtersX_offset);\n  copyInt16asLE(filtersY, mem, filtersY_offset); //\n  // Now call webassembly method\n  // emsdk does method names with '_'\n\n  var fn = instance.exports.convolveHV || instance.exports._convolveHV;\n  fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH); //\n  // Copy data back to typed array\n  //\n  // 32-bit copy is much faster in chrome\n\n  var dest32 = new Uint32Array(dest.buffer);\n  dest32.set(new Uint32Array(this.__memory.buffer, 0, destH * destW)); // That's faster than doing checks in convolver.\n  // !!! Note, canvas data is not premultipled. We don't need other\n  // alpha corrections.\n\n  if (!alpha) resetAlpha(dest, destW, destH);\n  return dest;\n};\n\n},{\"./resize_filter_gen\":6}],9:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = {\n  name: 'unsharp_mask',\n  fn: _dereq_('./unsharp_mask'),\n  wasm_fn: _dereq_('./unsharp_mask_wasm'),\n  wasm_src: _dereq_('./unsharp_mask_wasm_base64')\n};\n\n},{\"./unsharp_mask\":10,\"./unsharp_mask_wasm\":11,\"./unsharp_mask_wasm_base64\":12}],10:[function(_dereq_,module,exports){\n// Unsharp mask filter\n//\n// http://stackoverflow.com/a/23322820/1031804\n// USM(O) = O + (2 * (Amount / 100) * (O - GB))\n// GB - gaussian blur.\n//\n// Image is converted from RGB to HSV, unsharp mask is applied to the\n// brightness channel and then image is converted back to RGB.\n//\n'use strict';\n\nvar glur_mono16 = _dereq_('glur/mono16');\n\nfunction hsv_v16(img, width, height) {\n  var size = width * height;\n  var out = new Uint16Array(size);\n  var r, g, b, max;\n\n  for (var i = 0; i < size; i++) {\n    r = img[4 * i];\n    g = img[4 * i + 1];\n    b = img[4 * i + 2];\n    max = r >= g && r >= b ? r : g >= b && g >= r ? g : b;\n    out[i] = max << 8;\n  }\n\n  return out;\n}\n\nmodule.exports = function unsharp(img, width, height, amount, radius, threshold) {\n  var v1, v2, vmul;\n  var diff, iTimes4;\n\n  if (amount === 0 || radius < 0.5) {\n    return;\n  }\n\n  if (radius > 2.0) {\n    radius = 2.0;\n  }\n\n  var brightness = hsv_v16(img, width, height);\n  var blured = new Uint16Array(brightness); // copy, because blur modify src\n\n  glur_mono16(blured, width, height, radius);\n  var amountFp = amount / 100 * 0x1000 + 0.5 | 0;\n  var thresholdFp = threshold << 8;\n  var size = width * height;\n  /* eslint-disable indent */\n\n  for (var i = 0; i < size; i++) {\n    v1 = brightness[i];\n    diff = v1 - blured[i];\n\n    if (Math.abs(diff) >= thresholdFp) {\n      // add unsharp mask to the brightness channel\n      v2 = v1 + (amountFp * diff + 0x800 >> 12); // Both v1 and v2 are within [0.0 .. 255.0] (0000-FF00) range, never going into\n      // [255.003 .. 255.996] (FF01-FFFF). This allows to round this value as (x+.5)|0\n      // later without overflowing.\n\n      v2 = v2 > 0xff00 ? 0xff00 : v2;\n      v2 = v2 < 0x0000 ? 0x0000 : v2; // Avoid division by 0. V=0 means rgb(0,0,0), unsharp with unsharpAmount>0 cannot\n      // change this value (because diff between colors gets inflated), so no need to verify correctness.\n\n      v1 = v1 !== 0 ? v1 : 1; // Multiplying V in HSV model by a constant is equivalent to multiplying each component\n      // in RGB by the same constant (same for HSL), see also:\n      // https://beesbuzz.biz/code/16-hsv-color-transforms\n\n      vmul = (v2 << 12) / v1 | 0; // Result will be in [0..255] range because:\n      //  - all numbers are positive\n      //  - r,g,b <= (v1/256)\n      //  - r,g,b,(v1/256),(v2/256) <= 255\n      // So highest this number can get is X*255/X+0.5=255.5 which is < 256 and rounds down.\n\n      iTimes4 = i * 4;\n      img[iTimes4] = img[iTimes4] * vmul + 0x800 >> 12; // R\n\n      img[iTimes4 + 1] = img[iTimes4 + 1] * vmul + 0x800 >> 12; // G\n\n      img[iTimes4 + 2] = img[iTimes4 + 2] * vmul + 0x800 >> 12; // B\n    }\n  }\n};\n\n},{\"glur/mono16\":18}],11:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = function unsharp(img, width, height, amount, radius, threshold) {\n  if (amount === 0 || radius < 0.5) {\n    return;\n  }\n\n  if (radius > 2.0) {\n    radius = 2.0;\n  }\n\n  var pixels = width * height;\n  var img_bytes_cnt = pixels * 4;\n  var hsv_bytes_cnt = pixels * 2;\n  var blur_bytes_cnt = pixels * 2;\n  var blur_line_byte_cnt = Math.max(width, height) * 4; // float32 array\n\n  var blur_coeffs_byte_cnt = 8 * 4; // float32 array\n\n  var img_offset = 0;\n  var hsv_offset = img_bytes_cnt;\n  var blur_offset = hsv_offset + hsv_bytes_cnt;\n  var blur_tmp_offset = blur_offset + blur_bytes_cnt;\n  var blur_line_offset = blur_tmp_offset + blur_bytes_cnt;\n  var blur_coeffs_offset = blur_line_offset + blur_line_byte_cnt;\n\n  var instance = this.__instance('unsharp_mask', img_bytes_cnt + hsv_bytes_cnt + blur_bytes_cnt * 2 + blur_line_byte_cnt + blur_coeffs_byte_cnt, {\n    exp: Math.exp\n  }); // 32-bit copy is much faster in chrome\n\n\n  var img32 = new Uint32Array(img.buffer);\n  var mem32 = new Uint32Array(this.__memory.buffer);\n  mem32.set(img32); // HSL\n\n  var fn = instance.exports.hsv_v16 || instance.exports._hsv_v16;\n  fn(img_offset, hsv_offset, width, height); // BLUR\n\n  fn = instance.exports.blurMono16 || instance.exports._blurMono16;\n  fn(hsv_offset, blur_offset, blur_tmp_offset, blur_line_offset, blur_coeffs_offset, width, height, radius); // UNSHARP\n\n  fn = instance.exports.unsharp || instance.exports._unsharp;\n  fn(img_offset, img_offset, hsv_offset, blur_offset, width, height, amount, threshold); // 32-bit copy is much faster in chrome\n\n  img32.set(new Uint32Array(this.__memory.buffer, 0, pixels));\n};\n\n},{}],12:[function(_dereq_,module,exports){\n// This is autogenerated file from math.wasm, don't edit.\n//\n'use strict';\n/* eslint-disable max-len */\n\nmodule.exports = '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';\n\n},{}],13:[function(_dereq_,module,exports){\n'use strict';\n\nvar GC_INTERVAL = 100;\n\nfunction Pool(create, idle) {\n  this.create = create;\n  this.available = [];\n  this.acquired = {};\n  this.lastId = 1;\n  this.timeoutId = 0;\n  this.idle = idle || 2000;\n}\n\nPool.prototype.acquire = function () {\n  var _this = this;\n\n  var resource;\n\n  if (this.available.length !== 0) {\n    resource = this.available.pop();\n  } else {\n    resource = this.create();\n    resource.id = this.lastId++;\n\n    resource.release = function () {\n      return _this.release(resource);\n    };\n  }\n\n  this.acquired[resource.id] = resource;\n  return resource;\n};\n\nPool.prototype.release = function (resource) {\n  var _this2 = this;\n\n  delete this.acquired[resource.id];\n  resource.lastUsed = Date.now();\n  this.available.push(resource);\n\n  if (this.timeoutId === 0) {\n    this.timeoutId = setTimeout(function () {\n      return _this2.gc();\n    }, GC_INTERVAL);\n  }\n};\n\nPool.prototype.gc = function () {\n  var _this3 = this;\n\n  var now = Date.now();\n  this.available = this.available.filter(function (resource) {\n    if (now - resource.lastUsed > _this3.idle) {\n      resource.destroy();\n      return false;\n    }\n\n    return true;\n  });\n\n  if (this.available.length !== 0) {\n    this.timeoutId = setTimeout(function () {\n      return _this3.gc();\n    }, GC_INTERVAL);\n  } else {\n    this.timeoutId = 0;\n  }\n};\n\nmodule.exports = Pool;\n\n},{}],14:[function(_dereq_,module,exports){\n// Add intermediate resizing steps when scaling down by a very large factor.\n//\n// For example, when resizing 10000x10000 down to 10x10, it'll resize it to\n// 300x300 first.\n//\n// It's needed because tiler has issues when the entire tile is scaled down\n// to a few pixels (1024px source tile with border size 3 should result in\n// at least 3+3+2 = 8px target tile, so max scale factor is 128 here).\n//\n// Also, adding intermediate steps can speed up processing if we use lower\n// quality algorithms for first stages.\n//\n'use strict'; // min size = 0 results in infinite loop,\n// min size = 1 can consume large amount of memory\n\nvar MIN_INNER_TILE_SIZE = 2;\n\nmodule.exports = function createStages(fromWidth, fromHeight, toWidth, toHeight, srcTileSize, destTileBorder) {\n  var scaleX = toWidth / fromWidth;\n  var scaleY = toHeight / fromHeight; // derived from createRegions equation:\n  // innerTileWidth = pixelFloor(srcTileSize * scaleX) - 2 * destTileBorder;\n\n  var minScale = (2 * destTileBorder + MIN_INNER_TILE_SIZE + 1) / srcTileSize; // refuse to scale image multiple times by less than twice each time,\n  // it could only happen because of invalid options\n\n  if (minScale > 0.5) return [[toWidth, toHeight]];\n  var stageCount = Math.ceil(Math.log(Math.min(scaleX, scaleY)) / Math.log(minScale)); // no additional resizes are necessary,\n  // stageCount can be zero or be negative when enlarging the image\n\n  if (stageCount <= 1) return [[toWidth, toHeight]];\n  var result = [];\n\n  for (var i = 0; i < stageCount; i++) {\n    var width = Math.round(Math.pow(Math.pow(fromWidth, stageCount - i - 1) * Math.pow(toWidth, i + 1), 1 / stageCount));\n    var height = Math.round(Math.pow(Math.pow(fromHeight, stageCount - i - 1) * Math.pow(toHeight, i + 1), 1 / stageCount));\n    result.push([width, height]);\n  }\n\n  return result;\n};\n\n},{}],15:[function(_dereq_,module,exports){\n// Split original image into multiple 1024x1024 chunks to reduce memory usage\n// (images have to be unpacked into typed arrays for resizing) and allow\n// parallel processing of multiple tiles at a time.\n//\n'use strict';\n/*\n * pixelFloor and pixelCeil are modified versions of Math.floor and Math.ceil\n * functions which take into account floating point arithmetic errors.\n * Those errors can cause undesired increments/decrements of sizes and offsets:\n * Math.ceil(36 / (36 / 500)) = 501\n * pixelCeil(36 / (36 / 500)) = 500\n */\n\nvar PIXEL_EPSILON = 1e-5;\n\nfunction pixelFloor(x) {\n  var nearest = Math.round(x);\n\n  if (Math.abs(x - nearest) < PIXEL_EPSILON) {\n    return nearest;\n  }\n\n  return Math.floor(x);\n}\n\nfunction pixelCeil(x) {\n  var nearest = Math.round(x);\n\n  if (Math.abs(x - nearest) < PIXEL_EPSILON) {\n    return nearest;\n  }\n\n  return Math.ceil(x);\n}\n\nmodule.exports = function createRegions(options) {\n  var scaleX = options.toWidth / options.width;\n  var scaleY = options.toHeight / options.height;\n  var innerTileWidth = pixelFloor(options.srcTileSize * scaleX) - 2 * options.destTileBorder;\n  var innerTileHeight = pixelFloor(options.srcTileSize * scaleY) - 2 * options.destTileBorder; // prevent infinite loop, this should never happen\n\n  if (innerTileWidth < 1 || innerTileHeight < 1) {\n    throw new Error('Internal error in pica: target tile width/height is too small.');\n  }\n\n  var x, y;\n  var innerX, innerY, toTileWidth, toTileHeight;\n  var tiles = [];\n  var tile; // we go top-to-down instead of left-to-right to make image displayed from top to\n  // doesn in the browser\n\n  for (innerY = 0; innerY < options.toHeight; innerY += innerTileHeight) {\n    for (innerX = 0; innerX < options.toWidth; innerX += innerTileWidth) {\n      x = innerX - options.destTileBorder;\n\n      if (x < 0) {\n        x = 0;\n      }\n\n      toTileWidth = innerX + innerTileWidth + options.destTileBorder - x;\n\n      if (x + toTileWidth >= options.toWidth) {\n        toTileWidth = options.toWidth - x;\n      }\n\n      y = innerY - options.destTileBorder;\n\n      if (y < 0) {\n        y = 0;\n      }\n\n      toTileHeight = innerY + innerTileHeight + options.destTileBorder - y;\n\n      if (y + toTileHeight >= options.toHeight) {\n        toTileHeight = options.toHeight - y;\n      }\n\n      tile = {\n        toX: x,\n        toY: y,\n        toWidth: toTileWidth,\n        toHeight: toTileHeight,\n        toInnerX: innerX,\n        toInnerY: innerY,\n        toInnerWidth: innerTileWidth,\n        toInnerHeight: innerTileHeight,\n        offsetX: x / scaleX - pixelFloor(x / scaleX),\n        offsetY: y / scaleY - pixelFloor(y / scaleY),\n        scaleX: scaleX,\n        scaleY: scaleY,\n        x: pixelFloor(x / scaleX),\n        y: pixelFloor(y / scaleY),\n        width: pixelCeil(toTileWidth / scaleX),\n        height: pixelCeil(toTileHeight / scaleY)\n      };\n      tiles.push(tile);\n    }\n  }\n\n  return tiles;\n};\n\n},{}],16:[function(_dereq_,module,exports){\n'use strict';\n\nfunction objClass(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nmodule.exports.isCanvas = function isCanvas(element) {\n  var cname = objClass(element);\n  return cname === '[object HTMLCanvasElement]'\n  /* browser */\n  || cname === '[object OffscreenCanvas]' || cname === '[object Canvas]'\n  /* node-canvas */\n  ;\n};\n\nmodule.exports.isImage = function isImage(element) {\n  return objClass(element) === '[object HTMLImageElement]';\n};\n\nmodule.exports.isImageBitmap = function isImageBitmap(element) {\n  return objClass(element) === '[object ImageBitmap]';\n};\n\nmodule.exports.limiter = function limiter(concurrency) {\n  var active = 0,\n      queue = [];\n\n  function roll() {\n    if (active < concurrency && queue.length) {\n      active++;\n      queue.shift()();\n    }\n  }\n\n  return function limit(fn) {\n    return new Promise(function (resolve, reject) {\n      queue.push(function () {\n        fn().then(function (result) {\n          resolve(result);\n          active--;\n          roll();\n        }, function (err) {\n          reject(err);\n          active--;\n          roll();\n        });\n      });\n      roll();\n    });\n  };\n};\n\nmodule.exports.cib_quality_name = function cib_quality_name(num) {\n  switch (num) {\n    case 0:\n      return 'pixelated';\n\n    case 1:\n      return 'low';\n\n    case 2:\n      return 'medium';\n  }\n\n  return 'high';\n};\n\nmodule.exports.cib_support = function cib_support(createCanvas) {\n  return Promise.resolve().then(function () {\n    if (typeof createImageBitmap === 'undefined') {\n      return false;\n    }\n\n    var c = createCanvas(100, 100);\n    return createImageBitmap(c, 0, 0, 100, 100, {\n      resizeWidth: 10,\n      resizeHeight: 10,\n      resizeQuality: 'high'\n    }).then(function (bitmap) {\n      var status = bitmap.width === 10; // Branch below is filtered on upper level. We do not call resize\n      // detection for basic ImageBitmap.\n      //\n      // https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap\n      // old Crome 51 has ImageBitmap without .close(). Then this code\n      // will throw and return 'false' as expected.\n      //\n\n      bitmap.close();\n      c = null;\n      return status;\n    });\n  })[\"catch\"](function () {\n    return false;\n  });\n};\n\nmodule.exports.worker_offscreen_canvas_support = function worker_offscreen_canvas_support() {\n  return new Promise(function (resolve, reject) {\n    if (typeof OffscreenCanvas === 'undefined') {\n      // if OffscreenCanvas is present, we assume browser supports Worker and built-in Promise as well\n      resolve(false);\n      return;\n    }\n\n    function workerPayload(self) {\n      if (typeof createImageBitmap === 'undefined') {\n        self.postMessage(false);\n        return;\n      }\n\n      Promise.resolve().then(function () {\n        var canvas = new OffscreenCanvas(10, 10); // test that 2d context can be used in worker\n\n        var ctx = canvas.getContext('2d');\n        ctx.rect(0, 0, 1, 1); // test that cib can be used to return image bitmap from worker\n\n        return createImageBitmap(canvas, 0, 0, 1, 1);\n      }).then(function () {\n        return self.postMessage(true);\n      }, function () {\n        return self.postMessage(false);\n      });\n    }\n\n    var code = btoa(\"(\".concat(workerPayload.toString(), \")(self);\"));\n    var w = new Worker(\"data:text/javascript;base64,\".concat(code));\n\n    w.onmessage = function (ev) {\n      return resolve(ev.data);\n    };\n\n    w.onerror = reject;\n  }).then(function (result) {\n    return result;\n  }, function () {\n    return false;\n  });\n}; // Check if canvas.getContext('2d').getImageData can be used,\n// FireFox randomizes the output of that function in `privacy.resistFingerprinting` mode\n\n\nmodule.exports.can_use_canvas = function can_use_canvas(createCanvas) {\n  var usable = false;\n\n  try {\n    var canvas = createCanvas(2, 1);\n    var ctx = canvas.getContext('2d');\n    var d = ctx.createImageData(2, 1);\n    d.data[0] = 12;\n    d.data[1] = 23;\n    d.data[2] = 34;\n    d.data[3] = 255;\n    d.data[4] = 45;\n    d.data[5] = 56;\n    d.data[6] = 67;\n    d.data[7] = 255;\n    ctx.putImageData(d, 0, 0);\n    d = null;\n    d = ctx.getImageData(0, 0, 2, 1);\n\n    if (d.data[0] === 12 && d.data[1] === 23 && d.data[2] === 34 && d.data[3] === 255 && d.data[4] === 45 && d.data[5] === 56 && d.data[6] === 67 && d.data[7] === 255) {\n      usable = true;\n    }\n  } catch (err) {}\n\n  return usable;\n}; // Check if createImageBitmap(img, sx, sy, sw, sh) signature works correctly\n// with JPEG images oriented with Exif;\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1220671\n// TODO: remove after it's fixed in chrome for at least 2 releases\n\n\nmodule.exports.cib_can_use_region = function cib_can_use_region() {\n  return new Promise(function (resolve) {\n    if (typeof createImageBitmap === 'undefined') {\n      resolve(false);\n      return;\n    }\n\n    var image = new Image();\n    image.src = 'data:image/jpeg;base64,' + '/9j/4QBiRXhpZgAATU0AKgAAAAgABQESAAMAAAABAAYAAAEaAAUAAAABAAAASgEbAAUAA' + 'AABAAAAUgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAABIAAAAAQAAAEgAAAAB/9' + 'sAQwAEAwMEAwMEBAMEBQQEBQYKBwYGBgYNCQoICg8NEBAPDQ8OERMYFBESFxIODxUcFRc' + 'ZGRsbGxAUHR8dGh8YGhsa/9sAQwEEBQUGBQYMBwcMGhEPERoaGhoaGhoaGhoaGhoaGhoa' + 'GhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa/8IAEQgAAQACAwERAAIRAQMRA' + 'f/EABQAAQAAAAAAAAAAAAAAAAAAAAf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAA' + 'IQAxAAAAF/P//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAQUCf//EABQRAQAAAAA' + 'AAAAAAAAAAAAAAAD/2gAIAQMBAT8Bf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIB' + 'AT8Bf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEABj8Cf//EABQQAQAAAAAAAAAAA' + 'AAAAAAAAAD/2gAIAQEAAT8hf//aAAwDAQACAAMAAAAQH//EABQRAQAAAAAAAAAAAAAAAA' + 'AAAAD/2gAIAQMBAT8Qf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Qf//EABQ' + 'QAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8Qf//Z';\n\n    image.onload = function () {\n      createImageBitmap(image, 0, 0, image.width, image.height).then(function (bitmap) {\n        if (bitmap.width === image.width && bitmap.height === image.height) {\n          resolve(true);\n        } else {\n          resolve(false);\n        }\n      }, function () {\n        return resolve(false);\n      });\n    };\n\n    image.onerror = function () {\n      return resolve(false);\n    };\n  });\n};\n\n},{}],17:[function(_dereq_,module,exports){\n// Web Worker wrapper for image resize function\n'use strict';\n\nmodule.exports = function () {\n  var MathLib = _dereq_('./mathlib');\n\n  var mathLib;\n  /* eslint-disable no-undef */\n\n  onmessage = function onmessage(ev) {\n    var tileOpts = ev.data.opts;\n    var returnBitmap = false;\n\n    if (!tileOpts.src && tileOpts.srcBitmap) {\n      var canvas = new OffscreenCanvas(tileOpts.width, tileOpts.height);\n      var ctx = canvas.getContext('2d', {\n        alpha: Boolean(tileOpts.alpha)\n      });\n      ctx.drawImage(tileOpts.srcBitmap, 0, 0);\n      tileOpts.src = ctx.getImageData(0, 0, tileOpts.width, tileOpts.height).data;\n      canvas.width = canvas.height = 0;\n      canvas = null;\n      tileOpts.srcBitmap.close();\n      tileOpts.srcBitmap = null; // Temporary force out data to typed array, because Chrome have artefacts\n      // https://github.com/nodeca/pica/issues/223\n      // returnBitmap = true;\n    }\n\n    if (!mathLib) mathLib = new MathLib(ev.data.features); // Use multimath's sync auto-init. Avoid Promise use in old browsers,\n    // because polyfills are not propagated to webworker.\n\n    var data = mathLib.resizeAndUnsharp(tileOpts);\n\n    if (returnBitmap) {\n      var toImageData = new ImageData(new Uint8ClampedArray(data), tileOpts.toWidth, tileOpts.toHeight);\n\n      var _canvas = new OffscreenCanvas(tileOpts.toWidth, tileOpts.toHeight);\n\n      var _ctx = _canvas.getContext('2d', {\n        alpha: Boolean(tileOpts.alpha)\n      });\n\n      _ctx.putImageData(toImageData, 0, 0);\n\n      createImageBitmap(_canvas).then(function (bitmap) {\n        postMessage({\n          bitmap: bitmap\n        }, [bitmap]);\n      });\n    } else {\n      postMessage({\n        data: data\n      }, [data.buffer]);\n    }\n  };\n};\n\n},{\"./mathlib\":1}],18:[function(_dereq_,module,exports){\n// Calculate Gaussian blur of an image using IIR filter\n// The method is taken from Intel's white paper and code example attached to it:\n// https://software.intel.com/en-us/articles/iir-gaussian-blur-filter\n// -implementation-using-intel-advanced-vector-extensions\n\nvar a0, a1, a2, a3, b1, b2, left_corner, right_corner;\n\nfunction gaussCoef(sigma) {\n  if (sigma < 0.5) {\n    sigma = 0.5;\n  }\n\n  var a = Math.exp(0.726 * 0.726) / sigma,\n      g1 = Math.exp(-a),\n      g2 = Math.exp(-2 * a),\n      k = (1 - g1) * (1 - g1) / (1 + 2 * a * g1 - g2);\n\n  a0 = k;\n  a1 = k * (a - 1) * g1;\n  a2 = k * (a + 1) * g1;\n  a3 = -k * g2;\n  b1 = 2 * g1;\n  b2 = -g2;\n  left_corner = (a0 + a1) / (1 - b1 - b2);\n  right_corner = (a2 + a3) / (1 - b1 - b2);\n\n  // Attempt to force type to FP32.\n  return new Float32Array([ a0, a1, a2, a3, b1, b2, left_corner, right_corner ]);\n}\n\nfunction convolveMono16(src, out, line, coeff, width, height) {\n  // takes src image and writes the blurred and transposed result into out\n\n  var prev_src, curr_src, curr_out, prev_out, prev_prev_out;\n  var src_index, out_index, line_index;\n  var i, j;\n  var coeff_a0, coeff_a1, coeff_b1, coeff_b2;\n\n  for (i = 0; i < height; i++) {\n    src_index = i * width;\n    out_index = i;\n    line_index = 0;\n\n    // left to right\n    prev_src = src[src_index];\n    prev_prev_out = prev_src * coeff[6];\n    prev_out = prev_prev_out;\n\n    coeff_a0 = coeff[0];\n    coeff_a1 = coeff[1];\n    coeff_b1 = coeff[4];\n    coeff_b2 = coeff[5];\n\n    for (j = 0; j < width; j++) {\n      curr_src = src[src_index];\n\n      curr_out = curr_src * coeff_a0 +\n                 prev_src * coeff_a1 +\n                 prev_out * coeff_b1 +\n                 prev_prev_out * coeff_b2;\n\n      prev_prev_out = prev_out;\n      prev_out = curr_out;\n      prev_src = curr_src;\n\n      line[line_index] = prev_out;\n      line_index++;\n      src_index++;\n    }\n\n    src_index--;\n    line_index--;\n    out_index += height * (width - 1);\n\n    // right to left\n    prev_src = src[src_index];\n    prev_prev_out = prev_src * coeff[7];\n    prev_out = prev_prev_out;\n    curr_src = prev_src;\n\n    coeff_a0 = coeff[2];\n    coeff_a1 = coeff[3];\n\n    for (j = width - 1; j >= 0; j--) {\n      curr_out = curr_src * coeff_a0 +\n                 prev_src * coeff_a1 +\n                 prev_out * coeff_b1 +\n                 prev_prev_out * coeff_b2;\n\n      prev_prev_out = prev_out;\n      prev_out = curr_out;\n\n      prev_src = curr_src;\n      curr_src = src[src_index];\n\n      out[out_index] = line[line_index] + prev_out;\n\n      src_index--;\n      line_index--;\n      out_index -= height;\n    }\n  }\n}\n\n\nfunction blurMono16(src, width, height, radius) {\n  // Quick exit on zero radius\n  if (!radius) { return; }\n\n  var out      = new Uint16Array(src.length),\n      tmp_line = new Float32Array(Math.max(width, height));\n\n  var coeff = gaussCoef(radius);\n\n  convolveMono16(src, out, tmp_line, coeff, width, height, radius);\n  convolveMono16(out, src, tmp_line, coeff, height, width, radius);\n}\n\nmodule.exports = blurMono16;\n\n},{}],19:[function(_dereq_,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n},{}],20:[function(_dereq_,module,exports){\n'use strict';\n\n\nvar assign         = _dereq_('object-assign');\nvar base64decode   = _dereq_('./lib/base64decode');\nvar hasWebAssembly = _dereq_('./lib/wa_detect');\n\n\nvar DEFAULT_OPTIONS = {\n  js: true,\n  wasm: true\n};\n\n\nfunction MultiMath(options) {\n  if (!(this instanceof MultiMath)) return new MultiMath(options);\n\n  var opts = assign({}, DEFAULT_OPTIONS, options || {});\n\n  this.options         = opts;\n\n  this.__cache         = {};\n\n  this.__init_promise  = null;\n  this.__modules       = opts.modules || {};\n  this.__memory        = null;\n  this.__wasm          = {};\n\n  this.__isLE = ((new Uint32Array((new Uint8Array([ 1, 0, 0, 0 ])).buffer))[0] === 1);\n\n  if (!this.options.js && !this.options.wasm) {\n    throw new Error('mathlib: at least \"js\" or \"wasm\" should be enabled');\n  }\n}\n\n\nMultiMath.prototype.has_wasm = hasWebAssembly;\n\n\nMultiMath.prototype.use = function (module) {\n  this.__modules[module.name] = module;\n\n  // Pin the best possible implementation\n  if (this.options.wasm && this.has_wasm() && module.wasm_fn) {\n    this[module.name] = module.wasm_fn;\n  } else {\n    this[module.name] = module.fn;\n  }\n\n  return this;\n};\n\n\nMultiMath.prototype.init = function () {\n  if (this.__init_promise) return this.__init_promise;\n\n  if (!this.options.js && this.options.wasm && !this.has_wasm()) {\n    return Promise.reject(new Error('mathlib: only \"wasm\" was enabled, but it\\'s not supported'));\n  }\n\n  var self = this;\n\n  this.__init_promise = Promise.all(Object.keys(self.__modules).map(function (name) {\n    var module = self.__modules[name];\n\n    if (!self.options.wasm || !self.has_wasm() || !module.wasm_fn) return null;\n\n    // If already compiled - exit\n    if (self.__wasm[name]) return null;\n\n    // Compile wasm source\n    return WebAssembly.compile(self.__base64decode(module.wasm_src))\n      .then(function (m) { self.__wasm[name] = m; });\n  }))\n    .then(function () { return self; });\n\n  return this.__init_promise;\n};\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Methods below are for internal use from plugins\n\n\n// Simple decode base64 to typed array. Useful to load embedded webassembly\n// code. You probably don't need to call this method directly.\n//\nMultiMath.prototype.__base64decode = base64decode;\n\n\n// Increase current memory to include specified number of bytes. Do nothing if\n// size is already ok. You probably don't need to call this method directly,\n// because it will be invoked from `.__instance()`.\n//\nMultiMath.prototype.__reallocate = function mem_grow_to(bytes) {\n  if (!this.__memory) {\n    this.__memory = new WebAssembly.Memory({\n      initial: Math.ceil(bytes / (64 * 1024))\n    });\n    return this.__memory;\n  }\n\n  var mem_size = this.__memory.buffer.byteLength;\n\n  if (mem_size < bytes) {\n    this.__memory.grow(Math.ceil((bytes - mem_size) / (64 * 1024)));\n  }\n\n  return this.__memory;\n};\n\n\n// Returns instantinated webassembly item by name, with specified memory size\n// and environment.\n// - use cache if available\n// - do sync module init, if async init was not called earlier\n// - allocate memory if not enougth\n// - can export functions to webassembly via \"env_extra\",\n//   for example, { exp: Math.exp }\n//\nMultiMath.prototype.__instance = function instance(name, memsize, env_extra) {\n  if (memsize) this.__reallocate(memsize);\n\n  // If .init() was not called, do sync compile\n  if (!this.__wasm[name]) {\n    var module = this.__modules[name];\n    this.__wasm[name] = new WebAssembly.Module(this.__base64decode(module.wasm_src));\n  }\n\n  if (!this.__cache[name]) {\n    var env_base = {\n      memoryBase: 0,\n      memory: this.__memory,\n      tableBase: 0,\n      table: new WebAssembly.Table({ initial: 0, element: 'anyfunc' })\n    };\n\n    this.__cache[name] = new WebAssembly.Instance(this.__wasm[name], {\n      env: assign(env_base, env_extra || {})\n    });\n  }\n\n  return this.__cache[name];\n};\n\n\n// Helper to calculate memory aligh for pointers. Webassembly does not require\n// this, but you may wish to experiment. Default base = 8;\n//\nMultiMath.prototype.__align = function align(number, base) {\n  base = base || 8;\n  var reminder = number % base;\n  return number + (reminder ? base - reminder : 0);\n};\n\n\nmodule.exports = MultiMath;\n\n},{\"./lib/base64decode\":21,\"./lib/wa_detect\":22,\"object-assign\":23}],21:[function(_dereq_,module,exports){\n// base64 decode str -> Uint8Array, to load WA modules\n//\n'use strict';\n\n\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n\nmodule.exports = function base64decode(str) {\n  var input = str.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max   = input.length;\n\n  var out = new Uint8Array((max * 3) >> 2);\n\n  // Collect by 6*4 bits (3 bytes)\n\n  var bits = 0;\n  var ptr  = 0;\n\n  for (var idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      out[ptr++] = (bits >> 16) & 0xFF;\n      out[ptr++] = (bits >> 8) & 0xFF;\n      out[ptr++] = bits & 0xFF;\n    }\n\n    bits = (bits << 6) | BASE64_MAP.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  var tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    out[ptr++] = (bits >> 16) & 0xFF;\n    out[ptr++] = (bits >> 8) & 0xFF;\n    out[ptr++] = bits & 0xFF;\n  } else if (tailbits === 18) {\n    out[ptr++] = (bits >> 10) & 0xFF;\n    out[ptr++] = (bits >> 2) & 0xFF;\n  } else if (tailbits === 12) {\n    out[ptr++] = (bits >> 4) & 0xFF;\n  }\n\n  return out;\n};\n\n},{}],22:[function(_dereq_,module,exports){\n// Detect WebAssembly support.\n// - Check global WebAssembly object\n// - Try to load simple module (can be disabled via CSP)\n//\n'use strict';\n\n\nvar wa;\n\n\nmodule.exports = function hasWebAssembly() {\n  // use cache if called before;\n  if (typeof wa !== 'undefined') return wa;\n\n  wa = false;\n\n  if (typeof WebAssembly === 'undefined') return wa;\n\n  // If WebAssenbly is disabled, code can throw on compile\n  try {\n    // https://github.com/brion/min-wasm-fail/blob/master/min-wasm-fail.in.js\n    // Additional check that WA internals are correct\n\n    /* eslint-disable comma-spacing, max-len */\n    var bin      = new Uint8Array([ 0,97,115,109,1,0,0,0,1,6,1,96,1,127,1,127,3,2,1,0,5,3,1,0,1,7,8,1,4,116,101,115,116,0,0,10,16,1,14,0,32,0,65,1,54,2,0,32,0,40,2,0,11 ]);\n    var module   = new WebAssembly.Module(bin);\n    var instance = new WebAssembly.Instance(module, {});\n\n    // test storing to and loading from a non-zero location via a parameter.\n    // Safari on iOS 11.2.5 returns 0 unexpectedly at non-zero locations\n    if (instance.exports.test(4) !== 0) wa = true;\n\n    return wa;\n  } catch (__) {}\n\n  return wa;\n};\n\n},{}],23:[function(_dereq_,module,exports){\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n},{}],24:[function(_dereq_,module,exports){\nvar bundleFn = arguments[3];\nvar sources = arguments[4];\nvar cache = arguments[5];\n\nvar stringify = JSON.stringify;\n\nmodule.exports = function (fn, options) {\n    var wkey;\n    var cacheKeys = Object.keys(cache);\n\n    for (var i = 0, l = cacheKeys.length; i < l; i++) {\n        var key = cacheKeys[i];\n        var exp = cache[key].exports;\n        // Using babel as a transpiler to use esmodule, the export will always\n        // be an object with the default export as a property of it. To ensure\n        // the existing api and babel esmodule exports are both supported we\n        // check for both\n        if (exp === fn || exp && exp.default === fn) {\n            wkey = key;\n            break;\n        }\n    }\n\n    if (!wkey) {\n        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n        var wcache = {};\n        for (var i = 0, l = cacheKeys.length; i < l; i++) {\n            var key = cacheKeys[i];\n            wcache[key] = key;\n        }\n        sources[wkey] = [\n            'function(require,module,exports){' + fn + '(self); }',\n            wcache\n        ];\n    }\n    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n\n    var scache = {}; scache[wkey] = wkey;\n    sources[skey] = [\n        'function(require,module,exports){' +\n            // try to call default if defined to also support babel esmodule exports\n            'var f = require(' + stringify(wkey) + ');' +\n            '(f.default ? f.default : f)(self);' +\n        '}',\n        scache\n    ];\n\n    var workerSources = {};\n    resolveSources(skey);\n\n    function resolveSources(key) {\n        workerSources[key] = true;\n\n        for (var depPath in sources[key][1]) {\n            var depKey = sources[key][1][depPath];\n            if (!workerSources[depKey]) {\n                resolveSources(depKey);\n            }\n        }\n    }\n\n    var src = '(' + bundleFn + ')({'\n        + Object.keys(workerSources).map(function (key) {\n            return stringify(key) + ':['\n                + sources[key][0]\n                + ',' + stringify(sources[key][1]) + ']'\n            ;\n        }).join(',')\n        + '},{},[' + stringify(skey) + '])'\n    ;\n\n    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n    var blob = new Blob([src], { type: 'text/javascript' });\n    if (options && options.bare) { return blob; }\n    var workerUrl = URL.createObjectURL(blob);\n    var worker = new Worker(workerUrl);\n    worker.objectURL = workerUrl;\n    return worker;\n};\n\n},{}],\"/index.js\":[function(_dereq_,module,exports){\n'use strict';\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar assign = _dereq_('object-assign');\n\nvar webworkify = _dereq_('webworkify');\n\nvar MathLib = _dereq_('./lib/mathlib');\n\nvar Pool = _dereq_('./lib/pool');\n\nvar utils = _dereq_('./lib/utils');\n\nvar worker = _dereq_('./lib/worker');\n\nvar createStages = _dereq_('./lib/stepper');\n\nvar createRegions = _dereq_('./lib/tiler'); // Deduplicate pools & limiters with the same configs\n// when user creates multiple pica instances.\n\n\nvar singletones = {};\nvar NEED_SAFARI_FIX = false;\n\ntry {\n  if (typeof navigator !== 'undefined' && navigator.userAgent) {\n    NEED_SAFARI_FIX = navigator.userAgent.indexOf('Safari') >= 0;\n  }\n} catch (e) {}\n\nvar concurrency = 1;\n\nif (typeof navigator !== 'undefined') {\n  concurrency = Math.min(navigator.hardwareConcurrency || 1, 4);\n}\n\nvar DEFAULT_PICA_OPTS = {\n  tile: 1024,\n  concurrency: concurrency,\n  features: ['js', 'wasm', 'ww'],\n  idle: 2000,\n  createCanvas: function createCanvas(width, height) {\n    var tmpCanvas = document.createElement('canvas');\n    tmpCanvas.width = width;\n    tmpCanvas.height = height;\n    return tmpCanvas;\n  }\n};\nvar DEFAULT_RESIZE_OPTS = {\n  quality: 3,\n  alpha: false,\n  unsharpAmount: 0,\n  unsharpRadius: 0.0,\n  unsharpThreshold: 0\n};\nvar CAN_NEW_IMAGE_DATA = false;\nvar CAN_CREATE_IMAGE_BITMAP = false;\nvar CAN_USE_CANVAS_GET_IMAGE_DATA = false;\nvar CAN_USE_OFFSCREEN_CANVAS = false;\nvar CAN_USE_CIB_REGION_FOR_IMAGE = false;\n\nfunction workerFabric() {\n  return {\n    value: webworkify(worker),\n    destroy: function destroy() {\n      this.value.terminate();\n\n      if (typeof window !== 'undefined') {\n        var url = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n        if (url && url.revokeObjectURL && this.value.objectURL) {\n          url.revokeObjectURL(this.value.objectURL);\n        }\n      }\n    }\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n// API methods\n\n\nfunction Pica(options) {\n  if (!(this instanceof Pica)) return new Pica(options);\n  this.options = assign({}, DEFAULT_PICA_OPTS, options || {});\n  var limiter_key = \"lk_\".concat(this.options.concurrency); // Share limiters to avoid multiple parallel workers when user creates\n  // multiple pica instances.\n\n  this.__limit = singletones[limiter_key] || utils.limiter(this.options.concurrency);\n  if (!singletones[limiter_key]) singletones[limiter_key] = this.__limit; // List of supported features, according to options & browser/node.js\n\n  this.features = {\n    js: false,\n    // pure JS implementation, can be disabled for testing\n    wasm: false,\n    // webassembly implementation for heavy functions\n    cib: false,\n    // resize via createImageBitmap (only FF at this moment)\n    ww: false // webworkers\n\n  };\n  this.__workersPool = null; // Store requested features for webworkers\n\n  this.__requested_features = [];\n  this.__mathlib = null;\n}\n\nPica.prototype.init = function () {\n  var _this = this;\n\n  if (this.__initPromise) return this.__initPromise; // Test if we can create ImageData without canvas and memory copy\n\n  if (typeof ImageData !== 'undefined' && typeof Uint8ClampedArray !== 'undefined') {\n    try {\n      /* eslint-disable no-new */\n      new ImageData(new Uint8ClampedArray(400), 10, 10);\n      CAN_NEW_IMAGE_DATA = true;\n    } catch (__) {}\n  } // ImageBitmap can be effective in 2 places:\n  //\n  // 1. Threaded jpeg unpack (basic)\n  // 2. Built-in resize (blocked due problem in chrome, see issue #89)\n  //\n  // For basic use we also need ImageBitmap wo support .close() method,\n  // see https://developer.mozilla.org/ru/docs/Web/API/ImageBitmap\n\n\n  if (typeof ImageBitmap !== 'undefined') {\n    if (ImageBitmap.prototype && ImageBitmap.prototype.close) {\n      CAN_CREATE_IMAGE_BITMAP = true;\n    } else {\n      this.debug('ImageBitmap does not support .close(), disabled');\n    }\n  }\n\n  var features = this.options.features.slice();\n\n  if (features.indexOf('all') >= 0) {\n    features = ['cib', 'wasm', 'js', 'ww'];\n  }\n\n  this.__requested_features = features;\n  this.__mathlib = new MathLib(features); // Check WebWorker support if requested\n\n  if (features.indexOf('ww') >= 0) {\n    if (typeof window !== 'undefined' && 'Worker' in window) {\n      // IE <= 11 don't allow to create webworkers from string. We should check it.\n      // https://connect.microsoft.com/IE/feedback/details/801810/web-workers-from-blob-urls-in-ie-10-and-11\n      try {\n        var wkr = _dereq_('webworkify')(function () {});\n\n        wkr.terminate();\n        this.features.ww = true; // pool uniqueness depends on pool config + webworker config\n\n        var wpool_key = \"wp_\".concat(JSON.stringify(this.options));\n\n        if (singletones[wpool_key]) {\n          this.__workersPool = singletones[wpool_key];\n        } else {\n          this.__workersPool = new Pool(workerFabric, this.options.idle);\n          singletones[wpool_key] = this.__workersPool;\n        }\n      } catch (__) {}\n    }\n  }\n\n  var initMath = this.__mathlib.init().then(function (mathlib) {\n    // Copy detected features\n    assign(_this.features, mathlib.features);\n  });\n\n  var checkCibResize;\n\n  if (!CAN_CREATE_IMAGE_BITMAP) {\n    checkCibResize = Promise.resolve(false);\n  } else {\n    checkCibResize = utils.cib_support(this.options.createCanvas).then(function (status) {\n      if (_this.features.cib && features.indexOf('cib') < 0) {\n        _this.debug('createImageBitmap() resize supported, but disabled by config');\n\n        return;\n      }\n\n      if (features.indexOf('cib') >= 0) _this.features.cib = status;\n    });\n  }\n\n  CAN_USE_CANVAS_GET_IMAGE_DATA = utils.can_use_canvas(this.options.createCanvas);\n  var checkOffscreenCanvas;\n\n  if (CAN_CREATE_IMAGE_BITMAP && CAN_NEW_IMAGE_DATA && features.indexOf('ww') !== -1) {\n    checkOffscreenCanvas = utils.worker_offscreen_canvas_support();\n  } else {\n    checkOffscreenCanvas = Promise.resolve(false);\n  }\n\n  checkOffscreenCanvas = checkOffscreenCanvas.then(function (result) {\n    CAN_USE_OFFSCREEN_CANVAS = result;\n  }); // we use createImageBitmap to crop image data and pass it to workers,\n  // so need to check whether function works correctly;\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1220671\n\n  var checkCibRegion = utils.cib_can_use_region().then(function (result) {\n    CAN_USE_CIB_REGION_FOR_IMAGE = result;\n  }); // Init math lib. That's async because can load some\n\n  this.__initPromise = Promise.all([initMath, checkCibResize, checkOffscreenCanvas, checkCibRegion]).then(function () {\n    return _this;\n  });\n  return this.__initPromise;\n}; // Call resizer in webworker or locally, depending on config\n\n\nPica.prototype.__invokeResize = function (tileOpts, opts) {\n  var _this2 = this;\n\n  // Share cache between calls:\n  //\n  // - wasm instance\n  // - wasm memory object\n  //\n  opts.__mathCache = opts.__mathCache || {};\n  return Promise.resolve().then(function () {\n    if (!_this2.features.ww) {\n      // not possible to have ImageBitmap here if user disabled WW\n      return {\n        data: _this2.__mathlib.resizeAndUnsharp(tileOpts, opts.__mathCache)\n      };\n    }\n\n    return new Promise(function (resolve, reject) {\n      var w = _this2.__workersPool.acquire();\n\n      if (opts.cancelToken) opts.cancelToken[\"catch\"](function (err) {\n        return reject(err);\n      });\n\n      w.value.onmessage = function (ev) {\n        w.release();\n        if (ev.data.err) reject(ev.data.err);else resolve(ev.data);\n      };\n\n      var transfer = [];\n      if (tileOpts.src) transfer.push(tileOpts.src.buffer);\n      if (tileOpts.srcBitmap) transfer.push(tileOpts.srcBitmap);\n      w.value.postMessage({\n        opts: tileOpts,\n        features: _this2.__requested_features,\n        preload: {\n          wasm_nodule: _this2.__mathlib.__\n        }\n      }, transfer);\n    });\n  });\n}; // this function can return promise if createImageBitmap is used\n\n\nPica.prototype.__extractTileData = function (tile, from, opts, stageEnv, extractTo) {\n  if (this.features.ww && CAN_USE_OFFSCREEN_CANVAS && ( // createImageBitmap doesn't work for images (Image, ImageBitmap) with Exif orientation in Chrome,\n  // can use canvas because canvas doesn't have orientation;\n  // see https://bugs.chromium.org/p/chromium/issues/detail?id=1220671\n  utils.isCanvas(from) || CAN_USE_CIB_REGION_FOR_IMAGE)) {\n    this.debug('Create tile for OffscreenCanvas');\n    return createImageBitmap(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height).then(function (bitmap) {\n      extractTo.srcBitmap = bitmap;\n      return extractTo;\n    });\n  } // Extract tile RGBA buffer, depending on input type\n\n\n  if (utils.isCanvas(from)) {\n    if (!stageEnv.srcCtx) stageEnv.srcCtx = from.getContext('2d', {\n      alpha: Boolean(opts.alpha)\n    }); // If input is Canvas - extract region data directly\n\n    this.debug('Get tile pixel data');\n    extractTo.src = stageEnv.srcCtx.getImageData(tile.x, tile.y, tile.width, tile.height).data;\n    return extractTo;\n  } // If input is Image or decoded to ImageBitmap,\n  // draw region to temporary canvas and extract data from it\n  //\n  // Note! Attempt to reuse this canvas causes significant slowdown in chrome\n  //\n\n\n  this.debug('Draw tile imageBitmap/image to temporary canvas');\n  var tmpCanvas = this.options.createCanvas(tile.width, tile.height);\n  var tmpCtx = tmpCanvas.getContext('2d', {\n    alpha: Boolean(opts.alpha)\n  });\n  tmpCtx.globalCompositeOperation = 'copy';\n  tmpCtx.drawImage(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height, 0, 0, tile.width, tile.height);\n  this.debug('Get tile pixel data');\n  extractTo.src = tmpCtx.getImageData(0, 0, tile.width, tile.height).data; // Safari 12 workaround\n  // https://github.com/nodeca/pica/issues/199\n\n  tmpCanvas.width = tmpCanvas.height = 0;\n  return extractTo;\n};\n\nPica.prototype.__landTileData = function (tile, result, stageEnv) {\n  var toImageData;\n  this.debug('Convert raw rgba tile result to ImageData');\n\n  if (result.bitmap) {\n    stageEnv.toCtx.drawImage(result.bitmap, tile.toX, tile.toY);\n    return null;\n  }\n\n  if (CAN_NEW_IMAGE_DATA) {\n    // this branch is for modern browsers\n    // If `new ImageData()` & Uint8ClampedArray suported\n    toImageData = new ImageData(new Uint8ClampedArray(result.data), tile.toWidth, tile.toHeight);\n  } else {\n    // fallback for `node-canvas` and old browsers\n    // (IE11 has ImageData but does not support `new ImageData()`)\n    toImageData = stageEnv.toCtx.createImageData(tile.toWidth, tile.toHeight);\n\n    if (toImageData.data.set) {\n      toImageData.data.set(result.data);\n    } else {\n      // IE9 don't have `.set()`\n      for (var i = toImageData.data.length - 1; i >= 0; i--) {\n        toImageData.data[i] = result.data[i];\n      }\n    }\n  }\n\n  this.debug('Draw tile');\n\n  if (NEED_SAFARI_FIX) {\n    // Safari draws thin white stripes between tiles without this fix\n    stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth + 1e-5, tile.toInnerHeight + 1e-5);\n  } else {\n    stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth, tile.toInnerHeight);\n  }\n\n  return null;\n};\n\nPica.prototype.__tileAndResize = function (from, to, opts) {\n  var _this3 = this;\n\n  var stageEnv = {\n    srcCtx: null,\n    srcImageBitmap: null,\n    isImageBitmapReused: false,\n    toCtx: null\n  };\n\n  var processTile = function processTile(tile) {\n    return _this3.__limit(function () {\n      if (opts.canceled) return opts.cancelToken;\n      var tileOpts = {\n        width: tile.width,\n        height: tile.height,\n        toWidth: tile.toWidth,\n        toHeight: tile.toHeight,\n        scaleX: tile.scaleX,\n        scaleY: tile.scaleY,\n        offsetX: tile.offsetX,\n        offsetY: tile.offsetY,\n        quality: opts.quality,\n        alpha: opts.alpha,\n        unsharpAmount: opts.unsharpAmount,\n        unsharpRadius: opts.unsharpRadius,\n        unsharpThreshold: opts.unsharpThreshold\n      };\n\n      _this3.debug('Invoke resize math');\n\n      return Promise.resolve(tileOpts).then(function (tileOpts) {\n        return _this3.__extractTileData(tile, from, opts, stageEnv, tileOpts);\n      }).then(function (tileOpts) {\n        _this3.debug('Invoke resize math');\n\n        return _this3.__invokeResize(tileOpts, opts);\n      }).then(function (result) {\n        if (opts.canceled) return opts.cancelToken;\n        stageEnv.srcImageData = null;\n        return _this3.__landTileData(tile, result, stageEnv);\n      });\n    });\n  }; // Need to normalize data source first. It can be canvas or image.\n  // If image - try to decode in background if possible\n\n\n  return Promise.resolve().then(function () {\n    stageEnv.toCtx = to.getContext('2d', {\n      alpha: Boolean(opts.alpha)\n    });\n    if (utils.isCanvas(from)) return null;\n\n    if (utils.isImageBitmap(from)) {\n      stageEnv.srcImageBitmap = from;\n      stageEnv.isImageBitmapReused = true;\n      return null;\n    }\n\n    if (utils.isImage(from)) {\n      // try do decode image in background for faster next operations;\n      // if we're using offscreen canvas, cib is called per tile, so not needed here\n      if (!CAN_CREATE_IMAGE_BITMAP) return null;\n\n      _this3.debug('Decode image via createImageBitmap');\n\n      return createImageBitmap(from).then(function (imageBitmap) {\n        stageEnv.srcImageBitmap = imageBitmap;\n      }) // Suppress error to use fallback, if method fails\n      // https://github.com/nodeca/pica/issues/190\n\n      /* eslint-disable no-unused-vars */\n      [\"catch\"](function (e) {\n        return null;\n      });\n    }\n\n    throw new Error('Pica: \".from\" should be Image, Canvas or ImageBitmap');\n  }).then(function () {\n    if (opts.canceled) return opts.cancelToken;\n\n    _this3.debug('Calculate tiles'); //\n    // Here we are with \"normalized\" source,\n    // follow to tiling\n    //\n\n\n    var regions = createRegions({\n      width: opts.width,\n      height: opts.height,\n      srcTileSize: _this3.options.tile,\n      toWidth: opts.toWidth,\n      toHeight: opts.toHeight,\n      destTileBorder: opts.__destTileBorder\n    });\n    var jobs = regions.map(function (tile) {\n      return processTile(tile);\n    });\n\n    function cleanup(stageEnv) {\n      if (stageEnv.srcImageBitmap) {\n        if (!stageEnv.isImageBitmapReused) stageEnv.srcImageBitmap.close();\n        stageEnv.srcImageBitmap = null;\n      }\n    }\n\n    _this3.debug('Process tiles');\n\n    return Promise.all(jobs).then(function () {\n      _this3.debug('Finished!');\n\n      cleanup(stageEnv);\n      return to;\n    }, function (err) {\n      cleanup(stageEnv);\n      throw err;\n    });\n  });\n};\n\nPica.prototype.__processStages = function (stages, from, to, opts) {\n  var _this4 = this;\n\n  if (opts.canceled) return opts.cancelToken;\n\n  var _stages$shift = stages.shift(),\n      _stages$shift2 = _slicedToArray(_stages$shift, 2),\n      toWidth = _stages$shift2[0],\n      toHeight = _stages$shift2[1];\n\n  var isLastStage = stages.length === 0;\n  opts = assign({}, opts, {\n    toWidth: toWidth,\n    toHeight: toHeight,\n    // only use user-defined quality for the last stage,\n    // use simpler (Hamming) filter for the first stages where\n    // scale factor is large enough (more than 2-3)\n    quality: isLastStage ? opts.quality : Math.min(1, opts.quality)\n  });\n  var tmpCanvas;\n\n  if (!isLastStage) {\n    // create temporary canvas\n    tmpCanvas = this.options.createCanvas(toWidth, toHeight);\n  }\n\n  return this.__tileAndResize(from, isLastStage ? to : tmpCanvas, opts).then(function () {\n    if (isLastStage) return to;\n    opts.width = toWidth;\n    opts.height = toHeight;\n    return _this4.__processStages(stages, tmpCanvas, to, opts);\n  }).then(function (res) {\n    if (tmpCanvas) {\n      // Safari 12 workaround\n      // https://github.com/nodeca/pica/issues/199\n      tmpCanvas.width = tmpCanvas.height = 0;\n    }\n\n    return res;\n  });\n};\n\nPica.prototype.__resizeViaCreateImageBitmap = function (from, to, opts) {\n  var _this5 = this;\n\n  var toCtx = to.getContext('2d', {\n    alpha: Boolean(opts.alpha)\n  });\n  this.debug('Resize via createImageBitmap()');\n  return createImageBitmap(from, {\n    resizeWidth: opts.toWidth,\n    resizeHeight: opts.toHeight,\n    resizeQuality: utils.cib_quality_name(opts.quality)\n  }).then(function (imageBitmap) {\n    if (opts.canceled) return opts.cancelToken; // if no unsharp - draw directly to output canvas\n\n    if (!opts.unsharpAmount) {\n      toCtx.drawImage(imageBitmap, 0, 0);\n      imageBitmap.close();\n      toCtx = null;\n\n      _this5.debug('Finished!');\n\n      return to;\n    }\n\n    _this5.debug('Unsharp result');\n\n    var tmpCanvas = _this5.options.createCanvas(opts.toWidth, opts.toHeight);\n\n    var tmpCtx = tmpCanvas.getContext('2d', {\n      alpha: Boolean(opts.alpha)\n    });\n    tmpCtx.drawImage(imageBitmap, 0, 0);\n    imageBitmap.close();\n    var iData = tmpCtx.getImageData(0, 0, opts.toWidth, opts.toHeight);\n\n    _this5.__mathlib.unsharp_mask(iData.data, opts.toWidth, opts.toHeight, opts.unsharpAmount, opts.unsharpRadius, opts.unsharpThreshold);\n\n    toCtx.putImageData(iData, 0, 0); // Safari 12 workaround\n    // https://github.com/nodeca/pica/issues/199\n\n    tmpCanvas.width = tmpCanvas.height = 0;\n    iData = tmpCtx = tmpCanvas = toCtx = null;\n\n    _this5.debug('Finished!');\n\n    return to;\n  });\n};\n\nPica.prototype.resize = function (from, to, options) {\n  var _this6 = this;\n\n  this.debug('Start resize...');\n  var opts = assign({}, DEFAULT_RESIZE_OPTS);\n\n  if (!isNaN(options)) {\n    opts = assign(opts, {\n      quality: options\n    });\n  } else if (options) {\n    opts = assign(opts, options);\n  }\n\n  opts.toWidth = to.width;\n  opts.toHeight = to.height;\n  opts.width = from.naturalWidth || from.width;\n  opts.height = from.naturalHeight || from.height; // Prevent stepper from infinite loop\n\n  if (to.width === 0 || to.height === 0) {\n    return Promise.reject(new Error(\"Invalid output size: \".concat(to.width, \"x\").concat(to.height)));\n  }\n\n  if (opts.unsharpRadius > 2) opts.unsharpRadius = 2;\n  opts.canceled = false;\n\n  if (opts.cancelToken) {\n    // Wrap cancelToken to avoid successive resolve & set flag\n    opts.cancelToken = opts.cancelToken.then(function (data) {\n      opts.canceled = true;\n      throw data;\n    }, function (err) {\n      opts.canceled = true;\n      throw err;\n    });\n  }\n\n  var DEST_TILE_BORDER = 3; // Max possible filter window size\n\n  opts.__destTileBorder = Math.ceil(Math.max(DEST_TILE_BORDER, 2.5 * opts.unsharpRadius | 0));\n  return this.init().then(function () {\n    if (opts.canceled) return opts.cancelToken; // if createImageBitmap supports resize, just do it and return\n\n    if (_this6.features.cib) {\n      return _this6.__resizeViaCreateImageBitmap(from, to, opts);\n    }\n\n    if (!CAN_USE_CANVAS_GET_IMAGE_DATA) {\n      var err = new Error('Pica: cannot use getImageData on canvas, ' + \"make sure fingerprinting protection isn't enabled\");\n      err.code = 'ERR_GET_IMAGE_DATA';\n      throw err;\n    } //\n    // No easy way, let's resize manually via arrays\n    //\n\n\n    var stages = createStages(opts.width, opts.height, opts.toWidth, opts.toHeight, _this6.options.tile, opts.__destTileBorder);\n    return _this6.__processStages(stages, from, to, opts);\n  });\n}; // RGBA buffer resize\n//\n\n\nPica.prototype.resizeBuffer = function (options) {\n  var _this7 = this;\n\n  var opts = assign({}, DEFAULT_RESIZE_OPTS, options);\n  return this.init().then(function () {\n    return _this7.__mathlib.resizeAndUnsharp(opts);\n  });\n};\n\nPica.prototype.toBlob = function (canvas, mimeType, quality) {\n  mimeType = mimeType || 'image/png';\n  return new Promise(function (resolve) {\n    if (canvas.toBlob) {\n      canvas.toBlob(function (blob) {\n        return resolve(blob);\n      }, mimeType, quality);\n      return;\n    }\n\n    if (canvas.convertToBlob) {\n      resolve(canvas.convertToBlob({\n        type: mimeType,\n        quality: quality\n      }));\n      return;\n    } // Fallback for old browsers\n\n\n    var asString = atob(canvas.toDataURL(mimeType, quality).split(',')[1]);\n    var len = asString.length;\n    var asBuffer = new Uint8Array(len);\n\n    for (var i = 0; i < len; i++) {\n      asBuffer[i] = asString.charCodeAt(i);\n    }\n\n    resolve(new Blob([asBuffer], {\n      type: mimeType\n    }));\n  });\n};\n\nPica.prototype.debug = function () {};\n\nmodule.exports = Pica;\n\n},{\"./lib/mathlib\":1,\"./lib/pool\":13,\"./lib/stepper\":14,\"./lib/tiler\":15,\"./lib/utils\":16,\"./lib/worker\":17,\"object-assign\":23,\"webworkify\":24}]},{},[])(\"/index.js\")\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpY2FANy4xLjEvbm9kZV9tb2R1bGVzL3BpY2EvZGlzdC9waWNhLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxHQUFHLElBQXNELEVBQUUsbUJBQW1CLEtBQUssVUFBNk4sQ0FBQyxhQUFhLDBCQUEwQixtQkFBbUIsa0JBQWtCLGdCQUFnQixVQUFVLFVBQVUsTUFBTSxTQUFtQyxDQUFDLGdCQUFnQixPQUFDLE9BQU8sb0JBQW9CLDhDQUE4QyxrQ0FBa0MsWUFBWSxZQUFZLG1DQUFtQyxpQkFBaUIsZUFBZSxzQkFBc0Isb0JBQW9CLFVBQVUsU0FBbUMsS0FBSyxXQUFXLFlBQVksU0FBUyxTQUFTLEtBQUs7QUFDenpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxtRUFBbUU7QUFDdEU7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCLGlCQUFpQixhQUFhO0FBQzlCLG1CQUFtQjs7QUFFbkIsb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCLGFBQWEsZ0JBQWdCO0FBQzdCLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSw0SUFBNEksRUFBRSxHQUFHO0FBQ3BKLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3BpY2FANy4xLjEvbm9kZV9tb2R1bGVzL3BpY2EvZGlzdC9waWNhLmpzPzBhYjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG5cbnBpY2Fcbmh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYVxuXG4qL1xuXG4oZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5waWNhID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb2xsZWN0aW9uIG9mIG1hdGggZnVuY3Rpb25zXG4vL1xuLy8gMS4gQ29tYmluZSBjb21wb25lbnRzIHRvZ2V0aGVyXG4vLyAyLiBIYXMgYXN5bmMgaW5pdCB0byBsb2FkIHdhc20gbW9kdWxlc1xuLy9cbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTtcblxudmFyIE11bHRpbWF0aCA9IF9kZXJlcV8oJ211bHRpbWF0aCcpO1xuXG52YXIgbW1fdW5zaGFycF9tYXNrID0gX2RlcmVxXygnLi9tbV91bnNoYXJwX21hc2snKTtcblxudmFyIG1tX3Jlc2l6ZSA9IF9kZXJlcV8oJy4vbW1fcmVzaXplJyk7XG5cbmZ1bmN0aW9uIE1hdGhMaWIocmVxdWVzdGVkX2ZlYXR1cmVzKSB7XG4gIHZhciBfX3JlcXVlc3RlZF9mZWF0dXJlcyA9IHJlcXVlc3RlZF9mZWF0dXJlcyB8fCBbXTtcblxuICB2YXIgZmVhdHVyZXMgPSB7XG4gICAganM6IF9fcmVxdWVzdGVkX2ZlYXR1cmVzLmluZGV4T2YoJ2pzJykgPj0gMCxcbiAgICB3YXNtOiBfX3JlcXVlc3RlZF9mZWF0dXJlcy5pbmRleE9mKCd3YXNtJykgPj0gMFxuICB9O1xuICBNdWx0aW1hdGguY2FsbCh0aGlzLCBmZWF0dXJlcyk7XG4gIHRoaXMuZmVhdHVyZXMgPSB7XG4gICAganM6IGZlYXR1cmVzLmpzLFxuICAgIHdhc206IGZlYXR1cmVzLndhc20gJiYgdGhpcy5oYXNfd2FzbSgpXG4gIH07XG4gIHRoaXMudXNlKG1tX3Vuc2hhcnBfbWFzayk7XG4gIHRoaXMudXNlKG1tX3Jlc2l6ZSk7XG59XG5cbmluaGVyaXRzKE1hdGhMaWIsIE11bHRpbWF0aCk7XG5cbk1hdGhMaWIucHJvdG90eXBlLnJlc2l6ZUFuZFVuc2hhcnAgPSBmdW5jdGlvbiByZXNpemVBbmRVbnNoYXJwKG9wdGlvbnMsIGNhY2hlKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLnJlc2l6ZShvcHRpb25zLCBjYWNoZSk7XG5cbiAgaWYgKG9wdGlvbnMudW5zaGFycEFtb3VudCkge1xuICAgIHRoaXMudW5zaGFycF9tYXNrKHJlc3VsdCwgb3B0aW9ucy50b1dpZHRoLCBvcHRpb25zLnRvSGVpZ2h0LCBvcHRpb25zLnVuc2hhcnBBbW91bnQsIG9wdGlvbnMudW5zaGFycFJhZGl1cywgb3B0aW9ucy51bnNoYXJwVGhyZXNob2xkKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGhMaWI7XG5cbn0se1wiLi9tbV9yZXNpemVcIjo0LFwiLi9tbV91bnNoYXJwX21hc2tcIjo5LFwiaW5oZXJpdHNcIjoxOSxcIm11bHRpbWF0aFwiOjIwfV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBSZXNpemUgY29udm9sdmVycywgcHVyZSBKUyBpbXBsZW1lbnRhdGlvblxuLy9cbid1c2Ugc3RyaWN0JzsgLy8gUHJlY2lzaW9uIG9mIGZpeGVkIEZQIHZhbHVlc1xuLy92YXIgRklYRURfRlJBQ19CSVRTID0gMTQ7XG5cbmZ1bmN0aW9uIGNsYW1wVG84KGkpIHtcbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAyNTUgPyAyNTUgOiBpO1xufSAvLyBDb252b2x2ZSBpbWFnZSBpbiBob3Jpem9udGFsIGRpcmVjdGlvbnMgYW5kIHRyYW5zcG9zZSBvdXRwdXQuIEluIHRoZW9yeSxcbi8vIHRyYW5zcG9zZSBhbGxvdzpcbi8vXG4vLyAtIHVzZSB0aGUgc2FtZSBjb252b2x2ZXIgZm9yIGJvdGggcGFzc2VzICh0aGlzIGZhaWxzIGR1ZSBkaWZmZXJlbnRcbi8vICAgdHlwZXMgb2YgaW5wdXQgYXJyYXkgYW5kIHRlbXBvcmFyeSBidWZmZXIpXG4vLyAtIG1ha2luZyB2ZXJ0aWNhbCBwYXNzIGJ5IGhvcmlzb25sdGFsIGxpbmVzIGlucHJvdmUgQ1BVIGNhY2hlIHVzZS5cbi8vXG4vLyBCdXQgaW4gcmVhbCBsaWZlIHRoaXMgZG9lc24ndCB3b3JrIDopXG4vL1xuXG5cbmZ1bmN0aW9uIGNvbnZvbHZlSG9yaXpvbnRhbGx5KHNyYywgZGVzdCwgc3JjVywgc3JjSCwgZGVzdFcsIGZpbHRlcnMpIHtcbiAgdmFyIHIsIGcsIGIsIGE7XG4gIHZhciBmaWx0ZXJQdHIsIGZpbHRlclNoaWZ0LCBmaWx0ZXJTaXplO1xuICB2YXIgc3JjUHRyLCBzcmNZLCBkZXN0WCwgZmlsdGVyVmFsO1xuICB2YXIgc3JjT2Zmc2V0ID0gMCxcbiAgICAgIGRlc3RPZmZzZXQgPSAwOyAvLyBGb3IgZWFjaCByb3dcblxuICBmb3IgKHNyY1kgPSAwOyBzcmNZIDwgc3JjSDsgc3JjWSsrKSB7XG4gICAgZmlsdGVyUHRyID0gMDsgLy8gQXBwbHkgcHJlY29tcHV0ZWQgZmlsdGVycyB0byBlYWNoIGRlc3RpbmF0aW9uIHJvdyBwb2ludFxuXG4gICAgZm9yIChkZXN0WCA9IDA7IGRlc3RYIDwgZGVzdFc7IGRlc3RYKyspIHtcbiAgICAgIC8vIEdldCB0aGUgZmlsdGVyIHRoYXQgZGV0ZXJtaW5lcyB0aGUgY3VycmVudCBvdXRwdXQgcGl4ZWwuXG4gICAgICBmaWx0ZXJTaGlmdCA9IGZpbHRlcnNbZmlsdGVyUHRyKytdO1xuICAgICAgZmlsdGVyU2l6ZSA9IGZpbHRlcnNbZmlsdGVyUHRyKytdO1xuICAgICAgc3JjUHRyID0gc3JjT2Zmc2V0ICsgZmlsdGVyU2hpZnQgKiA0IHwgMDtcbiAgICAgIHIgPSBnID0gYiA9IGEgPSAwOyAvLyBBcHBseSB0aGUgZmlsdGVyIHRvIHRoZSByb3cgdG8gZ2V0IHRoZSBkZXN0aW5hdGlvbiBwaXhlbCByLCBnLCBiLCBhXG5cbiAgICAgIGZvciAoOyBmaWx0ZXJTaXplID4gMDsgZmlsdGVyU2l6ZS0tKSB7XG4gICAgICAgIGZpbHRlclZhbCA9IGZpbHRlcnNbZmlsdGVyUHRyKytdOyAvLyBVc2UgcmV2ZXJzZSBvcmRlciB0byB3b3JrYXJvdW5kIGRlb3B0cyBpbiBvbGQgdjggKG5vZGUgdi4xMClcbiAgICAgICAgLy8gQmlnIHRoYW5rcyB0byBAbXJhbGVwaCAoVnlhY2hlc2xhdiBFZ29yb3YpIGZvciB0aGUgdGlwLlxuXG4gICAgICAgIGEgPSBhICsgZmlsdGVyVmFsICogc3JjW3NyY1B0ciArIDNdIHwgMDtcbiAgICAgICAgYiA9IGIgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyICsgMl0gfCAwO1xuICAgICAgICBnID0gZyArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHIgKyAxXSB8IDA7XG4gICAgICAgIHIgPSByICsgZmlsdGVyVmFsICogc3JjW3NyY1B0cl0gfCAwO1xuICAgICAgICBzcmNQdHIgPSBzcmNQdHIgKyA0IHwgMDtcbiAgICAgIH0gLy8gQnJpbmcgdGhpcyB2YWx1ZSBiYWNrIGluIHJhbmdlLiBBbGwgb2YgdGhlIGZpbHRlciBzY2FsaW5nIGZhY3RvcnNcbiAgICAgIC8vIGFyZSBpbiBmaXhlZCBwb2ludCB3aXRoIEZJWEVEX0ZSQUNfQklUUyBiaXRzIG9mIGZyYWN0aW9uYWwgcGFydC5cbiAgICAgIC8vXG4gICAgICAvLyAoISkgQWRkIDEvMiBvZiB2YWx1ZSBiZWZvcmUgY2xhbXBpbmcgdG8gZ2V0IHByb3BlciByb3VuZGluZy4gSW4gb3RoZXJcbiAgICAgIC8vIGNhc2UgYnJpZ2h0bmVzcyBsb3NzIHdpbGwgYmUgbm90aWNlYWJsZSBpZiB5b3UgcmVzaXplIGltYWdlIHdpdGggd2hpdGVcbiAgICAgIC8vIGJvcmRlciBhbmQgcGxhY2UgaXQgb24gd2hpdGUgYmFja2dyb3VuZC5cbiAgICAgIC8vXG5cblxuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgM10gPSBjbGFtcFRvOChhICsgKDEgPDwgMTMpID4+IDE0XG4gICAgICAvKkZJWEVEX0ZSQUNfQklUUyovXG4gICAgICApO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMl0gPSBjbGFtcFRvOChiICsgKDEgPDwgMTMpID4+IDE0XG4gICAgICAvKkZJWEVEX0ZSQUNfQklUUyovXG4gICAgICApO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMV0gPSBjbGFtcFRvOChnICsgKDEgPDwgMTMpID4+IDE0XG4gICAgICAvKkZJWEVEX0ZSQUNfQklUUyovXG4gICAgICApO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0XSA9IGNsYW1wVG84KHIgKyAoMSA8PCAxMykgPj4gMTRcbiAgICAgIC8qRklYRURfRlJBQ19CSVRTKi9cbiAgICAgICk7XG4gICAgICBkZXN0T2Zmc2V0ID0gZGVzdE9mZnNldCArIHNyY0ggKiA0IHwgMDtcbiAgICB9XG5cbiAgICBkZXN0T2Zmc2V0ID0gKHNyY1kgKyAxKSAqIDQgfCAwO1xuICAgIHNyY09mZnNldCA9IChzcmNZICsgMSkgKiBzcmNXICogNCB8IDA7XG4gIH1cbn0gLy8gVGVjaG5pY2FsbHksIGNvbnZvbHZlcnMgYXJlIHRoZSBzYW1lLiBCdXQgaW5wdXQgYXJyYXkgYW5kIHRlbXBvcmFyeVxuLy8gYnVmZmVyIGNhbiBiZSBvZiBkaWZmZXJlbnQgdHlwZSAoZXNwZWNpYWxseSwgaW4gb2xkIGJyb3dzZXJzKS4gU28sXG4vLyBrZWVwIGNvZGUgaW4gc2VwYXJhdGUgZnVuY3Rpb25zIHRvIGF2b2lkIGRlb3B0aW1pemF0aW9ucyAmIHNwZWVkIGxvc3MuXG5cblxuZnVuY3Rpb24gY29udm9sdmVWZXJ0aWNhbGx5KHNyYywgZGVzdCwgc3JjVywgc3JjSCwgZGVzdFcsIGZpbHRlcnMpIHtcbiAgdmFyIHIsIGcsIGIsIGE7XG4gIHZhciBmaWx0ZXJQdHIsIGZpbHRlclNoaWZ0LCBmaWx0ZXJTaXplO1xuICB2YXIgc3JjUHRyLCBzcmNZLCBkZXN0WCwgZmlsdGVyVmFsO1xuICB2YXIgc3JjT2Zmc2V0ID0gMCxcbiAgICAgIGRlc3RPZmZzZXQgPSAwOyAvLyBGb3IgZWFjaCByb3dcblxuICBmb3IgKHNyY1kgPSAwOyBzcmNZIDwgc3JjSDsgc3JjWSsrKSB7XG4gICAgZmlsdGVyUHRyID0gMDsgLy8gQXBwbHkgcHJlY29tcHV0ZWQgZmlsdGVycyB0byBlYWNoIGRlc3RpbmF0aW9uIHJvdyBwb2ludFxuXG4gICAgZm9yIChkZXN0WCA9IDA7IGRlc3RYIDwgZGVzdFc7IGRlc3RYKyspIHtcbiAgICAgIC8vIEdldCB0aGUgZmlsdGVyIHRoYXQgZGV0ZXJtaW5lcyB0aGUgY3VycmVudCBvdXRwdXQgcGl4ZWwuXG4gICAgICBmaWx0ZXJTaGlmdCA9IGZpbHRlcnNbZmlsdGVyUHRyKytdO1xuICAgICAgZmlsdGVyU2l6ZSA9IGZpbHRlcnNbZmlsdGVyUHRyKytdO1xuICAgICAgc3JjUHRyID0gc3JjT2Zmc2V0ICsgZmlsdGVyU2hpZnQgKiA0IHwgMDtcbiAgICAgIHIgPSBnID0gYiA9IGEgPSAwOyAvLyBBcHBseSB0aGUgZmlsdGVyIHRvIHRoZSByb3cgdG8gZ2V0IHRoZSBkZXN0aW5hdGlvbiBwaXhlbCByLCBnLCBiLCBhXG5cbiAgICAgIGZvciAoOyBmaWx0ZXJTaXplID4gMDsgZmlsdGVyU2l6ZS0tKSB7XG4gICAgICAgIGZpbHRlclZhbCA9IGZpbHRlcnNbZmlsdGVyUHRyKytdOyAvLyBVc2UgcmV2ZXJzZSBvcmRlciB0byB3b3JrYXJvdW5kIGRlb3B0cyBpbiBvbGQgdjggKG5vZGUgdi4xMClcbiAgICAgICAgLy8gQmlnIHRoYW5rcyB0byBAbXJhbGVwaCAoVnlhY2hlc2xhdiBFZ29yb3YpIGZvciB0aGUgdGlwLlxuXG4gICAgICAgIGEgPSBhICsgZmlsdGVyVmFsICogc3JjW3NyY1B0ciArIDNdIHwgMDtcbiAgICAgICAgYiA9IGIgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyICsgMl0gfCAwO1xuICAgICAgICBnID0gZyArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHIgKyAxXSB8IDA7XG4gICAgICAgIHIgPSByICsgZmlsdGVyVmFsICogc3JjW3NyY1B0cl0gfCAwO1xuICAgICAgICBzcmNQdHIgPSBzcmNQdHIgKyA0IHwgMDtcbiAgICAgIH0gLy8gQnJpbmcgdGhpcyB2YWx1ZSBiYWNrIGluIHJhbmdlLiBBbGwgb2YgdGhlIGZpbHRlciBzY2FsaW5nIGZhY3RvcnNcbiAgICAgIC8vIGFyZSBpbiBmaXhlZCBwb2ludCB3aXRoIEZJWEVEX0ZSQUNfQklUUyBiaXRzIG9mIGZyYWN0aW9uYWwgcGFydC5cbiAgICAgIC8vXG4gICAgICAvLyAoISkgQWRkIDEvMiBvZiB2YWx1ZSBiZWZvcmUgY2xhbXBpbmcgdG8gZ2V0IHByb3BlciByb3VuZGluZy4gSW4gb3RoZXJcbiAgICAgIC8vIGNhc2UgYnJpZ2h0bmVzcyBsb3NzIHdpbGwgYmUgbm90aWNlYWJsZSBpZiB5b3UgcmVzaXplIGltYWdlIHdpdGggd2hpdGVcbiAgICAgIC8vIGJvcmRlciBhbmQgcGxhY2UgaXQgb24gd2hpdGUgYmFja2dyb3VuZC5cbiAgICAgIC8vXG5cblxuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgM10gPSBjbGFtcFRvOChhICsgKDEgPDwgMTMpID4+IDE0XG4gICAgICAvKkZJWEVEX0ZSQUNfQklUUyovXG4gICAgICApO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMl0gPSBjbGFtcFRvOChiICsgKDEgPDwgMTMpID4+IDE0XG4gICAgICAvKkZJWEVEX0ZSQUNfQklUUyovXG4gICAgICApO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMV0gPSBjbGFtcFRvOChnICsgKDEgPDwgMTMpID4+IDE0XG4gICAgICAvKkZJWEVEX0ZSQUNfQklUUyovXG4gICAgICApO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0XSA9IGNsYW1wVG84KHIgKyAoMSA8PCAxMykgPj4gMTRcbiAgICAgIC8qRklYRURfRlJBQ19CSVRTKi9cbiAgICAgICk7XG4gICAgICBkZXN0T2Zmc2V0ID0gZGVzdE9mZnNldCArIHNyY0ggKiA0IHwgMDtcbiAgICB9XG5cbiAgICBkZXN0T2Zmc2V0ID0gKHNyY1kgKyAxKSAqIDQgfCAwO1xuICAgIHNyY09mZnNldCA9IChzcmNZICsgMSkgKiBzcmNXICogNCB8IDA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnZvbHZlSG9yaXpvbnRhbGx5OiBjb252b2x2ZUhvcml6b250YWxseSxcbiAgY29udm9sdmVWZXJ0aWNhbGx5OiBjb252b2x2ZVZlcnRpY2FsbHlcbn07XG5cbn0se31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gVGhpcyBpcyBhdXRvZ2VuZXJhdGVkIGZpbGUgZnJvbSBtYXRoLndhc20sIGRvbid0IGVkaXQuXG4vL1xuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9ICdBR0Z6YlFFQUFBQUFEQVprZVd4cGJtc0FBQUFBQUFFWEEyQUFBR0FHZjM5L2YzOS9BR0FIZjM5L2YzOS9md0FDRHdFRFpXNTJCbTFsYlc5eWVRSUFBQU1FQXdBQkFnWUdBWDhBUVFBTEIxY0ZFVjlmZDJGemJWOWpZV3hzWDJOMGIzSnpBQUFJWTI5dWRtOXNkbVVBQVFwamIyNTJiMngyWlVoV0FBSU1YMTlrYzI5ZmFHRnVaR3hsQXdBWVgxOTNZWE50WDJGd2NHeDVYMlJoZEdGZmNtVnNiMk56QUFBSzdBTURBd0FCQzhZREFROS9Ba0FnQTBVTkFDQUVSUTBBQTBBZ0RDRU5RUUFoRTBFQUlRY0RRQ0FIUVFKcUlRWUNmeUFIUVFGMElBVnFJZ2N1QVFJaUZFVUVRRUdBd0FBaENFR0F3QUFoQ1VHQXdBQWhDa0dBd0FBaEN5QUdEQUVMSUJJZ0J5NEJBR29oQ0VFQUlRc2dGQ0VIUVFBaERpQUdJUWxCQUNFUFFRQWhFQU5BSUFVZ0NVRUJkR291QVFBaUVTQUFJQWhCQW5ScUtBSUFJZ3BCR0hac0lCQnFJUkFnQ2tIL0FYRWdFV3dnQzJvaEN5QUtRUkIyUWY4QmNTQVJiQ0FQYWlFUElBcEJDSFpCL3dGeElCRnNJQTVxSVE0Z0NFRUJhaUVJSUFsQkFXb2hDU0FIUVFGcklnY05BQXNnQzBHQVFHc2hDQ0FPUVlCQWF5RUpJQTlCZ0VCcklRb2dFRUdBUUdzaEN5QUdJQlJxQ3lFSElBRWdEVUVDZEdvZ0NVRU9kU0lHUWY4QklBWkIvd0ZJR3lJR1FRQWdCa0VBU2h0QkNIUkJnUDREY1NBS1FRNTFJZ1pCL3dFZ0JrSC9BVWdiSWdaQkFDQUdRUUJLRzBFUWRFR0FnUHdIY1NBTFFRNTFJZ1pCL3dFZ0JrSC9BVWdiSWdaQkFDQUdRUUJLRzBFWWRISnlJQWhCRG5VaUJrSC9BU0FHUWY4QlNCc2lCa0VBSUFaQkFFb2JjallDQUNBRElBMXFJUTBnRTBFQmFpSVRJQVJIRFFBTElBeEJBV29pRENBQ2JDRVNJQU1nREVjTkFBc0xDeDRBUVFBZ0FpQURJQVFnQlNBQUVBRWdBa0VBSUFRZ0JTQUdJQUVRQVFzPSc7XG5cbn0se31dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3Jlc2l6ZScsXG4gIGZuOiBfZGVyZXFfKCcuL3Jlc2l6ZScpLFxuICB3YXNtX2ZuOiBfZGVyZXFfKCcuL3Jlc2l6ZV93YXNtJyksXG4gIHdhc21fc3JjOiBfZGVyZXFfKCcuL2NvbnZvbHZlX3dhc21fYmFzZTY0Jylcbn07XG5cbn0se1wiLi9jb252b2x2ZV93YXNtX2Jhc2U2NFwiOjMsXCIuL3Jlc2l6ZVwiOjUsXCIuL3Jlc2l6ZV93YXNtXCI6OH1dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRmlsdGVycyA9IF9kZXJlcV8oJy4vcmVzaXplX2ZpbHRlcl9nZW4nKTtcblxudmFyIGNvbnZvbHZlSG9yaXpvbnRhbGx5ID0gX2RlcmVxXygnLi9jb252b2x2ZScpLmNvbnZvbHZlSG9yaXpvbnRhbGx5O1xuXG52YXIgY29udm9sdmVWZXJ0aWNhbGx5ID0gX2RlcmVxXygnLi9jb252b2x2ZScpLmNvbnZvbHZlVmVydGljYWxseTtcblxuZnVuY3Rpb24gcmVzZXRBbHBoYShkc3QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHB0ciA9IDMsXG4gICAgICBsZW4gPSB3aWR0aCAqIGhlaWdodCAqIDQgfCAwO1xuXG4gIHdoaWxlIChwdHIgPCBsZW4pIHtcbiAgICBkc3RbcHRyXSA9IDB4RkY7XG4gICAgcHRyID0gcHRyICsgNCB8IDA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXNpemUob3B0aW9ucykge1xuICB2YXIgc3JjID0gb3B0aW9ucy5zcmM7XG4gIHZhciBzcmNXID0gb3B0aW9ucy53aWR0aDtcbiAgdmFyIHNyY0ggPSBvcHRpb25zLmhlaWdodDtcbiAgdmFyIGRlc3RXID0gb3B0aW9ucy50b1dpZHRoO1xuICB2YXIgZGVzdEggPSBvcHRpb25zLnRvSGVpZ2h0O1xuICB2YXIgc2NhbGVYID0gb3B0aW9ucy5zY2FsZVggfHwgb3B0aW9ucy50b1dpZHRoIC8gb3B0aW9ucy53aWR0aDtcbiAgdmFyIHNjYWxlWSA9IG9wdGlvbnMuc2NhbGVZIHx8IG9wdGlvbnMudG9IZWlnaHQgLyBvcHRpb25zLmhlaWdodDtcbiAgdmFyIG9mZnNldFggPSBvcHRpb25zLm9mZnNldFggfHwgMDtcbiAgdmFyIG9mZnNldFkgPSBvcHRpb25zLm9mZnNldFkgfHwgMDtcbiAgdmFyIGRlc3QgPSBvcHRpb25zLmRlc3QgfHwgbmV3IFVpbnQ4QXJyYXkoZGVzdFcgKiBkZXN0SCAqIDQpO1xuICB2YXIgcXVhbGl0eSA9IHR5cGVvZiBvcHRpb25zLnF1YWxpdHkgPT09ICd1bmRlZmluZWQnID8gMyA6IG9wdGlvbnMucXVhbGl0eTtcbiAgdmFyIGFscGhhID0gb3B0aW9ucy5hbHBoYSB8fCBmYWxzZTtcbiAgdmFyIGZpbHRlcnNYID0gY3JlYXRlRmlsdGVycyhxdWFsaXR5LCBzcmNXLCBkZXN0Vywgc2NhbGVYLCBvZmZzZXRYKSxcbiAgICAgIGZpbHRlcnNZID0gY3JlYXRlRmlsdGVycyhxdWFsaXR5LCBzcmNILCBkZXN0SCwgc2NhbGVZLCBvZmZzZXRZKTtcbiAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KGRlc3RXICogc3JjSCAqIDQpOyAvLyBUbyB1c2Ugc2luZ2xlIGZ1bmN0aW9uIHdlIG5lZWQgc3JjICYgdG1wIG9mIHRoZSBzYW1lIHR5cGUuXG4gIC8vIEJ1dCBzcmMgY2FuIGJlIENhbnZhc1BpeGVsQXJyYXksIGFuZCB0bXAgLSBVaW50OEFycmF5LiBTbywga2VlcFxuICAvLyB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBwYXNzZXMgc2VwYXJhdGVseSB0byBhdm9pZCBkZW9wdGltaXphdGlvbi5cblxuICBjb252b2x2ZUhvcml6b250YWxseShzcmMsIHRtcCwgc3JjVywgc3JjSCwgZGVzdFcsIGZpbHRlcnNYKTtcbiAgY29udm9sdmVWZXJ0aWNhbGx5KHRtcCwgZGVzdCwgc3JjSCwgZGVzdFcsIGRlc3RILCBmaWx0ZXJzWSk7IC8vIFRoYXQncyBmYXN0ZXIgdGhhbiBkb2luZyBjaGVja3MgaW4gY29udm9sdmVyLlxuICAvLyAhISEgTm90ZSwgY2FudmFzIGRhdGEgaXMgbm90IHByZW11bHRpcGxlZC4gV2UgZG9uJ3QgbmVlZCBvdGhlclxuICAvLyBhbHBoYSBjb3JyZWN0aW9ucy5cblxuICBpZiAoIWFscGhhKSByZXNldEFscGhhKGRlc3QsIGRlc3RXLCBkZXN0SCk7XG4gIHJldHVybiBkZXN0O1xufTtcblxufSx7XCIuL2NvbnZvbHZlXCI6MixcIi4vcmVzaXplX2ZpbHRlcl9nZW5cIjo2fV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDYWxjdWxhdGUgY29udm9sdXRpb24gZmlsdGVycyBmb3IgZWFjaCBkZXN0aW5hdGlvbiBwb2ludCxcbi8vIGFuZCBwYWNrIGRhdGEgdG8gSW50MTZBcnJheTpcbi8vXG4vLyBbIHNoaWZ0LCBsZW5ndGgsIGRhdGEuLi4sIHNoaWZ0MiwgbGVuZ3RoMiwgZGF0YS4uLiwgLi4uIF1cbi8vXG4vLyAtIHNoaWZ0IC0gb2Zmc2V0IGluIHNyYyBpbWFnZVxuLy8gLSBsZW5ndGggLSBmaWx0ZXIgbGVuZ3RoIChpbiBzcmMgcG9pbnRzKVxuLy8gLSBkYXRhIC0gZmlsdGVyIHZhbHVlcyBzZXF1ZW5jZVxuLy9cbid1c2Ugc3RyaWN0JztcblxudmFyIEZJTFRFUl9JTkZPID0gX2RlcmVxXygnLi9yZXNpemVfZmlsdGVyX2luZm8nKTsgLy8gUHJlY2lzaW9uIG9mIGZpeGVkIEZQIHZhbHVlc1xuXG5cbnZhciBGSVhFRF9GUkFDX0JJVFMgPSAxNDtcblxuZnVuY3Rpb24gdG9GaXhlZFBvaW50KG51bSkge1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiAoKDEgPDwgRklYRURfRlJBQ19CSVRTKSAtIDEpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXNpemVGaWx0ZXJHZW4ocXVhbGl0eSwgc3JjU2l6ZSwgZGVzdFNpemUsIHNjYWxlLCBvZmZzZXQpIHtcbiAgdmFyIGZpbHRlckZ1bmN0aW9uID0gRklMVEVSX0lORk9bcXVhbGl0eV0uZmlsdGVyO1xuICB2YXIgc2NhbGVJbnZlcnRlZCA9IDEuMCAvIHNjYWxlO1xuICB2YXIgc2NhbGVDbGFtcGVkID0gTWF0aC5taW4oMS4wLCBzY2FsZSk7IC8vIEZvciB1cHNjYWxlXG4gIC8vIEZpbHRlciB3aW5kb3cgKGF2ZXJhZ2luZyBpbnRlcnZhbCksIHNjYWxlZCB0byBzcmMgaW1hZ2VcblxuICB2YXIgc3JjV2luZG93ID0gRklMVEVSX0lORk9bcXVhbGl0eV0ud2luIC8gc2NhbGVDbGFtcGVkO1xuICB2YXIgZGVzdFBpeGVsLCBzcmNQaXhlbCwgc3JjRmlyc3QsIHNyY0xhc3QsIGZpbHRlckVsZW1lbnRTaXplLCBmbG9hdEZpbHRlciwgZnhwRmlsdGVyLCB0b3RhbCwgcHhsLCBpZHgsIGZsb2F0VmFsLCBmaWx0ZXJUb3RhbCwgZmlsdGVyVmFsO1xuICB2YXIgbGVmdE5vdEVtcHR5LCByaWdodE5vdEVtcHR5LCBmaWx0ZXJTaGlmdCwgZmlsdGVyU2l6ZTtcbiAgdmFyIG1heEZpbHRlckVsZW1lbnRTaXplID0gTWF0aC5mbG9vcigoc3JjV2luZG93ICsgMSkgKiAyKTtcbiAgdmFyIHBhY2tlZEZpbHRlciA9IG5ldyBJbnQxNkFycmF5KChtYXhGaWx0ZXJFbGVtZW50U2l6ZSArIDIpICogZGVzdFNpemUpO1xuICB2YXIgcGFja2VkRmlsdGVyUHRyID0gMDtcbiAgdmFyIHNsb3dDb3B5ID0gIXBhY2tlZEZpbHRlci5zdWJhcnJheSB8fCAhcGFja2VkRmlsdGVyLnNldDsgLy8gRm9yIGVhY2ggZGVzdGluYXRpb24gcGl4ZWwgY2FsY3VsYXRlIHNvdXJjZSByYW5nZSBhbmQgYnVpbHQgZmlsdGVyIHZhbHVlc1xuXG4gIGZvciAoZGVzdFBpeGVsID0gMDsgZGVzdFBpeGVsIDwgZGVzdFNpemU7IGRlc3RQaXhlbCsrKSB7XG4gICAgLy8gU2NhbGluZyBzaG91bGQgYmUgZG9uZSByZWxhdGl2ZSB0byBjZW50cmFsIHBpeGVsIHBvaW50XG4gICAgc3JjUGl4ZWwgPSAoZGVzdFBpeGVsICsgMC41KSAqIHNjYWxlSW52ZXJ0ZWQgKyBvZmZzZXQ7XG4gICAgc3JjRmlyc3QgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHNyY1BpeGVsIC0gc3JjV2luZG93KSk7XG4gICAgc3JjTGFzdCA9IE1hdGgubWluKHNyY1NpemUgLSAxLCBNYXRoLmNlaWwoc3JjUGl4ZWwgKyBzcmNXaW5kb3cpKTtcbiAgICBmaWx0ZXJFbGVtZW50U2l6ZSA9IHNyY0xhc3QgLSBzcmNGaXJzdCArIDE7XG4gICAgZmxvYXRGaWx0ZXIgPSBuZXcgRmxvYXQzMkFycmF5KGZpbHRlckVsZW1lbnRTaXplKTtcbiAgICBmeHBGaWx0ZXIgPSBuZXcgSW50MTZBcnJheShmaWx0ZXJFbGVtZW50U2l6ZSk7XG4gICAgdG90YWwgPSAwLjA7IC8vIEZpbGwgZmlsdGVyIHZhbHVlcyBmb3IgY2FsY3VsYXRlZCByYW5nZVxuXG4gICAgZm9yIChweGwgPSBzcmNGaXJzdCwgaWR4ID0gMDsgcHhsIDw9IHNyY0xhc3Q7IHB4bCsrLCBpZHgrKykge1xuICAgICAgZmxvYXRWYWwgPSBmaWx0ZXJGdW5jdGlvbigocHhsICsgMC41IC0gc3JjUGl4ZWwpICogc2NhbGVDbGFtcGVkKTtcbiAgICAgIHRvdGFsICs9IGZsb2F0VmFsO1xuICAgICAgZmxvYXRGaWx0ZXJbaWR4XSA9IGZsb2F0VmFsO1xuICAgIH0gLy8gTm9ybWFsaXplIGZpbHRlciwgY29udmVydCB0byBmaXhlZCBwb2ludCBhbmQgYWNjdW11bGF0ZSBjb252ZXJzaW9uIGVycm9yXG5cblxuICAgIGZpbHRlclRvdGFsID0gMDtcblxuICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgZmxvYXRGaWx0ZXIubGVuZ3RoOyBpZHgrKykge1xuICAgICAgZmlsdGVyVmFsID0gZmxvYXRGaWx0ZXJbaWR4XSAvIHRvdGFsO1xuICAgICAgZmlsdGVyVG90YWwgKz0gZmlsdGVyVmFsO1xuICAgICAgZnhwRmlsdGVyW2lkeF0gPSB0b0ZpeGVkUG9pbnQoZmlsdGVyVmFsKTtcbiAgICB9IC8vIENvbXBlbnNhdGUgbm9ybWFsaXphdGlvbiBlcnJvciwgdG8gbWluaW1pemUgYnJpZ2h0bmVzcyBkcmlmdFxuXG5cbiAgICBmeHBGaWx0ZXJbZGVzdFNpemUgPj4gMV0gKz0gdG9GaXhlZFBvaW50KDEuMCAtIGZpbHRlclRvdGFsKTsgLy9cbiAgICAvLyBOb3cgcGFjayBmaWx0ZXIgdG8gdXNlYWJsZSBmb3JtXG4gICAgLy9cbiAgICAvLyAxLiBUcmltIGhlYWRpbmcgYW5kIHRhaWxpbmcgemVybyB2YWx1ZXMsIGFuZCBjb21wZW5zYXRlIHNoaXRmL2xlbmd0aFxuICAgIC8vIDIuIFB1dCBhbGwgdG8gc2luZ2xlIGFycmF5IGluIHRoaXMgZm9ybWF0OlxuICAgIC8vXG4gICAgLy8gICAgWyBwb3Mgc2hpZnQsIGRhdGEgbGVuZ3RoLCB2YWx1ZTEsIHZhbHVlMiwgdmFsdWUzLCAuLi4gXVxuICAgIC8vXG5cbiAgICBsZWZ0Tm90RW1wdHkgPSAwO1xuXG4gICAgd2hpbGUgKGxlZnROb3RFbXB0eSA8IGZ4cEZpbHRlci5sZW5ndGggJiYgZnhwRmlsdGVyW2xlZnROb3RFbXB0eV0gPT09IDApIHtcbiAgICAgIGxlZnROb3RFbXB0eSsrO1xuICAgIH1cblxuICAgIGlmIChsZWZ0Tm90RW1wdHkgPCBmeHBGaWx0ZXIubGVuZ3RoKSB7XG4gICAgICByaWdodE5vdEVtcHR5ID0gZnhwRmlsdGVyLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChyaWdodE5vdEVtcHR5ID4gMCAmJiBmeHBGaWx0ZXJbcmlnaHROb3RFbXB0eV0gPT09IDApIHtcbiAgICAgICAgcmlnaHROb3RFbXB0eS0tO1xuICAgICAgfVxuXG4gICAgICBmaWx0ZXJTaGlmdCA9IHNyY0ZpcnN0ICsgbGVmdE5vdEVtcHR5O1xuICAgICAgZmlsdGVyU2l6ZSA9IHJpZ2h0Tm90RW1wdHkgLSBsZWZ0Tm90RW1wdHkgKyAxO1xuICAgICAgcGFja2VkRmlsdGVyW3BhY2tlZEZpbHRlclB0cisrXSA9IGZpbHRlclNoaWZ0OyAvLyBzaGlmdFxuXG4gICAgICBwYWNrZWRGaWx0ZXJbcGFja2VkRmlsdGVyUHRyKytdID0gZmlsdGVyU2l6ZTsgLy8gc2l6ZVxuXG4gICAgICBpZiAoIXNsb3dDb3B5KSB7XG4gICAgICAgIHBhY2tlZEZpbHRlci5zZXQoZnhwRmlsdGVyLnN1YmFycmF5KGxlZnROb3RFbXB0eSwgcmlnaHROb3RFbXB0eSArIDEpLCBwYWNrZWRGaWx0ZXJQdHIpO1xuICAgICAgICBwYWNrZWRGaWx0ZXJQdHIgKz0gZmlsdGVyU2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIGZvciBvbGQgSUUgPCAxMSwgd2l0aG91dCBzdWJhcnJheS9zZXQgbWV0aG9kc1xuICAgICAgICBmb3IgKGlkeCA9IGxlZnROb3RFbXB0eTsgaWR4IDw9IHJpZ2h0Tm90RW1wdHk7IGlkeCsrKSB7XG4gICAgICAgICAgcGFja2VkRmlsdGVyW3BhY2tlZEZpbHRlclB0cisrXSA9IGZ4cEZpbHRlcltpZHhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHplcm8gZGF0YSwgd3JpdGUgaGVhZGVyIG9ubHlcbiAgICAgIHBhY2tlZEZpbHRlcltwYWNrZWRGaWx0ZXJQdHIrK10gPSAwOyAvLyBzaGlmdFxuXG4gICAgICBwYWNrZWRGaWx0ZXJbcGFja2VkRmlsdGVyUHRyKytdID0gMDsgLy8gc2l6ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWNrZWRGaWx0ZXI7XG59O1xuXG59LHtcIi4vcmVzaXplX2ZpbHRlcl9pbmZvXCI6N31dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gRmlsdGVyIGRlZmluaXRpb25zIHRvIGJ1aWxkIHRhYmxlcyBmb3Jcbi8vIHJlc2l6aW5nIGNvbnZvbHZlcnMuXG4vL1xuLy8gUHJlc2V0cyBmb3IgcXVhbGl0eSAwLi4zLiBGaWx0ZXIgZnVuY3Rpb25zICsgd2luZG93IHNpemVcbi8vXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW3tcbiAgLy8gTmVhcmVzdCBuZWlib3IgKEJveClcbiAgd2luOiAwLjUsXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKHgpIHtcbiAgICByZXR1cm4geCA+PSAtMC41ICYmIHggPCAwLjUgPyAxLjAgOiAwLjA7XG4gIH1cbn0sIHtcbiAgLy8gSGFtbWluZ1xuICB3aW46IDEuMCxcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoeCkge1xuICAgIGlmICh4IDw9IC0xLjAgfHwgeCA+PSAxLjApIHtcbiAgICAgIHJldHVybiAwLjA7XG4gICAgfVxuXG4gICAgaWYgKHggPiAtMS4xOTIwOTI5MEUtMDcgJiYgeCA8IDEuMTkyMDkyOTBFLTA3KSB7XG4gICAgICByZXR1cm4gMS4wO1xuICAgIH1cblxuICAgIHZhciB4cGkgPSB4ICogTWF0aC5QSTtcbiAgICByZXR1cm4gTWF0aC5zaW4oeHBpKSAvIHhwaSAqICgwLjU0ICsgMC40NiAqIE1hdGguY29zKHhwaSAvIDEuMCkpO1xuICB9XG59LCB7XG4gIC8vIExhbmN6b3MsIHdpbiA9IDJcbiAgd2luOiAyLjAsXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKHgpIHtcbiAgICBpZiAoeCA8PSAtMi4wIHx8IHggPj0gMi4wKSB7XG4gICAgICByZXR1cm4gMC4wO1xuICAgIH1cblxuICAgIGlmICh4ID4gLTEuMTkyMDkyOTBFLTA3ICYmIHggPCAxLjE5MjA5MjkwRS0wNykge1xuICAgICAgcmV0dXJuIDEuMDtcbiAgICB9XG5cbiAgICB2YXIgeHBpID0geCAqIE1hdGguUEk7XG4gICAgcmV0dXJuIE1hdGguc2luKHhwaSkgLyB4cGkgKiBNYXRoLnNpbih4cGkgLyAyLjApIC8gKHhwaSAvIDIuMCk7XG4gIH1cbn0sIHtcbiAgLy8gTGFuY3pvcywgd2luID0gM1xuICB3aW46IDMuMCxcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoeCkge1xuICAgIGlmICh4IDw9IC0zLjAgfHwgeCA+PSAzLjApIHtcbiAgICAgIHJldHVybiAwLjA7XG4gICAgfVxuXG4gICAgaWYgKHggPiAtMS4xOTIwOTI5MEUtMDcgJiYgeCA8IDEuMTkyMDkyOTBFLTA3KSB7XG4gICAgICByZXR1cm4gMS4wO1xuICAgIH1cblxuICAgIHZhciB4cGkgPSB4ICogTWF0aC5QSTtcbiAgICByZXR1cm4gTWF0aC5zaW4oeHBpKSAvIHhwaSAqIE1hdGguc2luKHhwaSAvIDMuMCkgLyAoeHBpIC8gMy4wKTtcbiAgfVxufV07XG5cbn0se31dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRmlsdGVycyA9IF9kZXJlcV8oJy4vcmVzaXplX2ZpbHRlcl9nZW4nKTtcblxuZnVuY3Rpb24gcmVzZXRBbHBoYShkc3QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHB0ciA9IDMsXG4gICAgICBsZW4gPSB3aWR0aCAqIGhlaWdodCAqIDQgfCAwO1xuXG4gIHdoaWxlIChwdHIgPCBsZW4pIHtcbiAgICBkc3RbcHRyXSA9IDB4RkY7XG4gICAgcHRyID0gcHRyICsgNCB8IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNVaW50OEFycmF5KHNyYykge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc3JjLmJ1ZmZlciwgMCwgc3JjLmJ5dGVMZW5ndGgpO1xufVxuXG52YXIgSVNfTEUgPSB0cnVlOyAvLyBzaG91bGQgbm90IGNyYXNoIGV2ZXJ5dGhpbmcgb24gbW9kdWxlIGxvYWQgaW4gb2xkIGJyb3dzZXJzXG5cbnRyeSB7XG4gIElTX0xFID0gbmV3IFVpbnQzMkFycmF5KG5ldyBVaW50OEFycmF5KFsxLCAwLCAwLCAwXSkuYnVmZmVyKVswXSA9PT0gMTtcbn0gY2F0Y2ggKF9fKSB7fVxuXG5mdW5jdGlvbiBjb3B5SW50MTZhc0xFKHNyYywgdGFyZ2V0LCB0YXJnZXRfb2Zmc2V0KSB7XG4gIGlmIChJU19MRSkge1xuICAgIHRhcmdldC5zZXQoYXNVaW50OEFycmF5KHNyYyksIHRhcmdldF9vZmZzZXQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIHB0ciA9IHRhcmdldF9vZmZzZXQsIGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRhdGEgPSBzcmNbaV07XG4gICAgdGFyZ2V0W3B0cisrXSA9IGRhdGEgJiAweEZGO1xuICAgIHRhcmdldFtwdHIrK10gPSBkYXRhID4+IDggJiAweEZGO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVzaXplX3dhc20ob3B0aW9ucykge1xuICB2YXIgc3JjID0gb3B0aW9ucy5zcmM7XG4gIHZhciBzcmNXID0gb3B0aW9ucy53aWR0aDtcbiAgdmFyIHNyY0ggPSBvcHRpb25zLmhlaWdodDtcbiAgdmFyIGRlc3RXID0gb3B0aW9ucy50b1dpZHRoO1xuICB2YXIgZGVzdEggPSBvcHRpb25zLnRvSGVpZ2h0O1xuICB2YXIgc2NhbGVYID0gb3B0aW9ucy5zY2FsZVggfHwgb3B0aW9ucy50b1dpZHRoIC8gb3B0aW9ucy53aWR0aDtcbiAgdmFyIHNjYWxlWSA9IG9wdGlvbnMuc2NhbGVZIHx8IG9wdGlvbnMudG9IZWlnaHQgLyBvcHRpb25zLmhlaWdodDtcbiAgdmFyIG9mZnNldFggPSBvcHRpb25zLm9mZnNldFggfHwgMC4wO1xuICB2YXIgb2Zmc2V0WSA9IG9wdGlvbnMub2Zmc2V0WSB8fCAwLjA7XG4gIHZhciBkZXN0ID0gb3B0aW9ucy5kZXN0IHx8IG5ldyBVaW50OEFycmF5KGRlc3RXICogZGVzdEggKiA0KTtcbiAgdmFyIHF1YWxpdHkgPSB0eXBlb2Ygb3B0aW9ucy5xdWFsaXR5ID09PSAndW5kZWZpbmVkJyA/IDMgOiBvcHRpb25zLnF1YWxpdHk7XG4gIHZhciBhbHBoYSA9IG9wdGlvbnMuYWxwaGEgfHwgZmFsc2U7XG4gIHZhciBmaWx0ZXJzWCA9IGNyZWF0ZUZpbHRlcnMocXVhbGl0eSwgc3JjVywgZGVzdFcsIHNjYWxlWCwgb2Zmc2V0WCksXG4gICAgICBmaWx0ZXJzWSA9IGNyZWF0ZUZpbHRlcnMocXVhbGl0eSwgc3JjSCwgZGVzdEgsIHNjYWxlWSwgb2Zmc2V0WSk7IC8vIGRlc3RpbmF0aW9uIGlzIDAgdG9vLlxuXG4gIHZhciBzcmNfb2Zmc2V0ID0gMDsgLy8gYnVmZmVyIGJldHdlZW4gY29udm9sdmUgcGFzc2VzXG5cbiAgdmFyIHRtcF9vZmZzZXQgPSB0aGlzLl9fYWxpZ24oc3JjX29mZnNldCArIE1hdGgubWF4KHNyYy5ieXRlTGVuZ3RoLCBkZXN0LmJ5dGVMZW5ndGgpKTtcblxuICB2YXIgZmlsdGVyc1hfb2Zmc2V0ID0gdGhpcy5fX2FsaWduKHRtcF9vZmZzZXQgKyBzcmNIICogZGVzdFcgKiA0KTtcblxuICB2YXIgZmlsdGVyc1lfb2Zmc2V0ID0gdGhpcy5fX2FsaWduKGZpbHRlcnNYX29mZnNldCArIGZpbHRlcnNYLmJ5dGVMZW5ndGgpO1xuXG4gIHZhciBhbGxvY19ieXRlcyA9IGZpbHRlcnNZX29mZnNldCArIGZpbHRlcnNZLmJ5dGVMZW5ndGg7XG5cbiAgdmFyIGluc3RhbmNlID0gdGhpcy5fX2luc3RhbmNlKCdyZXNpemUnLCBhbGxvY19ieXRlcyk7IC8vXG4gIC8vIEZpbGwgbWVtb3J5IGJsb2NrIHdpdGggZGF0YSB0byBwcm9jZXNzXG4gIC8vXG5cblxuICB2YXIgbWVtID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fX21lbW9yeS5idWZmZXIpO1xuICB2YXIgbWVtMzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fX21lbW9yeS5idWZmZXIpOyAvLyAzMi1iaXQgY29weSBpcyBtdWNoIGZhc3RlciBpbiBjaHJvbWVcblxuICB2YXIgc3JjMzIgPSBuZXcgVWludDMyQXJyYXkoc3JjLmJ1ZmZlcik7XG4gIG1lbTMyLnNldChzcmMzMik7IC8vIFdlIHNob3VsZCBndWFyYW50ZWUgTEUgYnl0ZXMgb3JkZXIuIEZpbHRlcnMgYXJlIG5vdCBiaWcsIHNvXG4gIC8vIHNwZWVkIGRpZmZlcmVuY2UgaXMgbm90IHNpZ25pZmljYW50IHZzIGRpcmVjdCAuc2V0KClcblxuICBjb3B5SW50MTZhc0xFKGZpbHRlcnNYLCBtZW0sIGZpbHRlcnNYX29mZnNldCk7XG4gIGNvcHlJbnQxNmFzTEUoZmlsdGVyc1ksIG1lbSwgZmlsdGVyc1lfb2Zmc2V0KTsgLy9cbiAgLy8gTm93IGNhbGwgd2ViYXNzZW1ibHkgbWV0aG9kXG4gIC8vIGVtc2RrIGRvZXMgbWV0aG9kIG5hbWVzIHdpdGggJ18nXG5cbiAgdmFyIGZuID0gaW5zdGFuY2UuZXhwb3J0cy5jb252b2x2ZUhWIHx8IGluc3RhbmNlLmV4cG9ydHMuX2NvbnZvbHZlSFY7XG4gIGZuKGZpbHRlcnNYX29mZnNldCwgZmlsdGVyc1lfb2Zmc2V0LCB0bXBfb2Zmc2V0LCBzcmNXLCBzcmNILCBkZXN0VywgZGVzdEgpOyAvL1xuICAvLyBDb3B5IGRhdGEgYmFjayB0byB0eXBlZCBhcnJheVxuICAvL1xuICAvLyAzMi1iaXQgY29weSBpcyBtdWNoIGZhc3RlciBpbiBjaHJvbWVcblxuICB2YXIgZGVzdDMyID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyKTtcbiAgZGVzdDMyLnNldChuZXcgVWludDMyQXJyYXkodGhpcy5fX21lbW9yeS5idWZmZXIsIDAsIGRlc3RIICogZGVzdFcpKTsgLy8gVGhhdCdzIGZhc3RlciB0aGFuIGRvaW5nIGNoZWNrcyBpbiBjb252b2x2ZXIuXG4gIC8vICEhISBOb3RlLCBjYW52YXMgZGF0YSBpcyBub3QgcHJlbXVsdGlwbGVkLiBXZSBkb24ndCBuZWVkIG90aGVyXG4gIC8vIGFscGhhIGNvcnJlY3Rpb25zLlxuXG4gIGlmICghYWxwaGEpIHJlc2V0QWxwaGEoZGVzdCwgZGVzdFcsIGRlc3RIKTtcbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG59LHtcIi4vcmVzaXplX2ZpbHRlcl9nZW5cIjo2fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAndW5zaGFycF9tYXNrJyxcbiAgZm46IF9kZXJlcV8oJy4vdW5zaGFycF9tYXNrJyksXG4gIHdhc21fZm46IF9kZXJlcV8oJy4vdW5zaGFycF9tYXNrX3dhc20nKSxcbiAgd2FzbV9zcmM6IF9kZXJlcV8oJy4vdW5zaGFycF9tYXNrX3dhc21fYmFzZTY0Jylcbn07XG5cbn0se1wiLi91bnNoYXJwX21hc2tcIjoxMCxcIi4vdW5zaGFycF9tYXNrX3dhc21cIjoxMSxcIi4vdW5zaGFycF9tYXNrX3dhc21fYmFzZTY0XCI6MTJ9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBVbnNoYXJwIG1hc2sgZmlsdGVyXG4vL1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjMzMjI4MjAvMTAzMTgwNFxuLy8gVVNNKE8pID0gTyArICgyICogKEFtb3VudCAvIDEwMCkgKiAoTyAtIEdCKSlcbi8vIEdCIC0gZ2F1c3NpYW4gYmx1ci5cbi8vXG4vLyBJbWFnZSBpcyBjb252ZXJ0ZWQgZnJvbSBSR0IgdG8gSFNWLCB1bnNoYXJwIG1hc2sgaXMgYXBwbGllZCB0byB0aGVcbi8vIGJyaWdodG5lc3MgY2hhbm5lbCBhbmQgdGhlbiBpbWFnZSBpcyBjb252ZXJ0ZWQgYmFjayB0byBSR0IuXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2x1cl9tb25vMTYgPSBfZGVyZXFfKCdnbHVyL21vbm8xNicpO1xuXG5mdW5jdGlvbiBoc3ZfdjE2KGltZywgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgc2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xuICB2YXIgb3V0ID0gbmV3IFVpbnQxNkFycmF5KHNpemUpO1xuICB2YXIgciwgZywgYiwgbWF4O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgciA9IGltZ1s0ICogaV07XG4gICAgZyA9IGltZ1s0ICogaSArIDFdO1xuICAgIGIgPSBpbWdbNCAqIGkgKyAyXTtcbiAgICBtYXggPSByID49IGcgJiYgciA+PSBiID8gciA6IGcgPj0gYiAmJiBnID49IHIgPyBnIDogYjtcbiAgICBvdXRbaV0gPSBtYXggPDwgODtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdW5zaGFycChpbWcsIHdpZHRoLCBoZWlnaHQsIGFtb3VudCwgcmFkaXVzLCB0aHJlc2hvbGQpIHtcbiAgdmFyIHYxLCB2Miwgdm11bDtcbiAgdmFyIGRpZmYsIGlUaW1lczQ7XG5cbiAgaWYgKGFtb3VudCA9PT0gMCB8fCByYWRpdXMgPCAwLjUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocmFkaXVzID4gMi4wKSB7XG4gICAgcmFkaXVzID0gMi4wO1xuICB9XG5cbiAgdmFyIGJyaWdodG5lc3MgPSBoc3ZfdjE2KGltZywgd2lkdGgsIGhlaWdodCk7XG4gIHZhciBibHVyZWQgPSBuZXcgVWludDE2QXJyYXkoYnJpZ2h0bmVzcyk7IC8vIGNvcHksIGJlY2F1c2UgYmx1ciBtb2RpZnkgc3JjXG5cbiAgZ2x1cl9tb25vMTYoYmx1cmVkLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xuICB2YXIgYW1vdW50RnAgPSBhbW91bnQgLyAxMDAgKiAweDEwMDAgKyAwLjUgfCAwO1xuICB2YXIgdGhyZXNob2xkRnAgPSB0aHJlc2hvbGQgPDwgODtcbiAgdmFyIHNpemUgPSB3aWR0aCAqIGhlaWdodDtcbiAgLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICB2MSA9IGJyaWdodG5lc3NbaV07XG4gICAgZGlmZiA9IHYxIC0gYmx1cmVkW2ldO1xuXG4gICAgaWYgKE1hdGguYWJzKGRpZmYpID49IHRocmVzaG9sZEZwKSB7XG4gICAgICAvLyBhZGQgdW5zaGFycCBtYXNrIHRvIHRoZSBicmlnaHRuZXNzIGNoYW5uZWxcbiAgICAgIHYyID0gdjEgKyAoYW1vdW50RnAgKiBkaWZmICsgMHg4MDAgPj4gMTIpOyAvLyBCb3RoIHYxIGFuZCB2MiBhcmUgd2l0aGluIFswLjAgLi4gMjU1LjBdICgwMDAwLUZGMDApIHJhbmdlLCBuZXZlciBnb2luZyBpbnRvXG4gICAgICAvLyBbMjU1LjAwMyAuLiAyNTUuOTk2XSAoRkYwMS1GRkZGKS4gVGhpcyBhbGxvd3MgdG8gcm91bmQgdGhpcyB2YWx1ZSBhcyAoeCsuNSl8MFxuICAgICAgLy8gbGF0ZXIgd2l0aG91dCBvdmVyZmxvd2luZy5cblxuICAgICAgdjIgPSB2MiA+IDB4ZmYwMCA/IDB4ZmYwMCA6IHYyO1xuICAgICAgdjIgPSB2MiA8IDB4MDAwMCA/IDB4MDAwMCA6IHYyOyAvLyBBdm9pZCBkaXZpc2lvbiBieSAwLiBWPTAgbWVhbnMgcmdiKDAsMCwwKSwgdW5zaGFycCB3aXRoIHVuc2hhcnBBbW91bnQ+MCBjYW5ub3RcbiAgICAgIC8vIGNoYW5nZSB0aGlzIHZhbHVlIChiZWNhdXNlIGRpZmYgYmV0d2VlbiBjb2xvcnMgZ2V0cyBpbmZsYXRlZCksIHNvIG5vIG5lZWQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzLlxuXG4gICAgICB2MSA9IHYxICE9PSAwID8gdjEgOiAxOyAvLyBNdWx0aXBseWluZyBWIGluIEhTViBtb2RlbCBieSBhIGNvbnN0YW50IGlzIGVxdWl2YWxlbnQgdG8gbXVsdGlwbHlpbmcgZWFjaCBjb21wb25lbnRcbiAgICAgIC8vIGluIFJHQiBieSB0aGUgc2FtZSBjb25zdGFudCAoc2FtZSBmb3IgSFNMKSwgc2VlIGFsc286XG4gICAgICAvLyBodHRwczovL2JlZXNidXp6LmJpei9jb2RlLzE2LWhzdi1jb2xvci10cmFuc2Zvcm1zXG5cbiAgICAgIHZtdWwgPSAodjIgPDwgMTIpIC8gdjEgfCAwOyAvLyBSZXN1bHQgd2lsbCBiZSBpbiBbMC4uMjU1XSByYW5nZSBiZWNhdXNlOlxuICAgICAgLy8gIC0gYWxsIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gICAgICAvLyAgLSByLGcsYiA8PSAodjEvMjU2KVxuICAgICAgLy8gIC0gcixnLGIsKHYxLzI1NiksKHYyLzI1NikgPD0gMjU1XG4gICAgICAvLyBTbyBoaWdoZXN0IHRoaXMgbnVtYmVyIGNhbiBnZXQgaXMgWCoyNTUvWCswLjU9MjU1LjUgd2hpY2ggaXMgPCAyNTYgYW5kIHJvdW5kcyBkb3duLlxuXG4gICAgICBpVGltZXM0ID0gaSAqIDQ7XG4gICAgICBpbWdbaVRpbWVzNF0gPSBpbWdbaVRpbWVzNF0gKiB2bXVsICsgMHg4MDAgPj4gMTI7IC8vIFJcblxuICAgICAgaW1nW2lUaW1lczQgKyAxXSA9IGltZ1tpVGltZXM0ICsgMV0gKiB2bXVsICsgMHg4MDAgPj4gMTI7IC8vIEdcblxuICAgICAgaW1nW2lUaW1lczQgKyAyXSA9IGltZ1tpVGltZXM0ICsgMl0gKiB2bXVsICsgMHg4MDAgPj4gMTI7IC8vIEJcbiAgICB9XG4gIH1cbn07XG5cbn0se1wiZ2x1ci9tb25vMTZcIjoxOH1dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1bnNoYXJwKGltZywgd2lkdGgsIGhlaWdodCwgYW1vdW50LCByYWRpdXMsIHRocmVzaG9sZCkge1xuICBpZiAoYW1vdW50ID09PSAwIHx8IHJhZGl1cyA8IDAuNSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyYWRpdXMgPiAyLjApIHtcbiAgICByYWRpdXMgPSAyLjA7XG4gIH1cblxuICB2YXIgcGl4ZWxzID0gd2lkdGggKiBoZWlnaHQ7XG4gIHZhciBpbWdfYnl0ZXNfY250ID0gcGl4ZWxzICogNDtcbiAgdmFyIGhzdl9ieXRlc19jbnQgPSBwaXhlbHMgKiAyO1xuICB2YXIgYmx1cl9ieXRlc19jbnQgPSBwaXhlbHMgKiAyO1xuICB2YXIgYmx1cl9saW5lX2J5dGVfY250ID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCkgKiA0OyAvLyBmbG9hdDMyIGFycmF5XG5cbiAgdmFyIGJsdXJfY29lZmZzX2J5dGVfY250ID0gOCAqIDQ7IC8vIGZsb2F0MzIgYXJyYXlcblxuICB2YXIgaW1nX29mZnNldCA9IDA7XG4gIHZhciBoc3Zfb2Zmc2V0ID0gaW1nX2J5dGVzX2NudDtcbiAgdmFyIGJsdXJfb2Zmc2V0ID0gaHN2X29mZnNldCArIGhzdl9ieXRlc19jbnQ7XG4gIHZhciBibHVyX3RtcF9vZmZzZXQgPSBibHVyX29mZnNldCArIGJsdXJfYnl0ZXNfY250O1xuICB2YXIgYmx1cl9saW5lX29mZnNldCA9IGJsdXJfdG1wX29mZnNldCArIGJsdXJfYnl0ZXNfY250O1xuICB2YXIgYmx1cl9jb2VmZnNfb2Zmc2V0ID0gYmx1cl9saW5lX29mZnNldCArIGJsdXJfbGluZV9ieXRlX2NudDtcblxuICB2YXIgaW5zdGFuY2UgPSB0aGlzLl9faW5zdGFuY2UoJ3Vuc2hhcnBfbWFzaycsIGltZ19ieXRlc19jbnQgKyBoc3ZfYnl0ZXNfY250ICsgYmx1cl9ieXRlc19jbnQgKiAyICsgYmx1cl9saW5lX2J5dGVfY250ICsgYmx1cl9jb2VmZnNfYnl0ZV9jbnQsIHtcbiAgICBleHA6IE1hdGguZXhwXG4gIH0pOyAvLyAzMi1iaXQgY29weSBpcyBtdWNoIGZhc3RlciBpbiBjaHJvbWVcblxuXG4gIHZhciBpbWczMiA9IG5ldyBVaW50MzJBcnJheShpbWcuYnVmZmVyKTtcbiAgdmFyIG1lbTMyID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuX19tZW1vcnkuYnVmZmVyKTtcbiAgbWVtMzIuc2V0KGltZzMyKTsgLy8gSFNMXG5cbiAgdmFyIGZuID0gaW5zdGFuY2UuZXhwb3J0cy5oc3ZfdjE2IHx8IGluc3RhbmNlLmV4cG9ydHMuX2hzdl92MTY7XG4gIGZuKGltZ19vZmZzZXQsIGhzdl9vZmZzZXQsIHdpZHRoLCBoZWlnaHQpOyAvLyBCTFVSXG5cbiAgZm4gPSBpbnN0YW5jZS5leHBvcnRzLmJsdXJNb25vMTYgfHwgaW5zdGFuY2UuZXhwb3J0cy5fYmx1ck1vbm8xNjtcbiAgZm4oaHN2X29mZnNldCwgYmx1cl9vZmZzZXQsIGJsdXJfdG1wX29mZnNldCwgYmx1cl9saW5lX29mZnNldCwgYmx1cl9jb2VmZnNfb2Zmc2V0LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpOyAvLyBVTlNIQVJQXG5cbiAgZm4gPSBpbnN0YW5jZS5leHBvcnRzLnVuc2hhcnAgfHwgaW5zdGFuY2UuZXhwb3J0cy5fdW5zaGFycDtcbiAgZm4oaW1nX29mZnNldCwgaW1nX29mZnNldCwgaHN2X29mZnNldCwgYmx1cl9vZmZzZXQsIHdpZHRoLCBoZWlnaHQsIGFtb3VudCwgdGhyZXNob2xkKTsgLy8gMzItYml0IGNvcHkgaXMgbXVjaCBmYXN0ZXIgaW4gY2hyb21lXG5cbiAgaW1nMzIuc2V0KG5ldyBVaW50MzJBcnJheSh0aGlzLl9fbWVtb3J5LmJ1ZmZlciwgMCwgcGl4ZWxzKSk7XG59O1xuXG59LHt9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGlzIGlzIGF1dG9nZW5lcmF0ZWQgZmlsZSBmcm9tIG1hdGgud2FzbSwgZG9uJ3QgZWRpdC5cbi8vXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbm1vZHVsZS5leHBvcnRzID0gJ0FHRnpiUUVBQUFBQURBWmtlV3hwYm1zQUFBQUFBQUUwQjJBQUFHQUVmMzkvZndCZ0JuOS9mMzkvZndCZ0NIOS9mMzkvZjM5L0FHQUlmMzkvZjM5L2YzMEFZQUo5ZndCZ0FYd0JmQUlaQWdObGJuWURaWGh3QUFZRFpXNTJCbTFsYlc5eWVRSUFBQU1IQmdBRkFnUUJBd1lHQVg4QVFRQUxCNG9CQ0JGZlgzZGhjMjFmWTJGc2JGOWpkRzl5Y3dBQkZsOWZZblZwYkdSZloyRjFjM05wWVc1ZlkyOWxabk1BQWc1ZlgyZGhkWE56TVRaZmJHbHVaUUFEQ21Kc2RYSk5iMjV2TVRZQUJBZG9jM1pmZGpFMkFBVUhkVzV6YUdGeWNBQUdERjlmWkhOdlgyaGhibVJzWlFNQUdGOWZkMkZ6YlY5aGNIQnNlVjlrWVhSaFgzSmxiRzlqY3dBQkNzVU1CZ01BQVF2V0FRRUhmQ0FCUk51R3VrT0NHdnMvSUFDN295SUNSQUFBQUFBQUFBREFvaEFBSWdXMmpEZ0NGQ0FCSUFLYUVBQWlBeUFEb0NJR3RqZ0NFQ0FCUkFBQUFBQUFBUEEvSUFPaElnUWdCS0lnQXlBQ0lBS2dva1FBQUFBQUFBRHdQNkFnQmFHaklnUzJPQUlBSUFFZ0JTQUVtcUlpQjdZNEFnd2dBU0FESUFKRUFBQUFBQUFBOEQrZ0lBU2lvaUlJdGpnQ0NDQUJJQU1nQWtRQUFBQUFBQUR3djZBZ0JLS2lJZ0syT0FJRUlBRWdCeUFJb0NBRlJBQUFBQUFBQVBBL0lBYWhvQ0lEbzdZNEFod2dBU0FFSUFLZ0lBT2p0amdDR0F1R0JRTUdmd2w4QW4wZ0F5b0NEQ0VWSUFNcUFnZ2hGaUFES2dJVXV5RVJJQU1xQWhDN0lSQUNRQ0FFUVFGcklnaEJBRWdpQ1FSQUlBSWhCeUFBSVFZTUFRc2dBaUFBTHdFQXVDSVBJQU1xQWhpN29pSU1JQkdpSWcwZ0RDQVFvaUFQSUFNcUFnUzdJaE9pSWhRZ0F5b0NBTHNpRWlBUG9xQ2dvQ0lPdGpnQ0FDQUNRUVJxSVFjZ0FFRUNhaUVHSUFoRkRRQWdDRUVCSUFoQkFVZ2JJZ3BCZjNNaEN3Si9JQVFnQ210QkFYRkZCRUFnRGlFTklBZ01BUXNnQWlBTklBNGdFS0lnRkNBU0lBQXZBUUs0SWcraW9LQ2dJZzIyT0FJRUlBSkJDR29oQnlBQVFRUnFJUVlnRGlFTUlBUkJBbXNMSVFJZ0MwRUFJQVJyUmcwQUEwQWdCeUFNSUJHaUlBMGdFS0lnRHlBVG9pQVNJQVl2QVFDNElnNmlvS0NnSWd5Mk9BSUFJQWNnRFNBUm9pQU1JQkNpSUE0Z0U2SWdFaUFHTHdFQ3VDSVBvcUNnb0NJTnRqZ0NCQ0FIUVFocUlRY2dCa0VFYWlFR0lBSkJBa29oQUNBQ1FRSnJJUUlnQUEwQUN3c0NRQ0FKRFFBZ0FTQUZJQWhzUVFGMGFpSUFBbjhnQmtFQ2F5OEJBQ0lDdUNJTklCVzdJaEtpSUEwZ0Zyc2lFNktnSUEwZ0F5b0NITHVpSWd3Z0VLS2dJQXdnRWFLZ0lnOGdCMEVFYXlJSEtnSUF1NkFpRGtRQUFBQUFBQUR3UVdNZ0RrUUFBQUFBQUFBQUFHWnhCRUFnRHFzTUFRdEJBQXM3QVFBZ0NFVU5BQ0FHUVFScklRWkJBQ0FGYTBFQmRDRUJBMEFDZnlBTklCS2lJQUpCLy84RGNiZ2lEU0FUb3FBZ0R5SU9JQkNpb0NBTUlCR2lvQ0lQSUFkQkJHc2lCeW9DQUx1Z0lneEVBQUFBQUFBQThFRmpJQXhFQUFBQUFBQUFBQUJtY1FSQUlBeXJEQUVMUVFBTElRTWdCaThCQUNFQ0lBQWdBV29pQUNBRE93RUFJQVpCQW1zaEJpQUlRUUZLSVFNZ0RpRU1JQWhCQVdzaENDQUREUUFMQ3d2UkFnSUJmd2Q4QWtBZ0IwTUFBQUFBV3cwQUlBUkUyNGE2UTRJYSt6OGdCME1BQUFBL2w3dWpJZ2xFQUFBQUFBQUFBTUNpRUFBaURMYU1PQUlVSUFRZ0Nab1FBQ0lLSUFxZ0lnMjJPQUlRSUFSRUFBQUFBQUFBOEQ4Z0NxRWlDeUFMb2lBS0lBa2dDYUNpUkFBQUFBQUFBUEEvb0NBTW9hTWlDN1k0QWdBZ0JDQU1JQXVhb2lJT3RqZ0NEQ0FFSUFvZ0NVUUFBQUFBQUFEd1A2QWdDNktpSWcrMk9BSUlJQVFnQ2lBSlJBQUFBQUFBQVBDL29DQUxvcUlpQ2JZNEFnUWdCQ0FPSUErZ0lBeEVBQUFBQUFBQThEOGdEYUdnSWdxanRqZ0NIQ0FFSUFzZ0NhQWdDcU8yT0FJWUlBWUVRQU5BSUFBZ0JTQUliRUVCZEdvZ0FpQUlRUUYwYWlBRElBUWdCU0FHRUFNZ0NFRUJhaUlJSUFaSERRQUxDeUFGUlEwQVFRQWhDQU5BSUFJZ0JpQUliRUVCZEdvZ0FTQUlRUUYwYWlBRElBUWdCaUFGRUFNZ0NFRUJhaUlJSUFWSERRQUxDd3R4QVFOL0lBSWdBMndpQlFSQUEwQWdBU0FBS0FJQUlnUkJFSFpCL3dGeElnSWdBaUFFUVFoMlFmOEJjU0lESUFNZ0JFSC9BWEVpQkVrYklBSWdBMHNiSWdZZ0JpQUVJQUlnQkVzYklBTWdCRXNiUVFoME93RUFJQUZCQW1vaEFTQUFRUVJxSVFBZ0JVRUJheUlGRFFBTEN3dVpBZ0lEZndGOElBUWdCV3doQkFKL0lBYXpRd0FBZ0VXVVF3QUF5RUtWdTBRQUFBQUFBQURnUDZBaUM1bEVBQUFBQUFBQTRFRmpCRUFnQzZvTUFRdEJnSUNBZ0hnTElRVWdCQVJBSUFkQkNIUWhDVUVBSVFZRFFDQUpJQUlnQmtFQmRDSUhhaThCQUNJQklBTWdCMm92QVFCcklnY2dCMEVmZFNJSWFpQUljMDBFUUNBQUlBWkJBblFpQ0dvaUNpQUZJQWRzUVlBUWFrRU1kU0FCYWlJSFFZRCtBeUFIUVlEK0EwZ2JJZ2RCQUNBSFFRQktHMEVNZENBQlFRRWdBUnR1SWdFZ0NpMEFBR3hCZ0JCcVFReDJPZ0FBSUFBZ0NFRUJjbW9pQnlBQklBY3RBQUJzUVlBUWFrRU1kam9BQUNBQUlBaEJBbkpxSWdjZ0FTQUhMUUFBYkVHQUVHcEJESFk2QUFBTElBWkJBV29pQmlBRVJ3MEFDd3NMJztcblxufSx7fV0sMTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgR0NfSU5URVJWQUwgPSAxMDA7XG5cbmZ1bmN0aW9uIFBvb2woY3JlYXRlLCBpZGxlKSB7XG4gIHRoaXMuY3JlYXRlID0gY3JlYXRlO1xuICB0aGlzLmF2YWlsYWJsZSA9IFtdO1xuICB0aGlzLmFjcXVpcmVkID0ge307XG4gIHRoaXMubGFzdElkID0gMTtcbiAgdGhpcy50aW1lb3V0SWQgPSAwO1xuICB0aGlzLmlkbGUgPSBpZGxlIHx8IDIwMDA7XG59XG5cblBvb2wucHJvdG90eXBlLmFjcXVpcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlc291cmNlO1xuXG4gIGlmICh0aGlzLmF2YWlsYWJsZS5sZW5ndGggIT09IDApIHtcbiAgICByZXNvdXJjZSA9IHRoaXMuYXZhaWxhYmxlLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHJlc291cmNlID0gdGhpcy5jcmVhdGUoKTtcbiAgICByZXNvdXJjZS5pZCA9IHRoaXMubGFzdElkKys7XG5cbiAgICByZXNvdXJjZS5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnJlbGVhc2UocmVzb3VyY2UpO1xuICAgIH07XG4gIH1cblxuICB0aGlzLmFjcXVpcmVkW3Jlc291cmNlLmlkXSA9IHJlc291cmNlO1xuICByZXR1cm4gcmVzb3VyY2U7XG59O1xuXG5Qb29sLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKHJlc291cmNlKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIGRlbGV0ZSB0aGlzLmFjcXVpcmVkW3Jlc291cmNlLmlkXTtcbiAgcmVzb3VyY2UubGFzdFVzZWQgPSBEYXRlLm5vdygpO1xuICB0aGlzLmF2YWlsYWJsZS5wdXNoKHJlc291cmNlKTtcblxuICBpZiAodGhpcy50aW1lb3V0SWQgPT09IDApIHtcbiAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzMi5nYygpO1xuICAgIH0sIEdDX0lOVEVSVkFMKTtcbiAgfVxufTtcblxuUG9vbC5wcm90b3R5cGUuZ2MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICB0aGlzLmF2YWlsYWJsZSA9IHRoaXMuYXZhaWxhYmxlLmZpbHRlcihmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgICBpZiAobm93IC0gcmVzb3VyY2UubGFzdFVzZWQgPiBfdGhpczMuaWRsZSkge1xuICAgICAgcmVzb3VyY2UuZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICBpZiAodGhpcy5hdmFpbGFibGUubGVuZ3RoICE9PSAwKSB7XG4gICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpczMuZ2MoKTtcbiAgICB9LCBHQ19JTlRFUlZBTCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50aW1lb3V0SWQgPSAwO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2w7XG5cbn0se31dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIEFkZCBpbnRlcm1lZGlhdGUgcmVzaXppbmcgc3RlcHMgd2hlbiBzY2FsaW5nIGRvd24gYnkgYSB2ZXJ5IGxhcmdlIGZhY3Rvci5cbi8vXG4vLyBGb3IgZXhhbXBsZSwgd2hlbiByZXNpemluZyAxMDAwMHgxMDAwMCBkb3duIHRvIDEweDEwLCBpdCdsbCByZXNpemUgaXQgdG9cbi8vIDMwMHgzMDAgZmlyc3QuXG4vL1xuLy8gSXQncyBuZWVkZWQgYmVjYXVzZSB0aWxlciBoYXMgaXNzdWVzIHdoZW4gdGhlIGVudGlyZSB0aWxlIGlzIHNjYWxlZCBkb3duXG4vLyB0byBhIGZldyBwaXhlbHMgKDEwMjRweCBzb3VyY2UgdGlsZSB3aXRoIGJvcmRlciBzaXplIDMgc2hvdWxkIHJlc3VsdCBpblxuLy8gYXQgbGVhc3QgMyszKzIgPSA4cHggdGFyZ2V0IHRpbGUsIHNvIG1heCBzY2FsZSBmYWN0b3IgaXMgMTI4IGhlcmUpLlxuLy9cbi8vIEFsc28sIGFkZGluZyBpbnRlcm1lZGlhdGUgc3RlcHMgY2FuIHNwZWVkIHVwIHByb2Nlc3NpbmcgaWYgd2UgdXNlIGxvd2VyXG4vLyBxdWFsaXR5IGFsZ29yaXRobXMgZm9yIGZpcnN0IHN0YWdlcy5cbi8vXG4ndXNlIHN0cmljdCc7IC8vIG1pbiBzaXplID0gMCByZXN1bHRzIGluIGluZmluaXRlIGxvb3AsXG4vLyBtaW4gc2l6ZSA9IDEgY2FuIGNvbnN1bWUgbGFyZ2UgYW1vdW50IG9mIG1lbW9yeVxuXG52YXIgTUlOX0lOTkVSX1RJTEVfU0laRSA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlU3RhZ2VzKGZyb21XaWR0aCwgZnJvbUhlaWdodCwgdG9XaWR0aCwgdG9IZWlnaHQsIHNyY1RpbGVTaXplLCBkZXN0VGlsZUJvcmRlcikge1xuICB2YXIgc2NhbGVYID0gdG9XaWR0aCAvIGZyb21XaWR0aDtcbiAgdmFyIHNjYWxlWSA9IHRvSGVpZ2h0IC8gZnJvbUhlaWdodDsgLy8gZGVyaXZlZCBmcm9tIGNyZWF0ZVJlZ2lvbnMgZXF1YXRpb246XG4gIC8vIGlubmVyVGlsZVdpZHRoID0gcGl4ZWxGbG9vcihzcmNUaWxlU2l6ZSAqIHNjYWxlWCkgLSAyICogZGVzdFRpbGVCb3JkZXI7XG5cbiAgdmFyIG1pblNjYWxlID0gKDIgKiBkZXN0VGlsZUJvcmRlciArIE1JTl9JTk5FUl9USUxFX1NJWkUgKyAxKSAvIHNyY1RpbGVTaXplOyAvLyByZWZ1c2UgdG8gc2NhbGUgaW1hZ2UgbXVsdGlwbGUgdGltZXMgYnkgbGVzcyB0aGFuIHR3aWNlIGVhY2ggdGltZSxcbiAgLy8gaXQgY291bGQgb25seSBoYXBwZW4gYmVjYXVzZSBvZiBpbnZhbGlkIG9wdGlvbnNcblxuICBpZiAobWluU2NhbGUgPiAwLjUpIHJldHVybiBbW3RvV2lkdGgsIHRvSGVpZ2h0XV07XG4gIHZhciBzdGFnZUNvdW50ID0gTWF0aC5jZWlsKE1hdGgubG9nKE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKSkgLyBNYXRoLmxvZyhtaW5TY2FsZSkpOyAvLyBubyBhZGRpdGlvbmFsIHJlc2l6ZXMgYXJlIG5lY2Vzc2FyeSxcbiAgLy8gc3RhZ2VDb3VudCBjYW4gYmUgemVybyBvciBiZSBuZWdhdGl2ZSB3aGVuIGVubGFyZ2luZyB0aGUgaW1hZ2VcblxuICBpZiAoc3RhZ2VDb3VudCA8PSAxKSByZXR1cm4gW1t0b1dpZHRoLCB0b0hlaWdodF1dO1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFnZUNvdW50OyBpKyspIHtcbiAgICB2YXIgd2lkdGggPSBNYXRoLnJvdW5kKE1hdGgucG93KE1hdGgucG93KGZyb21XaWR0aCwgc3RhZ2VDb3VudCAtIGkgLSAxKSAqIE1hdGgucG93KHRvV2lkdGgsIGkgKyAxKSwgMSAvIHN0YWdlQ291bnQpKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5yb3VuZChNYXRoLnBvdyhNYXRoLnBvdyhmcm9tSGVpZ2h0LCBzdGFnZUNvdW50IC0gaSAtIDEpICogTWF0aC5wb3codG9IZWlnaHQsIGkgKyAxKSwgMSAvIHN0YWdlQ291bnQpKTtcbiAgICByZXN1bHQucHVzaChbd2lkdGgsIGhlaWdodF0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbn0se31dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIFNwbGl0IG9yaWdpbmFsIGltYWdlIGludG8gbXVsdGlwbGUgMTAyNHgxMDI0IGNodW5rcyB0byByZWR1Y2UgbWVtb3J5IHVzYWdlXG4vLyAoaW1hZ2VzIGhhdmUgdG8gYmUgdW5wYWNrZWQgaW50byB0eXBlZCBhcnJheXMgZm9yIHJlc2l6aW5nKSBhbmQgYWxsb3dcbi8vIHBhcmFsbGVsIHByb2Nlc3Npbmcgb2YgbXVsdGlwbGUgdGlsZXMgYXQgYSB0aW1lLlxuLy9cbid1c2Ugc3RyaWN0Jztcbi8qXG4gKiBwaXhlbEZsb29yIGFuZCBwaXhlbENlaWwgYXJlIG1vZGlmaWVkIHZlcnNpb25zIG9mIE1hdGguZmxvb3IgYW5kIE1hdGguY2VpbFxuICogZnVuY3Rpb25zIHdoaWNoIHRha2UgaW50byBhY2NvdW50IGZsb2F0aW5nIHBvaW50IGFyaXRobWV0aWMgZXJyb3JzLlxuICogVGhvc2UgZXJyb3JzIGNhbiBjYXVzZSB1bmRlc2lyZWQgaW5jcmVtZW50cy9kZWNyZW1lbnRzIG9mIHNpemVzIGFuZCBvZmZzZXRzOlxuICogTWF0aC5jZWlsKDM2IC8gKDM2IC8gNTAwKSkgPSA1MDFcbiAqIHBpeGVsQ2VpbCgzNiAvICgzNiAvIDUwMCkpID0gNTAwXG4gKi9cblxudmFyIFBJWEVMX0VQU0lMT04gPSAxZS01O1xuXG5mdW5jdGlvbiBwaXhlbEZsb29yKHgpIHtcbiAgdmFyIG5lYXJlc3QgPSBNYXRoLnJvdW5kKHgpO1xuXG4gIGlmIChNYXRoLmFicyh4IC0gbmVhcmVzdCkgPCBQSVhFTF9FUFNJTE9OKSB7XG4gICAgcmV0dXJuIG5lYXJlc3Q7XG4gIH1cblxuICByZXR1cm4gTWF0aC5mbG9vcih4KTtcbn1cblxuZnVuY3Rpb24gcGl4ZWxDZWlsKHgpIHtcbiAgdmFyIG5lYXJlc3QgPSBNYXRoLnJvdW5kKHgpO1xuXG4gIGlmIChNYXRoLmFicyh4IC0gbmVhcmVzdCkgPCBQSVhFTF9FUFNJTE9OKSB7XG4gICAgcmV0dXJuIG5lYXJlc3Q7XG4gIH1cblxuICByZXR1cm4gTWF0aC5jZWlsKHgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZVJlZ2lvbnMob3B0aW9ucykge1xuICB2YXIgc2NhbGVYID0gb3B0aW9ucy50b1dpZHRoIC8gb3B0aW9ucy53aWR0aDtcbiAgdmFyIHNjYWxlWSA9IG9wdGlvbnMudG9IZWlnaHQgLyBvcHRpb25zLmhlaWdodDtcbiAgdmFyIGlubmVyVGlsZVdpZHRoID0gcGl4ZWxGbG9vcihvcHRpb25zLnNyY1RpbGVTaXplICogc2NhbGVYKSAtIDIgKiBvcHRpb25zLmRlc3RUaWxlQm9yZGVyO1xuICB2YXIgaW5uZXJUaWxlSGVpZ2h0ID0gcGl4ZWxGbG9vcihvcHRpb25zLnNyY1RpbGVTaXplICogc2NhbGVZKSAtIDIgKiBvcHRpb25zLmRlc3RUaWxlQm9yZGVyOyAvLyBwcmV2ZW50IGluZmluaXRlIGxvb3AsIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblxuXG4gIGlmIChpbm5lclRpbGVXaWR0aCA8IDEgfHwgaW5uZXJUaWxlSGVpZ2h0IDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgZXJyb3IgaW4gcGljYTogdGFyZ2V0IHRpbGUgd2lkdGgvaGVpZ2h0IGlzIHRvbyBzbWFsbC4nKTtcbiAgfVxuXG4gIHZhciB4LCB5O1xuICB2YXIgaW5uZXJYLCBpbm5lclksIHRvVGlsZVdpZHRoLCB0b1RpbGVIZWlnaHQ7XG4gIHZhciB0aWxlcyA9IFtdO1xuICB2YXIgdGlsZTsgLy8gd2UgZ28gdG9wLXRvLWRvd24gaW5zdGVhZCBvZiBsZWZ0LXRvLXJpZ2h0IHRvIG1ha2UgaW1hZ2UgZGlzcGxheWVkIGZyb20gdG9wIHRvXG4gIC8vIGRvZXNuIGluIHRoZSBicm93c2VyXG5cbiAgZm9yIChpbm5lclkgPSAwOyBpbm5lclkgPCBvcHRpb25zLnRvSGVpZ2h0OyBpbm5lclkgKz0gaW5uZXJUaWxlSGVpZ2h0KSB7XG4gICAgZm9yIChpbm5lclggPSAwOyBpbm5lclggPCBvcHRpb25zLnRvV2lkdGg7IGlubmVyWCArPSBpbm5lclRpbGVXaWR0aCkge1xuICAgICAgeCA9IGlubmVyWCAtIG9wdGlvbnMuZGVzdFRpbGVCb3JkZXI7XG5cbiAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICB4ID0gMDtcbiAgICAgIH1cblxuICAgICAgdG9UaWxlV2lkdGggPSBpbm5lclggKyBpbm5lclRpbGVXaWR0aCArIG9wdGlvbnMuZGVzdFRpbGVCb3JkZXIgLSB4O1xuXG4gICAgICBpZiAoeCArIHRvVGlsZVdpZHRoID49IG9wdGlvbnMudG9XaWR0aCkge1xuICAgICAgICB0b1RpbGVXaWR0aCA9IG9wdGlvbnMudG9XaWR0aCAtIHg7XG4gICAgICB9XG5cbiAgICAgIHkgPSBpbm5lclkgLSBvcHRpb25zLmRlc3RUaWxlQm9yZGVyO1xuXG4gICAgICBpZiAoeSA8IDApIHtcbiAgICAgICAgeSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRvVGlsZUhlaWdodCA9IGlubmVyWSArIGlubmVyVGlsZUhlaWdodCArIG9wdGlvbnMuZGVzdFRpbGVCb3JkZXIgLSB5O1xuXG4gICAgICBpZiAoeSArIHRvVGlsZUhlaWdodCA+PSBvcHRpb25zLnRvSGVpZ2h0KSB7XG4gICAgICAgIHRvVGlsZUhlaWdodCA9IG9wdGlvbnMudG9IZWlnaHQgLSB5O1xuICAgICAgfVxuXG4gICAgICB0aWxlID0ge1xuICAgICAgICB0b1g6IHgsXG4gICAgICAgIHRvWTogeSxcbiAgICAgICAgdG9XaWR0aDogdG9UaWxlV2lkdGgsXG4gICAgICAgIHRvSGVpZ2h0OiB0b1RpbGVIZWlnaHQsXG4gICAgICAgIHRvSW5uZXJYOiBpbm5lclgsXG4gICAgICAgIHRvSW5uZXJZOiBpbm5lclksXG4gICAgICAgIHRvSW5uZXJXaWR0aDogaW5uZXJUaWxlV2lkdGgsXG4gICAgICAgIHRvSW5uZXJIZWlnaHQ6IGlubmVyVGlsZUhlaWdodCxcbiAgICAgICAgb2Zmc2V0WDogeCAvIHNjYWxlWCAtIHBpeGVsRmxvb3IoeCAvIHNjYWxlWCksXG4gICAgICAgIG9mZnNldFk6IHkgLyBzY2FsZVkgLSBwaXhlbEZsb29yKHkgLyBzY2FsZVkpLFxuICAgICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiBzY2FsZVksXG4gICAgICAgIHg6IHBpeGVsRmxvb3IoeCAvIHNjYWxlWCksXG4gICAgICAgIHk6IHBpeGVsRmxvb3IoeSAvIHNjYWxlWSksXG4gICAgICAgIHdpZHRoOiBwaXhlbENlaWwodG9UaWxlV2lkdGggLyBzY2FsZVgpLFxuICAgICAgICBoZWlnaHQ6IHBpeGVsQ2VpbCh0b1RpbGVIZWlnaHQgLyBzY2FsZVkpXG4gICAgICB9O1xuICAgICAgdGlsZXMucHVzaCh0aWxlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGlsZXM7XG59O1xuXG59LHt9XSwxNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9iakNsYXNzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzLmlzQ2FudmFzID0gZnVuY3Rpb24gaXNDYW52YXMoZWxlbWVudCkge1xuICB2YXIgY25hbWUgPSBvYmpDbGFzcyhlbGVtZW50KTtcbiAgcmV0dXJuIGNuYW1lID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nXG4gIC8qIGJyb3dzZXIgKi9cbiAgfHwgY25hbWUgPT09ICdbb2JqZWN0IE9mZnNjcmVlbkNhbnZhc10nIHx8IGNuYW1lID09PSAnW29iamVjdCBDYW52YXNdJ1xuICAvKiBub2RlLWNhbnZhcyAqL1xuICA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pc0ltYWdlID0gZnVuY3Rpb24gaXNJbWFnZShlbGVtZW50KSB7XG4gIHJldHVybiBvYmpDbGFzcyhlbGVtZW50KSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nO1xufTtcblxubW9kdWxlLmV4cG9ydHMuaXNJbWFnZUJpdG1hcCA9IGZ1bmN0aW9uIGlzSW1hZ2VCaXRtYXAoZWxlbWVudCkge1xuICByZXR1cm4gb2JqQ2xhc3MoZWxlbWVudCkgPT09ICdbb2JqZWN0IEltYWdlQml0bWFwXSc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5saW1pdGVyID0gZnVuY3Rpb24gbGltaXRlcihjb25jdXJyZW5jeSkge1xuICB2YXIgYWN0aXZlID0gMCxcbiAgICAgIHF1ZXVlID0gW107XG5cbiAgZnVuY3Rpb24gcm9sbCgpIHtcbiAgICBpZiAoYWN0aXZlIDwgY29uY3VycmVuY3kgJiYgcXVldWUubGVuZ3RoKSB7XG4gICAgICBhY3RpdmUrKztcbiAgICAgIHF1ZXVlLnNoaWZ0KCkoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gbGltaXQoZm4pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZuKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIGFjdGl2ZS0tO1xuICAgICAgICAgIHJvbGwoKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIGFjdGl2ZS0tO1xuICAgICAgICAgIHJvbGwoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJvbGwoKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNpYl9xdWFsaXR5X25hbWUgPSBmdW5jdGlvbiBjaWJfcXVhbGl0eV9uYW1lKG51bSkge1xuICBzd2l0Y2ggKG51bSkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiAncGl4ZWxhdGVkJztcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiAnbG93JztcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiAnbWVkaXVtJztcbiAgfVxuXG4gIHJldHVybiAnaGlnaCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jaWJfc3VwcG9ydCA9IGZ1bmN0aW9uIGNpYl9zdXBwb3J0KGNyZWF0ZUNhbnZhcykge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IGNyZWF0ZUNhbnZhcygxMDAsIDEwMCk7XG4gICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGMsIDAsIDAsIDEwMCwgMTAwLCB7XG4gICAgICByZXNpemVXaWR0aDogMTAsXG4gICAgICByZXNpemVIZWlnaHQ6IDEwLFxuICAgICAgcmVzaXplUXVhbGl0eTogJ2hpZ2gnXG4gICAgfSkudGhlbihmdW5jdGlvbiAoYml0bWFwKSB7XG4gICAgICB2YXIgc3RhdHVzID0gYml0bWFwLndpZHRoID09PSAxMDsgLy8gQnJhbmNoIGJlbG93IGlzIGZpbHRlcmVkIG9uIHVwcGVyIGxldmVsLiBXZSBkbyBub3QgY2FsbCByZXNpemVcbiAgICAgIC8vIGRldGVjdGlvbiBmb3IgYmFzaWMgSW1hZ2VCaXRtYXAuXG4gICAgICAvL1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ltYWdlQml0bWFwXG4gICAgICAvLyBvbGQgQ3JvbWUgNTEgaGFzIEltYWdlQml0bWFwIHdpdGhvdXQgLmNsb3NlKCkuIFRoZW4gdGhpcyBjb2RlXG4gICAgICAvLyB3aWxsIHRocm93IGFuZCByZXR1cm4gJ2ZhbHNlJyBhcyBleHBlY3RlZC5cbiAgICAgIC8vXG5cbiAgICAgIGJpdG1hcC5jbG9zZSgpO1xuICAgICAgYyA9IG51bGw7XG4gICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH0pO1xuICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMud29ya2VyX29mZnNjcmVlbl9jYW52YXNfc3VwcG9ydCA9IGZ1bmN0aW9uIHdvcmtlcl9vZmZzY3JlZW5fY2FudmFzX3N1cHBvcnQoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBpZiBPZmZzY3JlZW5DYW52YXMgaXMgcHJlc2VudCwgd2UgYXNzdW1lIGJyb3dzZXIgc3VwcG9ydHMgV29ya2VyIGFuZCBidWlsdC1pbiBQcm9taXNlIGFzIHdlbGxcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdvcmtlclBheWxvYWQoc2VsZikge1xuICAgICAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEwLCAxMCk7IC8vIHRlc3QgdGhhdCAyZCBjb250ZXh0IGNhbiBiZSB1c2VkIGluIHdvcmtlclxuXG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LnJlY3QoMCwgMCwgMSwgMSk7IC8vIHRlc3QgdGhhdCBjaWIgY2FuIGJlIHVzZWQgdG8gcmV0dXJuIGltYWdlIGJpdG1hcCBmcm9tIHdvcmtlclxuXG4gICAgICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChjYW52YXMsIDAsIDAsIDEsIDEpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnBvc3RNZXNzYWdlKHRydWUpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5wb3N0TWVzc2FnZShmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgY29kZSA9IGJ0b2EoXCIoXCIuY29uY2F0KHdvcmtlclBheWxvYWQudG9TdHJpbmcoKSwgXCIpKHNlbGYpO1wiKSk7XG4gICAgdmFyIHcgPSBuZXcgV29ya2VyKFwiZGF0YTp0ZXh0L2phdmFzY3JpcHQ7YmFzZTY0LFwiLmNvbmNhdChjb2RlKSk7XG5cbiAgICB3Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgcmV0dXJuIHJlc29sdmUoZXYuZGF0YSk7XG4gICAgfTtcblxuICAgIHcub25lcnJvciA9IHJlamVjdDtcbiAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59OyAvLyBDaGVjayBpZiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEgY2FuIGJlIHVzZWQsXG4vLyBGaXJlRm94IHJhbmRvbWl6ZXMgdGhlIG91dHB1dCBvZiB0aGF0IGZ1bmN0aW9uIGluIGBwcml2YWN5LnJlc2lzdEZpbmdlcnByaW50aW5nYCBtb2RlXG5cblxubW9kdWxlLmV4cG9ydHMuY2FuX3VzZV9jYW52YXMgPSBmdW5jdGlvbiBjYW5fdXNlX2NhbnZhcyhjcmVhdGVDYW52YXMpIHtcbiAgdmFyIHVzYWJsZSA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygyLCAxKTtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIGQgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKDIsIDEpO1xuICAgIGQuZGF0YVswXSA9IDEyO1xuICAgIGQuZGF0YVsxXSA9IDIzO1xuICAgIGQuZGF0YVsyXSA9IDM0O1xuICAgIGQuZGF0YVszXSA9IDI1NTtcbiAgICBkLmRhdGFbNF0gPSA0NTtcbiAgICBkLmRhdGFbNV0gPSA1NjtcbiAgICBkLmRhdGFbNl0gPSA2NztcbiAgICBkLmRhdGFbN10gPSAyNTU7XG4gICAgY3R4LnB1dEltYWdlRGF0YShkLCAwLCAwKTtcbiAgICBkID0gbnVsbDtcbiAgICBkID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAyLCAxKTtcblxuICAgIGlmIChkLmRhdGFbMF0gPT09IDEyICYmIGQuZGF0YVsxXSA9PT0gMjMgJiYgZC5kYXRhWzJdID09PSAzNCAmJiBkLmRhdGFbM10gPT09IDI1NSAmJiBkLmRhdGFbNF0gPT09IDQ1ICYmIGQuZGF0YVs1XSA9PT0gNTYgJiYgZC5kYXRhWzZdID09PSA2NyAmJiBkLmRhdGFbN10gPT09IDI1NSkge1xuICAgICAgdXNhYmxlID0gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge31cblxuICByZXR1cm4gdXNhYmxlO1xufTsgLy8gQ2hlY2sgaWYgY3JlYXRlSW1hZ2VCaXRtYXAoaW1nLCBzeCwgc3ksIHN3LCBzaCkgc2lnbmF0dXJlIHdvcmtzIGNvcnJlY3RseVxuLy8gd2l0aCBKUEVHIGltYWdlcyBvcmllbnRlZCB3aXRoIEV4aWY7XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjIwNjcxXG4vLyBUT0RPOiByZW1vdmUgYWZ0ZXIgaXQncyBmaXhlZCBpbiBjaHJvbWUgZm9yIGF0IGxlYXN0IDIgcmVsZWFzZXNcblxuXG5tb2R1bGUuZXhwb3J0cy5jaWJfY2FuX3VzZV9yZWdpb24gPSBmdW5jdGlvbiBjaWJfY2FuX3VzZV9yZWdpb24oKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5zcmMgPSAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwnICsgJy85ai80UUJpUlhocFpnQUFUVTBBS2dBQUFBZ0FCUUVTQUFNQUFBQUJBQVlBQUFFYUFBVUFBQUFCQUFBQVNnRWJBQVVBQScgKyAnQUFCQUFBQVVnRW9BQU1BQUFBQkFBSUFBQUlUQUFNQUFBQUJBQUVBQUFBQUFBQUFBQUJJQUFBQUFRQUFBRWdBQUFBQi85JyArICdzQVF3QUVBd01FQXdNRUJBTUVCUVFFQlFZS0J3WUdCZ1lOQ1FvSUNnOE5FQkFQRFE4T0VSTVlGQkVTRnhJT0R4VWNGUmMnICsgJ1pHUnNiR3hBVUhSOGRHaDhZR2hzYS85c0FRd0VFQlFVR0JRWU1Cd2NNR2hFUEVSb2FHaG9hR2hvYUdob2FHaG9hR2hvYScgKyAnR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdob2EvOElBRVFnQUFRQUNBd0VSQUFJUkFRTVJBJyArICdmL0VBQlFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQWYveEFBVUFRRUFBQUFBQUFBQUFBQUFBQUFBQUFBQS85b0FEQU1CQUEnICsgJ0lRQXhBQUFBRi9QLy9FQUJRUUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFELzJnQUlBUUVBQVFVQ2YvL0VBQlFSQVFBQUFBQScgKyAnQUFBQUFBQUFBQUFBQUFBRC8yZ0FJQVFNQkFUOEJmLy9FQUJRUkFRQUFBQUFBQUFBQUFBQUFBQUFBQUFELzJnQUlBUUlCJyArICdBVDhCZi8vRUFCUVFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBRC8yZ0FJQVFFQUJqOENmLy9FQUJRUUFRQUFBQUFBQUFBQUEnICsgJ0FBQUFBQUFBQUQvMmdBSUFRRUFBVDhoZi8vYUFBd0RBUUFDQUFNQUFBQVFILy9FQUJRUkFRQUFBQUFBQUFBQUFBQUFBQScgKyAnQUFBQUQvMmdBSUFRTUJBVDhRZi8vRUFCUVJBUUFBQUFBQUFBQUFBQUFBQUFBQUFBRC8yZ0FJQVFJQkFUOFFmLy9FQUJRJyArICdRQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUQvMmdBSUFRRUFBVDhRZi8vWic7XG5cbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCkudGhlbihmdW5jdGlvbiAoYml0bWFwKSB7XG4gICAgICAgIGlmIChiaXRtYXAud2lkdGggPT09IGltYWdlLndpZHRoICYmIGJpdG1hcC5oZWlnaHQgPT09IGltYWdlLmhlaWdodCkge1xuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSk7XG4gICAgfTtcbiAgfSk7XG59O1xuXG59LHt9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBXZWIgV29ya2VyIHdyYXBwZXIgZm9yIGltYWdlIHJlc2l6ZSBmdW5jdGlvblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIE1hdGhMaWIgPSBfZGVyZXFfKCcuL21hdGhsaWInKTtcblxuICB2YXIgbWF0aExpYjtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cblxuICBvbm1lc3NhZ2UgPSBmdW5jdGlvbiBvbm1lc3NhZ2UoZXYpIHtcbiAgICB2YXIgdGlsZU9wdHMgPSBldi5kYXRhLm9wdHM7XG4gICAgdmFyIHJldHVybkJpdG1hcCA9IGZhbHNlO1xuXG4gICAgaWYgKCF0aWxlT3B0cy5zcmMgJiYgdGlsZU9wdHMuc3JjQml0bWFwKSB7XG4gICAgICB2YXIgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh0aWxlT3B0cy53aWR0aCwgdGlsZU9wdHMuaGVpZ2h0KTtcbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgICAgIGFscGhhOiBCb29sZWFuKHRpbGVPcHRzLmFscGhhKVxuICAgICAgfSk7XG4gICAgICBjdHguZHJhd0ltYWdlKHRpbGVPcHRzLnNyY0JpdG1hcCwgMCwgMCk7XG4gICAgICB0aWxlT3B0cy5zcmMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRpbGVPcHRzLndpZHRoLCB0aWxlT3B0cy5oZWlnaHQpLmRhdGE7XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICB0aWxlT3B0cy5zcmNCaXRtYXAuY2xvc2UoKTtcbiAgICAgIHRpbGVPcHRzLnNyY0JpdG1hcCA9IG51bGw7IC8vIFRlbXBvcmFyeSBmb3JjZSBvdXQgZGF0YSB0byB0eXBlZCBhcnJheSwgYmVjYXVzZSBDaHJvbWUgaGF2ZSBhcnRlZmFjdHNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYS9pc3N1ZXMvMjIzXG4gICAgICAvLyByZXR1cm5CaXRtYXAgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghbWF0aExpYikgbWF0aExpYiA9IG5ldyBNYXRoTGliKGV2LmRhdGEuZmVhdHVyZXMpOyAvLyBVc2UgbXVsdGltYXRoJ3Mgc3luYyBhdXRvLWluaXQuIEF2b2lkIFByb21pc2UgdXNlIGluIG9sZCBicm93c2VycyxcbiAgICAvLyBiZWNhdXNlIHBvbHlmaWxscyBhcmUgbm90IHByb3BhZ2F0ZWQgdG8gd2Vid29ya2VyLlxuXG4gICAgdmFyIGRhdGEgPSBtYXRoTGliLnJlc2l6ZUFuZFVuc2hhcnAodGlsZU9wdHMpO1xuXG4gICAgaWYgKHJldHVybkJpdG1hcCkge1xuICAgICAgdmFyIHRvSW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkoZGF0YSksIHRpbGVPcHRzLnRvV2lkdGgsIHRpbGVPcHRzLnRvSGVpZ2h0KTtcblxuICAgICAgdmFyIF9jYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHRpbGVPcHRzLnRvV2lkdGgsIHRpbGVPcHRzLnRvSGVpZ2h0KTtcblxuICAgICAgdmFyIF9jdHggPSBfY2FudmFzLmdldENvbnRleHQoJzJkJywge1xuICAgICAgICBhbHBoYTogQm9vbGVhbih0aWxlT3B0cy5hbHBoYSlcbiAgICAgIH0pO1xuXG4gICAgICBfY3R4LnB1dEltYWdlRGF0YSh0b0ltYWdlRGF0YSwgMCwgMCk7XG5cbiAgICAgIGNyZWF0ZUltYWdlQml0bWFwKF9jYW52YXMpLnRoZW4oZnVuY3Rpb24gKGJpdG1hcCkge1xuICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgYml0bWFwOiBiaXRtYXBcbiAgICAgICAgfSwgW2JpdG1hcF0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSwgW2RhdGEuYnVmZmVyXSk7XG4gICAgfVxuICB9O1xufTtcblxufSx7XCIuL21hdGhsaWJcIjoxfV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ2FsY3VsYXRlIEdhdXNzaWFuIGJsdXIgb2YgYW4gaW1hZ2UgdXNpbmcgSUlSIGZpbHRlclxuLy8gVGhlIG1ldGhvZCBpcyB0YWtlbiBmcm9tIEludGVsJ3Mgd2hpdGUgcGFwZXIgYW5kIGNvZGUgZXhhbXBsZSBhdHRhY2hlZCB0byBpdDpcbi8vIGh0dHBzOi8vc29mdHdhcmUuaW50ZWwuY29tL2VuLXVzL2FydGljbGVzL2lpci1nYXVzc2lhbi1ibHVyLWZpbHRlclxuLy8gLWltcGxlbWVudGF0aW9uLXVzaW5nLWludGVsLWFkdmFuY2VkLXZlY3Rvci1leHRlbnNpb25zXG5cbnZhciBhMCwgYTEsIGEyLCBhMywgYjEsIGIyLCBsZWZ0X2Nvcm5lciwgcmlnaHRfY29ybmVyO1xuXG5mdW5jdGlvbiBnYXVzc0NvZWYoc2lnbWEpIHtcbiAgaWYgKHNpZ21hIDwgMC41KSB7XG4gICAgc2lnbWEgPSAwLjU7XG4gIH1cblxuICB2YXIgYSA9IE1hdGguZXhwKDAuNzI2ICogMC43MjYpIC8gc2lnbWEsXG4gICAgICBnMSA9IE1hdGguZXhwKC1hKSxcbiAgICAgIGcyID0gTWF0aC5leHAoLTIgKiBhKSxcbiAgICAgIGsgPSAoMSAtIGcxKSAqICgxIC0gZzEpIC8gKDEgKyAyICogYSAqIGcxIC0gZzIpO1xuXG4gIGEwID0gaztcbiAgYTEgPSBrICogKGEgLSAxKSAqIGcxO1xuICBhMiA9IGsgKiAoYSArIDEpICogZzE7XG4gIGEzID0gLWsgKiBnMjtcbiAgYjEgPSAyICogZzE7XG4gIGIyID0gLWcyO1xuICBsZWZ0X2Nvcm5lciA9IChhMCArIGExKSAvICgxIC0gYjEgLSBiMik7XG4gIHJpZ2h0X2Nvcm5lciA9IChhMiArIGEzKSAvICgxIC0gYjEgLSBiMik7XG5cbiAgLy8gQXR0ZW1wdCB0byBmb3JjZSB0eXBlIHRvIEZQMzIuXG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFsgYTAsIGExLCBhMiwgYTMsIGIxLCBiMiwgbGVmdF9jb3JuZXIsIHJpZ2h0X2Nvcm5lciBdKTtcbn1cblxuZnVuY3Rpb24gY29udm9sdmVNb25vMTYoc3JjLCBvdXQsIGxpbmUsIGNvZWZmLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIC8vIHRha2VzIHNyYyBpbWFnZSBhbmQgd3JpdGVzIHRoZSBibHVycmVkIGFuZCB0cmFuc3Bvc2VkIHJlc3VsdCBpbnRvIG91dFxuXG4gIHZhciBwcmV2X3NyYywgY3Vycl9zcmMsIGN1cnJfb3V0LCBwcmV2X291dCwgcHJldl9wcmV2X291dDtcbiAgdmFyIHNyY19pbmRleCwgb3V0X2luZGV4LCBsaW5lX2luZGV4O1xuICB2YXIgaSwgajtcbiAgdmFyIGNvZWZmX2EwLCBjb2VmZl9hMSwgY29lZmZfYjEsIGNvZWZmX2IyO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgIHNyY19pbmRleCA9IGkgKiB3aWR0aDtcbiAgICBvdXRfaW5kZXggPSBpO1xuICAgIGxpbmVfaW5kZXggPSAwO1xuXG4gICAgLy8gbGVmdCB0byByaWdodFxuICAgIHByZXZfc3JjID0gc3JjW3NyY19pbmRleF07XG4gICAgcHJldl9wcmV2X291dCA9IHByZXZfc3JjICogY29lZmZbNl07XG4gICAgcHJldl9vdXQgPSBwcmV2X3ByZXZfb3V0O1xuXG4gICAgY29lZmZfYTAgPSBjb2VmZlswXTtcbiAgICBjb2VmZl9hMSA9IGNvZWZmWzFdO1xuICAgIGNvZWZmX2IxID0gY29lZmZbNF07XG4gICAgY29lZmZfYjIgPSBjb2VmZls1XTtcblxuICAgIGZvciAoaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICBjdXJyX3NyYyA9IHNyY1tzcmNfaW5kZXhdO1xuXG4gICAgICBjdXJyX291dCA9IGN1cnJfc3JjICogY29lZmZfYTAgK1xuICAgICAgICAgICAgICAgICBwcmV2X3NyYyAqIGNvZWZmX2ExICtcbiAgICAgICAgICAgICAgICAgcHJldl9vdXQgKiBjb2VmZl9iMSArXG4gICAgICAgICAgICAgICAgIHByZXZfcHJldl9vdXQgKiBjb2VmZl9iMjtcblxuICAgICAgcHJldl9wcmV2X291dCA9IHByZXZfb3V0O1xuICAgICAgcHJldl9vdXQgPSBjdXJyX291dDtcbiAgICAgIHByZXZfc3JjID0gY3Vycl9zcmM7XG5cbiAgICAgIGxpbmVbbGluZV9pbmRleF0gPSBwcmV2X291dDtcbiAgICAgIGxpbmVfaW5kZXgrKztcbiAgICAgIHNyY19pbmRleCsrO1xuICAgIH1cblxuICAgIHNyY19pbmRleC0tO1xuICAgIGxpbmVfaW5kZXgtLTtcbiAgICBvdXRfaW5kZXggKz0gaGVpZ2h0ICogKHdpZHRoIC0gMSk7XG5cbiAgICAvLyByaWdodCB0byBsZWZ0XG4gICAgcHJldl9zcmMgPSBzcmNbc3JjX2luZGV4XTtcbiAgICBwcmV2X3ByZXZfb3V0ID0gcHJldl9zcmMgKiBjb2VmZls3XTtcbiAgICBwcmV2X291dCA9IHByZXZfcHJldl9vdXQ7XG4gICAgY3Vycl9zcmMgPSBwcmV2X3NyYztcblxuICAgIGNvZWZmX2EwID0gY29lZmZbMl07XG4gICAgY29lZmZfYTEgPSBjb2VmZlszXTtcblxuICAgIGZvciAoaiA9IHdpZHRoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGN1cnJfb3V0ID0gY3Vycl9zcmMgKiBjb2VmZl9hMCArXG4gICAgICAgICAgICAgICAgIHByZXZfc3JjICogY29lZmZfYTEgK1xuICAgICAgICAgICAgICAgICBwcmV2X291dCAqIGNvZWZmX2IxICtcbiAgICAgICAgICAgICAgICAgcHJldl9wcmV2X291dCAqIGNvZWZmX2IyO1xuXG4gICAgICBwcmV2X3ByZXZfb3V0ID0gcHJldl9vdXQ7XG4gICAgICBwcmV2X291dCA9IGN1cnJfb3V0O1xuXG4gICAgICBwcmV2X3NyYyA9IGN1cnJfc3JjO1xuICAgICAgY3Vycl9zcmMgPSBzcmNbc3JjX2luZGV4XTtcblxuICAgICAgb3V0W291dF9pbmRleF0gPSBsaW5lW2xpbmVfaW5kZXhdICsgcHJldl9vdXQ7XG5cbiAgICAgIHNyY19pbmRleC0tO1xuICAgICAgbGluZV9pbmRleC0tO1xuICAgICAgb3V0X2luZGV4IC09IGhlaWdodDtcbiAgICB9XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBibHVyTW9ubzE2KHNyYywgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIC8vIFF1aWNrIGV4aXQgb24gemVybyByYWRpdXNcbiAgaWYgKCFyYWRpdXMpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIG91dCAgICAgID0gbmV3IFVpbnQxNkFycmF5KHNyYy5sZW5ndGgpLFxuICAgICAgdG1wX2xpbmUgPSBuZXcgRmxvYXQzMkFycmF5KE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpKTtcblxuICB2YXIgY29lZmYgPSBnYXVzc0NvZWYocmFkaXVzKTtcblxuICBjb252b2x2ZU1vbm8xNihzcmMsIG91dCwgdG1wX2xpbmUsIGNvZWZmLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xuICBjb252b2x2ZU1vbm8xNihvdXQsIHNyYywgdG1wX2xpbmUsIGNvZWZmLCBoZWlnaHQsIHdpZHRoLCByYWRpdXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJsdXJNb25vMTY7XG5cbn0se31dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cblxufSx7fV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhc3NpZ24gICAgICAgICA9IF9kZXJlcV8oJ29iamVjdC1hc3NpZ24nKTtcbnZhciBiYXNlNjRkZWNvZGUgICA9IF9kZXJlcV8oJy4vbGliL2Jhc2U2NGRlY29kZScpO1xudmFyIGhhc1dlYkFzc2VtYmx5ID0gX2RlcmVxXygnLi9saWIvd2FfZGV0ZWN0Jyk7XG5cblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAganM6IHRydWUsXG4gIHdhc206IHRydWVcbn07XG5cblxuZnVuY3Rpb24gTXVsdGlNYXRoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE11bHRpTWF0aCkpIHJldHVybiBuZXcgTXVsdGlNYXRoKG9wdGlvbnMpO1xuXG4gIHZhciBvcHRzID0gYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMgfHwge30pO1xuXG4gIHRoaXMub3B0aW9ucyAgICAgICAgID0gb3B0cztcblxuICB0aGlzLl9fY2FjaGUgICAgICAgICA9IHt9O1xuXG4gIHRoaXMuX19pbml0X3Byb21pc2UgID0gbnVsbDtcbiAgdGhpcy5fX21vZHVsZXMgICAgICAgPSBvcHRzLm1vZHVsZXMgfHwge307XG4gIHRoaXMuX19tZW1vcnkgICAgICAgID0gbnVsbDtcbiAgdGhpcy5fX3dhc20gICAgICAgICAgPSB7fTtcblxuICB0aGlzLl9faXNMRSA9ICgobmV3IFVpbnQzMkFycmF5KChuZXcgVWludDhBcnJheShbIDEsIDAsIDAsIDAgXSkpLmJ1ZmZlcikpWzBdID09PSAxKTtcblxuICBpZiAoIXRoaXMub3B0aW9ucy5qcyAmJiAhdGhpcy5vcHRpb25zLndhc20pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hdGhsaWI6IGF0IGxlYXN0IFwianNcIiBvciBcIndhc21cIiBzaG91bGQgYmUgZW5hYmxlZCcpO1xuICB9XG59XG5cblxuTXVsdGlNYXRoLnByb3RvdHlwZS5oYXNfd2FzbSA9IGhhc1dlYkFzc2VtYmx5O1xuXG5cbk11bHRpTWF0aC5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICB0aGlzLl9fbW9kdWxlc1ttb2R1bGUubmFtZV0gPSBtb2R1bGU7XG5cbiAgLy8gUGluIHRoZSBiZXN0IHBvc3NpYmxlIGltcGxlbWVudGF0aW9uXG4gIGlmICh0aGlzLm9wdGlvbnMud2FzbSAmJiB0aGlzLmhhc193YXNtKCkgJiYgbW9kdWxlLndhc21fZm4pIHtcbiAgICB0aGlzW21vZHVsZS5uYW1lXSA9IG1vZHVsZS53YXNtX2ZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXNbbW9kdWxlLm5hbWVdID0gbW9kdWxlLmZuO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbk11bHRpTWF0aC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX19pbml0X3Byb21pc2UpIHJldHVybiB0aGlzLl9faW5pdF9wcm9taXNlO1xuXG4gIGlmICghdGhpcy5vcHRpb25zLmpzICYmIHRoaXMub3B0aW9ucy53YXNtICYmICF0aGlzLmhhc193YXNtKCkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdtYXRobGliOiBvbmx5IFwid2FzbVwiIHdhcyBlbmFibGVkLCBidXQgaXRcXCdzIG5vdCBzdXBwb3J0ZWQnKSk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5fX2luaXRfcHJvbWlzZSA9IFByb21pc2UuYWxsKE9iamVjdC5rZXlzKHNlbGYuX19tb2R1bGVzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgbW9kdWxlID0gc2VsZi5fX21vZHVsZXNbbmFtZV07XG5cbiAgICBpZiAoIXNlbGYub3B0aW9ucy53YXNtIHx8ICFzZWxmLmhhc193YXNtKCkgfHwgIW1vZHVsZS53YXNtX2ZuKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIElmIGFscmVhZHkgY29tcGlsZWQgLSBleGl0XG4gICAgaWYgKHNlbGYuX193YXNtW25hbWVdKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIENvbXBpbGUgd2FzbSBzb3VyY2VcbiAgICByZXR1cm4gV2ViQXNzZW1ibHkuY29tcGlsZShzZWxmLl9fYmFzZTY0ZGVjb2RlKG1vZHVsZS53YXNtX3NyYykpXG4gICAgICAudGhlbihmdW5jdGlvbiAobSkgeyBzZWxmLl9fd2FzbVtuYW1lXSA9IG07IH0pO1xuICB9KSlcbiAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmOyB9KTtcblxuICByZXR1cm4gdGhpcy5fX2luaXRfcHJvbWlzZTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1ldGhvZHMgYmVsb3cgYXJlIGZvciBpbnRlcm5hbCB1c2UgZnJvbSBwbHVnaW5zXG5cblxuLy8gU2ltcGxlIGRlY29kZSBiYXNlNjQgdG8gdHlwZWQgYXJyYXkuIFVzZWZ1bCB0byBsb2FkIGVtYmVkZGVkIHdlYmFzc2VtYmx5XG4vLyBjb2RlLiBZb3UgcHJvYmFibHkgZG9uJ3QgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIGRpcmVjdGx5LlxuLy9cbk11bHRpTWF0aC5wcm90b3R5cGUuX19iYXNlNjRkZWNvZGUgPSBiYXNlNjRkZWNvZGU7XG5cblxuLy8gSW5jcmVhc2UgY3VycmVudCBtZW1vcnkgdG8gaW5jbHVkZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzLiBEbyBub3RoaW5nIGlmXG4vLyBzaXplIGlzIGFscmVhZHkgb2suIFlvdSBwcm9iYWJseSBkb24ndCBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QgZGlyZWN0bHksXG4vLyBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCBmcm9tIGAuX19pbnN0YW5jZSgpYC5cbi8vXG5NdWx0aU1hdGgucHJvdG90eXBlLl9fcmVhbGxvY2F0ZSA9IGZ1bmN0aW9uIG1lbV9ncm93X3RvKGJ5dGVzKSB7XG4gIGlmICghdGhpcy5fX21lbW9yeSkge1xuICAgIHRoaXMuX19tZW1vcnkgPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtcbiAgICAgIGluaXRpYWw6IE1hdGguY2VpbChieXRlcyAvICg2NCAqIDEwMjQpKVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9fbWVtb3J5O1xuICB9XG5cbiAgdmFyIG1lbV9zaXplID0gdGhpcy5fX21lbW9yeS5idWZmZXIuYnl0ZUxlbmd0aDtcblxuICBpZiAobWVtX3NpemUgPCBieXRlcykge1xuICAgIHRoaXMuX19tZW1vcnkuZ3JvdyhNYXRoLmNlaWwoKGJ5dGVzIC0gbWVtX3NpemUpIC8gKDY0ICogMTAyNCkpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9fbWVtb3J5O1xufTtcblxuXG4vLyBSZXR1cm5zIGluc3RhbnRpbmF0ZWQgd2ViYXNzZW1ibHkgaXRlbSBieSBuYW1lLCB3aXRoIHNwZWNpZmllZCBtZW1vcnkgc2l6ZVxuLy8gYW5kIGVudmlyb25tZW50LlxuLy8gLSB1c2UgY2FjaGUgaWYgYXZhaWxhYmxlXG4vLyAtIGRvIHN5bmMgbW9kdWxlIGluaXQsIGlmIGFzeW5jIGluaXQgd2FzIG5vdCBjYWxsZWQgZWFybGllclxuLy8gLSBhbGxvY2F0ZSBtZW1vcnkgaWYgbm90IGVub3VndGhcbi8vIC0gY2FuIGV4cG9ydCBmdW5jdGlvbnMgdG8gd2ViYXNzZW1ibHkgdmlhIFwiZW52X2V4dHJhXCIsXG4vLyAgIGZvciBleGFtcGxlLCB7IGV4cDogTWF0aC5leHAgfVxuLy9cbk11bHRpTWF0aC5wcm90b3R5cGUuX19pbnN0YW5jZSA9IGZ1bmN0aW9uIGluc3RhbmNlKG5hbWUsIG1lbXNpemUsIGVudl9leHRyYSkge1xuICBpZiAobWVtc2l6ZSkgdGhpcy5fX3JlYWxsb2NhdGUobWVtc2l6ZSk7XG5cbiAgLy8gSWYgLmluaXQoKSB3YXMgbm90IGNhbGxlZCwgZG8gc3luYyBjb21waWxlXG4gIGlmICghdGhpcy5fX3dhc21bbmFtZV0pIHtcbiAgICB2YXIgbW9kdWxlID0gdGhpcy5fX21vZHVsZXNbbmFtZV07XG4gICAgdGhpcy5fX3dhc21bbmFtZV0gPSBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKHRoaXMuX19iYXNlNjRkZWNvZGUobW9kdWxlLndhc21fc3JjKSk7XG4gIH1cblxuICBpZiAoIXRoaXMuX19jYWNoZVtuYW1lXSkge1xuICAgIHZhciBlbnZfYmFzZSA9IHtcbiAgICAgIG1lbW9yeUJhc2U6IDAsXG4gICAgICBtZW1vcnk6IHRoaXMuX19tZW1vcnksXG4gICAgICB0YWJsZUJhc2U6IDAsXG4gICAgICB0YWJsZTogbmV3IFdlYkFzc2VtYmx5LlRhYmxlKHsgaW5pdGlhbDogMCwgZWxlbWVudDogJ2FueWZ1bmMnIH0pXG4gICAgfTtcblxuICAgIHRoaXMuX19jYWNoZVtuYW1lXSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZSh0aGlzLl9fd2FzbVtuYW1lXSwge1xuICAgICAgZW52OiBhc3NpZ24oZW52X2Jhc2UsIGVudl9leHRyYSB8fCB7fSlcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9fY2FjaGVbbmFtZV07XG59O1xuXG5cbi8vIEhlbHBlciB0byBjYWxjdWxhdGUgbWVtb3J5IGFsaWdoIGZvciBwb2ludGVycy4gV2ViYXNzZW1ibHkgZG9lcyBub3QgcmVxdWlyZVxuLy8gdGhpcywgYnV0IHlvdSBtYXkgd2lzaCB0byBleHBlcmltZW50LiBEZWZhdWx0IGJhc2UgPSA4O1xuLy9cbk11bHRpTWF0aC5wcm90b3R5cGUuX19hbGlnbiA9IGZ1bmN0aW9uIGFsaWduKG51bWJlciwgYmFzZSkge1xuICBiYXNlID0gYmFzZSB8fCA4O1xuICB2YXIgcmVtaW5kZXIgPSBudW1iZXIgJSBiYXNlO1xuICByZXR1cm4gbnVtYmVyICsgKHJlbWluZGVyID8gYmFzZSAtIHJlbWluZGVyIDogMCk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTXVsdGlNYXRoO1xuXG59LHtcIi4vbGliL2Jhc2U2NGRlY29kZVwiOjIxLFwiLi9saWIvd2FfZGV0ZWN0XCI6MjIsXCJvYmplY3QtYXNzaWduXCI6MjN9XSwyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBiYXNlNjQgZGVjb2RlIHN0ciAtPiBVaW50OEFycmF5LCB0byBsb2FkIFdBIG1vZHVsZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIEJBU0U2NF9NQVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYXNlNjRkZWNvZGUoc3RyKSB7XG4gIHZhciBpbnB1dCA9IHN0ci5yZXBsYWNlKC9bXFxyXFxuPV0vZywgJycpLCAvLyByZW1vdmUgQ1IvTEYgJiBwYWRkaW5nIHRvIHNpbXBsaWZ5IHNjYW5cbiAgICAgIG1heCAgID0gaW5wdXQubGVuZ3RoO1xuXG4gIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSgobWF4ICogMykgPj4gMik7XG5cbiAgLy8gQ29sbGVjdCBieSA2KjQgYml0cyAoMyBieXRlcylcblxuICB2YXIgYml0cyA9IDA7XG4gIHZhciBwdHIgID0gMDtcblxuICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSA0ID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIG91dFtwdHIrK10gPSAoYml0cyA+PiAxNikgJiAweEZGO1xuICAgICAgb3V0W3B0cisrXSA9IChiaXRzID4+IDgpICYgMHhGRjtcbiAgICAgIG91dFtwdHIrK10gPSBiaXRzICYgMHhGRjtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgNikgfCBCQVNFNjRfTUFQLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdmFyIHRhaWxiaXRzID0gKG1heCAlIDQpICogNjtcblxuICBpZiAodGFpbGJpdHMgPT09IDApIHtcbiAgICBvdXRbcHRyKytdID0gKGJpdHMgPj4gMTYpICYgMHhGRjtcbiAgICBvdXRbcHRyKytdID0gKGJpdHMgPj4gOCkgJiAweEZGO1xuICAgIG91dFtwdHIrK10gPSBiaXRzICYgMHhGRjtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTgpIHtcbiAgICBvdXRbcHRyKytdID0gKGJpdHMgPj4gMTApICYgMHhGRjtcbiAgICBvdXRbcHRyKytdID0gKGJpdHMgPj4gMikgJiAweEZGO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxMikge1xuICAgIG91dFtwdHIrK10gPSAoYml0cyA+PiA0KSAmIDB4RkY7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxufSx7fV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gRGV0ZWN0IFdlYkFzc2VtYmx5IHN1cHBvcnQuXG4vLyAtIENoZWNrIGdsb2JhbCBXZWJBc3NlbWJseSBvYmplY3Rcbi8vIC0gVHJ5IHRvIGxvYWQgc2ltcGxlIG1vZHVsZSAoY2FuIGJlIGRpc2FibGVkIHZpYSBDU1ApXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB3YTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1dlYkFzc2VtYmx5KCkge1xuICAvLyB1c2UgY2FjaGUgaWYgY2FsbGVkIGJlZm9yZTtcbiAgaWYgKHR5cGVvZiB3YSAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB3YTtcblxuICB3YSA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2E7XG5cbiAgLy8gSWYgV2ViQXNzZW5ibHkgaXMgZGlzYWJsZWQsIGNvZGUgY2FuIHRocm93IG9uIGNvbXBpbGVcbiAgdHJ5IHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnJpb24vbWluLXdhc20tZmFpbC9ibG9iL21hc3Rlci9taW4td2FzbS1mYWlsLmluLmpzXG4gICAgLy8gQWRkaXRpb25hbCBjaGVjayB0aGF0IFdBIGludGVybmFscyBhcmUgY29ycmVjdFxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZywgbWF4LWxlbiAqL1xuICAgIHZhciBiaW4gICAgICA9IG5ldyBVaW50OEFycmF5KFsgMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw2LDEsOTYsMSwxMjcsMSwxMjcsMywyLDEsMCw1LDMsMSwwLDEsNyw4LDEsNCwxMTYsMTAxLDExNSwxMTYsMCwwLDEwLDE2LDEsMTQsMCwzMiwwLDY1LDEsNTQsMiwwLDMyLDAsNDAsMiwwLDExIF0pO1xuICAgIHZhciBtb2R1bGUgICA9IG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUoYmluKTtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobW9kdWxlLCB7fSk7XG5cbiAgICAvLyB0ZXN0IHN0b3JpbmcgdG8gYW5kIGxvYWRpbmcgZnJvbSBhIG5vbi16ZXJvIGxvY2F0aW9uIHZpYSBhIHBhcmFtZXRlci5cbiAgICAvLyBTYWZhcmkgb24gaU9TIDExLjIuNSByZXR1cm5zIDAgdW5leHBlY3RlZGx5IGF0IG5vbi16ZXJvIGxvY2F0aW9uc1xuICAgIGlmIChpbnN0YW5jZS5leHBvcnRzLnRlc3QoNCkgIT09IDApIHdhID0gdHJ1ZTtcblxuICAgIHJldHVybiB3YTtcbiAgfSBjYXRjaCAoX18pIHt9XG5cbiAgcmV0dXJuIHdhO1xufTtcblxufSx7fV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxufSx7fV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGJ1bmRsZUZuID0gYXJndW1lbnRzWzNdO1xudmFyIHNvdXJjZXMgPSBhcmd1bWVudHNbNF07XG52YXIgY2FjaGUgPSBhcmd1bWVudHNbNV07XG5cbnZhciBzdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICB2YXIgd2tleTtcbiAgICB2YXIgY2FjaGVLZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgIHZhciBleHAgPSBjYWNoZVtrZXldLmV4cG9ydHM7XG4gICAgICAgIC8vIFVzaW5nIGJhYmVsIGFzIGEgdHJhbnNwaWxlciB0byB1c2UgZXNtb2R1bGUsIHRoZSBleHBvcnQgd2lsbCBhbHdheXNcbiAgICAgICAgLy8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGRlZmF1bHQgZXhwb3J0IGFzIGEgcHJvcGVydHkgb2YgaXQuIFRvIGVuc3VyZVxuICAgICAgICAvLyB0aGUgZXhpc3RpbmcgYXBpIGFuZCBiYWJlbCBlc21vZHVsZSBleHBvcnRzIGFyZSBib3RoIHN1cHBvcnRlZCB3ZVxuICAgICAgICAvLyBjaGVjayBmb3IgYm90aFxuICAgICAgICBpZiAoZXhwID09PSBmbiB8fCBleHAgJiYgZXhwLmRlZmF1bHQgPT09IGZuKSB7XG4gICAgICAgICAgICB3a2V5ID0ga2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXdrZXkpIHtcbiAgICAgICAgd2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgd2NhY2hlID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGNhY2hlS2V5c1tpXTtcbiAgICAgICAgICAgIHdjYWNoZVtrZXldID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZXNbd2tleV0gPSBbXG4gICAgICAgICAgICAnZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7JyArIGZuICsgJyhzZWxmKTsgfScsXG4gICAgICAgICAgICB3Y2FjaGVcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHNrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcblxuICAgIHZhciBzY2FjaGUgPSB7fTsgc2NhY2hlW3drZXldID0gd2tleTtcbiAgICBzb3VyY2VzW3NrZXldID0gW1xuICAgICAgICAnZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7JyArXG4gICAgICAgICAgICAvLyB0cnkgdG8gY2FsbCBkZWZhdWx0IGlmIGRlZmluZWQgdG8gYWxzbyBzdXBwb3J0IGJhYmVsIGVzbW9kdWxlIGV4cG9ydHNcbiAgICAgICAgICAgICd2YXIgZiA9IHJlcXVpcmUoJyArIHN0cmluZ2lmeSh3a2V5KSArICcpOycgK1xuICAgICAgICAgICAgJyhmLmRlZmF1bHQgPyBmLmRlZmF1bHQgOiBmKShzZWxmKTsnICtcbiAgICAgICAgJ30nLFxuICAgICAgICBzY2FjaGVcbiAgICBdO1xuXG4gICAgdmFyIHdvcmtlclNvdXJjZXMgPSB7fTtcbiAgICByZXNvbHZlU291cmNlcyhza2V5KTtcblxuICAgIGZ1bmN0aW9uIHJlc29sdmVTb3VyY2VzKGtleSkge1xuICAgICAgICB3b3JrZXJTb3VyY2VzW2tleV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGRlcFBhdGggaW4gc291cmNlc1trZXldWzFdKSB7XG4gICAgICAgICAgICB2YXIgZGVwS2V5ID0gc291cmNlc1trZXldWzFdW2RlcFBhdGhdO1xuICAgICAgICAgICAgaWYgKCF3b3JrZXJTb3VyY2VzW2RlcEtleV0pIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlU291cmNlcyhkZXBLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNyYyA9ICcoJyArIGJ1bmRsZUZuICsgJykoeydcbiAgICAgICAgKyBPYmplY3Qua2V5cyh3b3JrZXJTb3VyY2VzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShrZXkpICsgJzpbJ1xuICAgICAgICAgICAgICAgICsgc291cmNlc1trZXldWzBdXG4gICAgICAgICAgICAgICAgKyAnLCcgKyBzdHJpbmdpZnkoc291cmNlc1trZXldWzFdKSArICddJ1xuICAgICAgICAgICAgO1xuICAgICAgICB9KS5qb2luKCcsJylcbiAgICAgICAgKyAnfSx7fSxbJyArIHN0cmluZ2lmeShza2V5KSArICddKSdcbiAgICA7XG5cbiAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xuXG4gICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmJhcmUpIHsgcmV0dXJuIGJsb2I7IH1cbiAgICB2YXIgd29ya2VyVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVcmwpO1xuICAgIHdvcmtlci5vYmplY3RVUkwgPSB3b3JrZXJVcmw7XG4gICAgcmV0dXJuIHdvcmtlcjtcbn07XG5cbn0se31dLFwiL2luZGV4LmpzXCI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbnZhciBhc3NpZ24gPSBfZGVyZXFfKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciB3ZWJ3b3JraWZ5ID0gX2RlcmVxXygnd2Vid29ya2lmeScpO1xuXG52YXIgTWF0aExpYiA9IF9kZXJlcV8oJy4vbGliL21hdGhsaWInKTtcblxudmFyIFBvb2wgPSBfZGVyZXFfKCcuL2xpYi9wb29sJyk7XG5cbnZhciB1dGlscyA9IF9kZXJlcV8oJy4vbGliL3V0aWxzJyk7XG5cbnZhciB3b3JrZXIgPSBfZGVyZXFfKCcuL2xpYi93b3JrZXInKTtcblxudmFyIGNyZWF0ZVN0YWdlcyA9IF9kZXJlcV8oJy4vbGliL3N0ZXBwZXInKTtcblxudmFyIGNyZWF0ZVJlZ2lvbnMgPSBfZGVyZXFfKCcuL2xpYi90aWxlcicpOyAvLyBEZWR1cGxpY2F0ZSBwb29scyAmIGxpbWl0ZXJzIHdpdGggdGhlIHNhbWUgY29uZmlnc1xuLy8gd2hlbiB1c2VyIGNyZWF0ZXMgbXVsdGlwbGUgcGljYSBpbnN0YW5jZXMuXG5cblxudmFyIHNpbmdsZXRvbmVzID0ge307XG52YXIgTkVFRF9TQUZBUklfRklYID0gZmFsc2U7XG5cbnRyeSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgTkVFRF9TQUZBUklfRklYID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdTYWZhcmknKSA+PSAwO1xuICB9XG59IGNhdGNoIChlKSB7fVxuXG52YXIgY29uY3VycmVuY3kgPSAxO1xuXG5pZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgY29uY3VycmVuY3kgPSBNYXRoLm1pbihuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSB8fCAxLCA0KTtcbn1cblxudmFyIERFRkFVTFRfUElDQV9PUFRTID0ge1xuICB0aWxlOiAxMDI0LFxuICBjb25jdXJyZW5jeTogY29uY3VycmVuY3ksXG4gIGZlYXR1cmVzOiBbJ2pzJywgJ3dhc20nLCAnd3cnXSxcbiAgaWRsZTogMjAwMCxcbiAgY3JlYXRlQ2FudmFzOiBmdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0bXBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICB0bXBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiB0bXBDYW52YXM7XG4gIH1cbn07XG52YXIgREVGQVVMVF9SRVNJWkVfT1BUUyA9IHtcbiAgcXVhbGl0eTogMyxcbiAgYWxwaGE6IGZhbHNlLFxuICB1bnNoYXJwQW1vdW50OiAwLFxuICB1bnNoYXJwUmFkaXVzOiAwLjAsXG4gIHVuc2hhcnBUaHJlc2hvbGQ6IDBcbn07XG52YXIgQ0FOX05FV19JTUFHRV9EQVRBID0gZmFsc2U7XG52YXIgQ0FOX0NSRUFURV9JTUFHRV9CSVRNQVAgPSBmYWxzZTtcbnZhciBDQU5fVVNFX0NBTlZBU19HRVRfSU1BR0VfREFUQSA9IGZhbHNlO1xudmFyIENBTl9VU0VfT0ZGU0NSRUVOX0NBTlZBUyA9IGZhbHNlO1xudmFyIENBTl9VU0VfQ0lCX1JFR0lPTl9GT1JfSU1BR0UgPSBmYWxzZTtcblxuZnVuY3Rpb24gd29ya2VyRmFicmljKCkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB3ZWJ3b3JraWZ5KHdvcmtlciksXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMudmFsdWUudGVybWluYXRlKCk7XG5cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgdXJsID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xuXG4gICAgICAgIGlmICh1cmwgJiYgdXJsLnJldm9rZU9iamVjdFVSTCAmJiB0aGlzLnZhbHVlLm9iamVjdFVSTCkge1xuICAgICAgICAgIHVybC5yZXZva2VPYmplY3RVUkwodGhpcy52YWx1ZS5vYmplY3RVUkwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQVBJIG1ldGhvZHNcblxuXG5mdW5jdGlvbiBQaWNhKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBpY2EpKSByZXR1cm4gbmV3IFBpY2Eob3B0aW9ucyk7XG4gIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgREVGQVVMVF9QSUNBX09QVFMsIG9wdGlvbnMgfHwge30pO1xuICB2YXIgbGltaXRlcl9rZXkgPSBcImxrX1wiLmNvbmNhdCh0aGlzLm9wdGlvbnMuY29uY3VycmVuY3kpOyAvLyBTaGFyZSBsaW1pdGVycyB0byBhdm9pZCBtdWx0aXBsZSBwYXJhbGxlbCB3b3JrZXJzIHdoZW4gdXNlciBjcmVhdGVzXG4gIC8vIG11bHRpcGxlIHBpY2EgaW5zdGFuY2VzLlxuXG4gIHRoaXMuX19saW1pdCA9IHNpbmdsZXRvbmVzW2xpbWl0ZXJfa2V5XSB8fCB1dGlscy5saW1pdGVyKHRoaXMub3B0aW9ucy5jb25jdXJyZW5jeSk7XG4gIGlmICghc2luZ2xldG9uZXNbbGltaXRlcl9rZXldKSBzaW5nbGV0b25lc1tsaW1pdGVyX2tleV0gPSB0aGlzLl9fbGltaXQ7IC8vIExpc3Qgb2Ygc3VwcG9ydGVkIGZlYXR1cmVzLCBhY2NvcmRpbmcgdG8gb3B0aW9ucyAmIGJyb3dzZXIvbm9kZS5qc1xuXG4gIHRoaXMuZmVhdHVyZXMgPSB7XG4gICAganM6IGZhbHNlLFxuICAgIC8vIHB1cmUgSlMgaW1wbGVtZW50YXRpb24sIGNhbiBiZSBkaXNhYmxlZCBmb3IgdGVzdGluZ1xuICAgIHdhc206IGZhbHNlLFxuICAgIC8vIHdlYmFzc2VtYmx5IGltcGxlbWVudGF0aW9uIGZvciBoZWF2eSBmdW5jdGlvbnNcbiAgICBjaWI6IGZhbHNlLFxuICAgIC8vIHJlc2l6ZSB2aWEgY3JlYXRlSW1hZ2VCaXRtYXAgKG9ubHkgRkYgYXQgdGhpcyBtb21lbnQpXG4gICAgd3c6IGZhbHNlIC8vIHdlYndvcmtlcnNcblxuICB9O1xuICB0aGlzLl9fd29ya2Vyc1Bvb2wgPSBudWxsOyAvLyBTdG9yZSByZXF1ZXN0ZWQgZmVhdHVyZXMgZm9yIHdlYndvcmtlcnNcblxuICB0aGlzLl9fcmVxdWVzdGVkX2ZlYXR1cmVzID0gW107XG4gIHRoaXMuX19tYXRobGliID0gbnVsbDtcbn1cblxuUGljYS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodGhpcy5fX2luaXRQcm9taXNlKSByZXR1cm4gdGhpcy5fX2luaXRQcm9taXNlOyAvLyBUZXN0IGlmIHdlIGNhbiBjcmVhdGUgSW1hZ2VEYXRhIHdpdGhvdXQgY2FudmFzIGFuZCBtZW1vcnkgY29weVxuXG4gIGlmICh0eXBlb2YgSW1hZ2VEYXRhICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuICAgICAgbmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkoNDAwKSwgMTAsIDEwKTtcbiAgICAgIENBTl9ORVdfSU1BR0VfREFUQSA9IHRydWU7XG4gICAgfSBjYXRjaCAoX18pIHt9XG4gIH0gLy8gSW1hZ2VCaXRtYXAgY2FuIGJlIGVmZmVjdGl2ZSBpbiAyIHBsYWNlczpcbiAgLy9cbiAgLy8gMS4gVGhyZWFkZWQganBlZyB1bnBhY2sgKGJhc2ljKVxuICAvLyAyLiBCdWlsdC1pbiByZXNpemUgKGJsb2NrZWQgZHVlIHByb2JsZW0gaW4gY2hyb21lLCBzZWUgaXNzdWUgIzg5KVxuICAvL1xuICAvLyBGb3IgYmFzaWMgdXNlIHdlIGFsc28gbmVlZCBJbWFnZUJpdG1hcCB3byBzdXBwb3J0IC5jbG9zZSgpIG1ldGhvZCxcbiAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0FQSS9JbWFnZUJpdG1hcFxuXG5cbiAgaWYgKHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoSW1hZ2VCaXRtYXAucHJvdG90eXBlICYmIEltYWdlQml0bWFwLnByb3RvdHlwZS5jbG9zZSkge1xuICAgICAgQ0FOX0NSRUFURV9JTUFHRV9CSVRNQVAgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYnVnKCdJbWFnZUJpdG1hcCBkb2VzIG5vdCBzdXBwb3J0IC5jbG9zZSgpLCBkaXNhYmxlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmZWF0dXJlcyA9IHRoaXMub3B0aW9ucy5mZWF0dXJlcy5zbGljZSgpO1xuXG4gIGlmIChmZWF0dXJlcy5pbmRleE9mKCdhbGwnKSA+PSAwKSB7XG4gICAgZmVhdHVyZXMgPSBbJ2NpYicsICd3YXNtJywgJ2pzJywgJ3d3J107XG4gIH1cblxuICB0aGlzLl9fcmVxdWVzdGVkX2ZlYXR1cmVzID0gZmVhdHVyZXM7XG4gIHRoaXMuX19tYXRobGliID0gbmV3IE1hdGhMaWIoZmVhdHVyZXMpOyAvLyBDaGVjayBXZWJXb3JrZXIgc3VwcG9ydCBpZiByZXF1ZXN0ZWRcblxuICBpZiAoZmVhdHVyZXMuaW5kZXhPZignd3cnKSA+PSAwKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdXb3JrZXInIGluIHdpbmRvdykge1xuICAgICAgLy8gSUUgPD0gMTEgZG9uJ3QgYWxsb3cgdG8gY3JlYXRlIHdlYndvcmtlcnMgZnJvbSBzdHJpbmcuIFdlIHNob3VsZCBjaGVjayBpdC5cbiAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvODAxODEwL3dlYi13b3JrZXJzLWZyb20tYmxvYi11cmxzLWluLWllLTEwLWFuZC0xMVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHdrciA9IF9kZXJlcV8oJ3dlYndvcmtpZnknKShmdW5jdGlvbiAoKSB7fSk7XG5cbiAgICAgICAgd2tyLnRlcm1pbmF0ZSgpO1xuICAgICAgICB0aGlzLmZlYXR1cmVzLnd3ID0gdHJ1ZTsgLy8gcG9vbCB1bmlxdWVuZXNzIGRlcGVuZHMgb24gcG9vbCBjb25maWcgKyB3ZWJ3b3JrZXIgY29uZmlnXG5cbiAgICAgICAgdmFyIHdwb29sX2tleSA9IFwid3BfXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucykpO1xuXG4gICAgICAgIGlmIChzaW5nbGV0b25lc1t3cG9vbF9rZXldKSB7XG4gICAgICAgICAgdGhpcy5fX3dvcmtlcnNQb29sID0gc2luZ2xldG9uZXNbd3Bvb2xfa2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fd29ya2Vyc1Bvb2wgPSBuZXcgUG9vbCh3b3JrZXJGYWJyaWMsIHRoaXMub3B0aW9ucy5pZGxlKTtcbiAgICAgICAgICBzaW5nbGV0b25lc1t3cG9vbF9rZXldID0gdGhpcy5fX3dvcmtlcnNQb29sO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfXykge31cbiAgICB9XG4gIH1cblxuICB2YXIgaW5pdE1hdGggPSB0aGlzLl9fbWF0aGxpYi5pbml0KCkudGhlbihmdW5jdGlvbiAobWF0aGxpYikge1xuICAgIC8vIENvcHkgZGV0ZWN0ZWQgZmVhdHVyZXNcbiAgICBhc3NpZ24oX3RoaXMuZmVhdHVyZXMsIG1hdGhsaWIuZmVhdHVyZXMpO1xuICB9KTtcblxuICB2YXIgY2hlY2tDaWJSZXNpemU7XG5cbiAgaWYgKCFDQU5fQ1JFQVRFX0lNQUdFX0JJVE1BUCkge1xuICAgIGNoZWNrQ2liUmVzaXplID0gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBjaGVja0NpYlJlc2l6ZSA9IHV0aWxzLmNpYl9zdXBwb3J0KHRoaXMub3B0aW9ucy5jcmVhdGVDYW52YXMpLnRoZW4oZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgaWYgKF90aGlzLmZlYXR1cmVzLmNpYiAmJiBmZWF0dXJlcy5pbmRleE9mKCdjaWInKSA8IDApIHtcbiAgICAgICAgX3RoaXMuZGVidWcoJ2NyZWF0ZUltYWdlQml0bWFwKCkgcmVzaXplIHN1cHBvcnRlZCwgYnV0IGRpc2FibGVkIGJ5IGNvbmZpZycpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGZlYXR1cmVzLmluZGV4T2YoJ2NpYicpID49IDApIF90aGlzLmZlYXR1cmVzLmNpYiA9IHN0YXR1cztcbiAgICB9KTtcbiAgfVxuXG4gIENBTl9VU0VfQ0FOVkFTX0dFVF9JTUFHRV9EQVRBID0gdXRpbHMuY2FuX3VzZV9jYW52YXModGhpcy5vcHRpb25zLmNyZWF0ZUNhbnZhcyk7XG4gIHZhciBjaGVja09mZnNjcmVlbkNhbnZhcztcblxuICBpZiAoQ0FOX0NSRUFURV9JTUFHRV9CSVRNQVAgJiYgQ0FOX05FV19JTUFHRV9EQVRBICYmIGZlYXR1cmVzLmluZGV4T2YoJ3d3JykgIT09IC0xKSB7XG4gICAgY2hlY2tPZmZzY3JlZW5DYW52YXMgPSB1dGlscy53b3JrZXJfb2Zmc2NyZWVuX2NhbnZhc19zdXBwb3J0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tPZmZzY3JlZW5DYW52YXMgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICB9XG5cbiAgY2hlY2tPZmZzY3JlZW5DYW52YXMgPSBjaGVja09mZnNjcmVlbkNhbnZhcy50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBDQU5fVVNFX09GRlNDUkVFTl9DQU5WQVMgPSByZXN1bHQ7XG4gIH0pOyAvLyB3ZSB1c2UgY3JlYXRlSW1hZ2VCaXRtYXAgdG8gY3JvcCBpbWFnZSBkYXRhIGFuZCBwYXNzIGl0IHRvIHdvcmtlcnMsXG4gIC8vIHNvIG5lZWQgdG8gY2hlY2sgd2hldGhlciBmdW5jdGlvbiB3b3JrcyBjb3JyZWN0bHk7XG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyMjA2NzFcblxuICB2YXIgY2hlY2tDaWJSZWdpb24gPSB1dGlscy5jaWJfY2FuX3VzZV9yZWdpb24oKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBDQU5fVVNFX0NJQl9SRUdJT05fRk9SX0lNQUdFID0gcmVzdWx0O1xuICB9KTsgLy8gSW5pdCBtYXRoIGxpYi4gVGhhdCdzIGFzeW5jIGJlY2F1c2UgY2FuIGxvYWQgc29tZVxuXG4gIHRoaXMuX19pbml0UHJvbWlzZSA9IFByb21pc2UuYWxsKFtpbml0TWF0aCwgY2hlY2tDaWJSZXNpemUsIGNoZWNrT2Zmc2NyZWVuQ2FudmFzLCBjaGVja0NpYlJlZ2lvbl0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpcztcbiAgfSk7XG4gIHJldHVybiB0aGlzLl9faW5pdFByb21pc2U7XG59OyAvLyBDYWxsIHJlc2l6ZXIgaW4gd2Vid29ya2VyIG9yIGxvY2FsbHksIGRlcGVuZGluZyBvbiBjb25maWdcblxuXG5QaWNhLnByb3RvdHlwZS5fX2ludm9rZVJlc2l6ZSA9IGZ1bmN0aW9uICh0aWxlT3B0cywgb3B0cykge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAvLyBTaGFyZSBjYWNoZSBiZXR3ZWVuIGNhbGxzOlxuICAvL1xuICAvLyAtIHdhc20gaW5zdGFuY2VcbiAgLy8gLSB3YXNtIG1lbW9yeSBvYmplY3RcbiAgLy9cbiAgb3B0cy5fX21hdGhDYWNoZSA9IG9wdHMuX19tYXRoQ2FjaGUgfHwge307XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV90aGlzMi5mZWF0dXJlcy53dykge1xuICAgICAgLy8gbm90IHBvc3NpYmxlIHRvIGhhdmUgSW1hZ2VCaXRtYXAgaGVyZSBpZiB1c2VyIGRpc2FibGVkIFdXXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBfdGhpczIuX19tYXRobGliLnJlc2l6ZUFuZFVuc2hhcnAodGlsZU9wdHMsIG9wdHMuX19tYXRoQ2FjaGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgdyA9IF90aGlzMi5fX3dvcmtlcnNQb29sLmFjcXVpcmUoKTtcblxuICAgICAgaWYgKG9wdHMuY2FuY2VsVG9rZW4pIG9wdHMuY2FuY2VsVG9rZW5bXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuXG4gICAgICB3LnZhbHVlLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB3LnJlbGVhc2UoKTtcbiAgICAgICAgaWYgKGV2LmRhdGEuZXJyKSByZWplY3QoZXYuZGF0YS5lcnIpO2Vsc2UgcmVzb2x2ZShldi5kYXRhKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciB0cmFuc2ZlciA9IFtdO1xuICAgICAgaWYgKHRpbGVPcHRzLnNyYykgdHJhbnNmZXIucHVzaCh0aWxlT3B0cy5zcmMuYnVmZmVyKTtcbiAgICAgIGlmICh0aWxlT3B0cy5zcmNCaXRtYXApIHRyYW5zZmVyLnB1c2godGlsZU9wdHMuc3JjQml0bWFwKTtcbiAgICAgIHcudmFsdWUucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBvcHRzOiB0aWxlT3B0cyxcbiAgICAgICAgZmVhdHVyZXM6IF90aGlzMi5fX3JlcXVlc3RlZF9mZWF0dXJlcyxcbiAgICAgICAgcHJlbG9hZDoge1xuICAgICAgICAgIHdhc21fbm9kdWxlOiBfdGhpczIuX19tYXRobGliLl9fXG4gICAgICAgIH1cbiAgICAgIH0sIHRyYW5zZmVyKTtcbiAgICB9KTtcbiAgfSk7XG59OyAvLyB0aGlzIGZ1bmN0aW9uIGNhbiByZXR1cm4gcHJvbWlzZSBpZiBjcmVhdGVJbWFnZUJpdG1hcCBpcyB1c2VkXG5cblxuUGljYS5wcm90b3R5cGUuX19leHRyYWN0VGlsZURhdGEgPSBmdW5jdGlvbiAodGlsZSwgZnJvbSwgb3B0cywgc3RhZ2VFbnYsIGV4dHJhY3RUbykge1xuICBpZiAodGhpcy5mZWF0dXJlcy53dyAmJiBDQU5fVVNFX09GRlNDUkVFTl9DQU5WQVMgJiYgKCAvLyBjcmVhdGVJbWFnZUJpdG1hcCBkb2Vzbid0IHdvcmsgZm9yIGltYWdlcyAoSW1hZ2UsIEltYWdlQml0bWFwKSB3aXRoIEV4aWYgb3JpZW50YXRpb24gaW4gQ2hyb21lLFxuICAvLyBjYW4gdXNlIGNhbnZhcyBiZWNhdXNlIGNhbnZhcyBkb2Vzbid0IGhhdmUgb3JpZW50YXRpb247XG4gIC8vIHNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjIwNjcxXG4gIHV0aWxzLmlzQ2FudmFzKGZyb20pIHx8IENBTl9VU0VfQ0lCX1JFR0lPTl9GT1JfSU1BR0UpKSB7XG4gICAgdGhpcy5kZWJ1ZygnQ3JlYXRlIHRpbGUgZm9yIE9mZnNjcmVlbkNhbnZhcycpO1xuICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChzdGFnZUVudi5zcmNJbWFnZUJpdG1hcCB8fCBmcm9tLCB0aWxlLngsIHRpbGUueSwgdGlsZS53aWR0aCwgdGlsZS5oZWlnaHQpLnRoZW4oZnVuY3Rpb24gKGJpdG1hcCkge1xuICAgICAgZXh0cmFjdFRvLnNyY0JpdG1hcCA9IGJpdG1hcDtcbiAgICAgIHJldHVybiBleHRyYWN0VG87XG4gICAgfSk7XG4gIH0gLy8gRXh0cmFjdCB0aWxlIFJHQkEgYnVmZmVyLCBkZXBlbmRpbmcgb24gaW5wdXQgdHlwZVxuXG5cbiAgaWYgKHV0aWxzLmlzQ2FudmFzKGZyb20pKSB7XG4gICAgaWYgKCFzdGFnZUVudi5zcmNDdHgpIHN0YWdlRW52LnNyY0N0eCA9IGZyb20uZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgICBhbHBoYTogQm9vbGVhbihvcHRzLmFscGhhKVxuICAgIH0pOyAvLyBJZiBpbnB1dCBpcyBDYW52YXMgLSBleHRyYWN0IHJlZ2lvbiBkYXRhIGRpcmVjdGx5XG5cbiAgICB0aGlzLmRlYnVnKCdHZXQgdGlsZSBwaXhlbCBkYXRhJyk7XG4gICAgZXh0cmFjdFRvLnNyYyA9IHN0YWdlRW52LnNyY0N0eC5nZXRJbWFnZURhdGEodGlsZS54LCB0aWxlLnksIHRpbGUud2lkdGgsIHRpbGUuaGVpZ2h0KS5kYXRhO1xuICAgIHJldHVybiBleHRyYWN0VG87XG4gIH0gLy8gSWYgaW5wdXQgaXMgSW1hZ2Ugb3IgZGVjb2RlZCB0byBJbWFnZUJpdG1hcCxcbiAgLy8gZHJhdyByZWdpb24gdG8gdGVtcG9yYXJ5IGNhbnZhcyBhbmQgZXh0cmFjdCBkYXRhIGZyb20gaXRcbiAgLy9cbiAgLy8gTm90ZSEgQXR0ZW1wdCB0byByZXVzZSB0aGlzIGNhbnZhcyBjYXVzZXMgc2lnbmlmaWNhbnQgc2xvd2Rvd24gaW4gY2hyb21lXG4gIC8vXG5cblxuICB0aGlzLmRlYnVnKCdEcmF3IHRpbGUgaW1hZ2VCaXRtYXAvaW1hZ2UgdG8gdGVtcG9yYXJ5IGNhbnZhcycpO1xuICB2YXIgdG1wQ2FudmFzID0gdGhpcy5vcHRpb25zLmNyZWF0ZUNhbnZhcyh0aWxlLndpZHRoLCB0aWxlLmhlaWdodCk7XG4gIHZhciB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgYWxwaGE6IEJvb2xlYW4ob3B0cy5hbHBoYSlcbiAgfSk7XG4gIHRtcEN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gIHRtcEN0eC5kcmF3SW1hZ2Uoc3RhZ2VFbnYuc3JjSW1hZ2VCaXRtYXAgfHwgZnJvbSwgdGlsZS54LCB0aWxlLnksIHRpbGUud2lkdGgsIHRpbGUuaGVpZ2h0LCAwLCAwLCB0aWxlLndpZHRoLCB0aWxlLmhlaWdodCk7XG4gIHRoaXMuZGVidWcoJ0dldCB0aWxlIHBpeGVsIGRhdGEnKTtcbiAgZXh0cmFjdFRvLnNyYyA9IHRtcEN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGlsZS53aWR0aCwgdGlsZS5oZWlnaHQpLmRhdGE7IC8vIFNhZmFyaSAxMiB3b3JrYXJvdW5kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYS9pc3N1ZXMvMTk5XG5cbiAgdG1wQ2FudmFzLndpZHRoID0gdG1wQ2FudmFzLmhlaWdodCA9IDA7XG4gIHJldHVybiBleHRyYWN0VG87XG59O1xuXG5QaWNhLnByb3RvdHlwZS5fX2xhbmRUaWxlRGF0YSA9IGZ1bmN0aW9uICh0aWxlLCByZXN1bHQsIHN0YWdlRW52KSB7XG4gIHZhciB0b0ltYWdlRGF0YTtcbiAgdGhpcy5kZWJ1ZygnQ29udmVydCByYXcgcmdiYSB0aWxlIHJlc3VsdCB0byBJbWFnZURhdGEnKTtcblxuICBpZiAocmVzdWx0LmJpdG1hcCkge1xuICAgIHN0YWdlRW52LnRvQ3R4LmRyYXdJbWFnZShyZXN1bHQuYml0bWFwLCB0aWxlLnRvWCwgdGlsZS50b1kpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKENBTl9ORVdfSU1BR0VfREFUQSkge1xuICAgIC8vIHRoaXMgYnJhbmNoIGlzIGZvciBtb2Rlcm4gYnJvd3NlcnNcbiAgICAvLyBJZiBgbmV3IEltYWdlRGF0YSgpYCAmIFVpbnQ4Q2xhbXBlZEFycmF5IHN1cG9ydGVkXG4gICAgdG9JbWFnZURhdGEgPSBuZXcgSW1hZ2VEYXRhKG5ldyBVaW50OENsYW1wZWRBcnJheShyZXN1bHQuZGF0YSksIHRpbGUudG9XaWR0aCwgdGlsZS50b0hlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2sgZm9yIGBub2RlLWNhbnZhc2AgYW5kIG9sZCBicm93c2Vyc1xuICAgIC8vIChJRTExIGhhcyBJbWFnZURhdGEgYnV0IGRvZXMgbm90IHN1cHBvcnQgYG5ldyBJbWFnZURhdGEoKWApXG4gICAgdG9JbWFnZURhdGEgPSBzdGFnZUVudi50b0N0eC5jcmVhdGVJbWFnZURhdGEodGlsZS50b1dpZHRoLCB0aWxlLnRvSGVpZ2h0KTtcblxuICAgIGlmICh0b0ltYWdlRGF0YS5kYXRhLnNldCkge1xuICAgICAgdG9JbWFnZURhdGEuZGF0YS5zZXQocmVzdWx0LmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRTkgZG9uJ3QgaGF2ZSBgLnNldCgpYFxuICAgICAgZm9yICh2YXIgaSA9IHRvSW1hZ2VEYXRhLmRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdG9JbWFnZURhdGEuZGF0YVtpXSA9IHJlc3VsdC5kYXRhW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuZGVidWcoJ0RyYXcgdGlsZScpO1xuXG4gIGlmIChORUVEX1NBRkFSSV9GSVgpIHtcbiAgICAvLyBTYWZhcmkgZHJhd3MgdGhpbiB3aGl0ZSBzdHJpcGVzIGJldHdlZW4gdGlsZXMgd2l0aG91dCB0aGlzIGZpeFxuICAgIHN0YWdlRW52LnRvQ3R4LnB1dEltYWdlRGF0YSh0b0ltYWdlRGF0YSwgdGlsZS50b1gsIHRpbGUudG9ZLCB0aWxlLnRvSW5uZXJYIC0gdGlsZS50b1gsIHRpbGUudG9Jbm5lclkgLSB0aWxlLnRvWSwgdGlsZS50b0lubmVyV2lkdGggKyAxZS01LCB0aWxlLnRvSW5uZXJIZWlnaHQgKyAxZS01KTtcbiAgfSBlbHNlIHtcbiAgICBzdGFnZUVudi50b0N0eC5wdXRJbWFnZURhdGEodG9JbWFnZURhdGEsIHRpbGUudG9YLCB0aWxlLnRvWSwgdGlsZS50b0lubmVyWCAtIHRpbGUudG9YLCB0aWxlLnRvSW5uZXJZIC0gdGlsZS50b1ksIHRpbGUudG9Jbm5lcldpZHRoLCB0aWxlLnRvSW5uZXJIZWlnaHQpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5QaWNhLnByb3RvdHlwZS5fX3RpbGVBbmRSZXNpemUgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIG9wdHMpIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgdmFyIHN0YWdlRW52ID0ge1xuICAgIHNyY0N0eDogbnVsbCxcbiAgICBzcmNJbWFnZUJpdG1hcDogbnVsbCxcbiAgICBpc0ltYWdlQml0bWFwUmV1c2VkOiBmYWxzZSxcbiAgICB0b0N0eDogbnVsbFxuICB9O1xuXG4gIHZhciBwcm9jZXNzVGlsZSA9IGZ1bmN0aW9uIHByb2Nlc3NUaWxlKHRpbGUpIHtcbiAgICByZXR1cm4gX3RoaXMzLl9fbGltaXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9wdHMuY2FuY2VsZWQpIHJldHVybiBvcHRzLmNhbmNlbFRva2VuO1xuICAgICAgdmFyIHRpbGVPcHRzID0ge1xuICAgICAgICB3aWR0aDogdGlsZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aWxlLmhlaWdodCxcbiAgICAgICAgdG9XaWR0aDogdGlsZS50b1dpZHRoLFxuICAgICAgICB0b0hlaWdodDogdGlsZS50b0hlaWdodCxcbiAgICAgICAgc2NhbGVYOiB0aWxlLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0aWxlLnNjYWxlWSxcbiAgICAgICAgb2Zmc2V0WDogdGlsZS5vZmZzZXRYLFxuICAgICAgICBvZmZzZXRZOiB0aWxlLm9mZnNldFksXG4gICAgICAgIHF1YWxpdHk6IG9wdHMucXVhbGl0eSxcbiAgICAgICAgYWxwaGE6IG9wdHMuYWxwaGEsXG4gICAgICAgIHVuc2hhcnBBbW91bnQ6IG9wdHMudW5zaGFycEFtb3VudCxcbiAgICAgICAgdW5zaGFycFJhZGl1czogb3B0cy51bnNoYXJwUmFkaXVzLFxuICAgICAgICB1bnNoYXJwVGhyZXNob2xkOiBvcHRzLnVuc2hhcnBUaHJlc2hvbGRcbiAgICAgIH07XG5cbiAgICAgIF90aGlzMy5kZWJ1ZygnSW52b2tlIHJlc2l6ZSBtYXRoJyk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGlsZU9wdHMpLnRoZW4oZnVuY3Rpb24gKHRpbGVPcHRzKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuX19leHRyYWN0VGlsZURhdGEodGlsZSwgZnJvbSwgb3B0cywgc3RhZ2VFbnYsIHRpbGVPcHRzKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHRpbGVPcHRzKSB7XG4gICAgICAgIF90aGlzMy5kZWJ1ZygnSW52b2tlIHJlc2l6ZSBtYXRoJyk7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzMy5fX2ludm9rZVJlc2l6ZSh0aWxlT3B0cywgb3B0cyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKG9wdHMuY2FuY2VsZWQpIHJldHVybiBvcHRzLmNhbmNlbFRva2VuO1xuICAgICAgICBzdGFnZUVudi5zcmNJbWFnZURhdGEgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXMzLl9fbGFuZFRpbGVEYXRhKHRpbGUsIHJlc3VsdCwgc3RhZ2VFbnYpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07IC8vIE5lZWQgdG8gbm9ybWFsaXplIGRhdGEgc291cmNlIGZpcnN0LiBJdCBjYW4gYmUgY2FudmFzIG9yIGltYWdlLlxuICAvLyBJZiBpbWFnZSAtIHRyeSB0byBkZWNvZGUgaW4gYmFja2dyb3VuZCBpZiBwb3NzaWJsZVxuXG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHN0YWdlRW52LnRvQ3R4ID0gdG8uZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgICBhbHBoYTogQm9vbGVhbihvcHRzLmFscGhhKVxuICAgIH0pO1xuICAgIGlmICh1dGlscy5pc0NhbnZhcyhmcm9tKSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAodXRpbHMuaXNJbWFnZUJpdG1hcChmcm9tKSkge1xuICAgICAgc3RhZ2VFbnYuc3JjSW1hZ2VCaXRtYXAgPSBmcm9tO1xuICAgICAgc3RhZ2VFbnYuaXNJbWFnZUJpdG1hcFJldXNlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNJbWFnZShmcm9tKSkge1xuICAgICAgLy8gdHJ5IGRvIGRlY29kZSBpbWFnZSBpbiBiYWNrZ3JvdW5kIGZvciBmYXN0ZXIgbmV4dCBvcGVyYXRpb25zO1xuICAgICAgLy8gaWYgd2UncmUgdXNpbmcgb2Zmc2NyZWVuIGNhbnZhcywgY2liIGlzIGNhbGxlZCBwZXIgdGlsZSwgc28gbm90IG5lZWRlZCBoZXJlXG4gICAgICBpZiAoIUNBTl9DUkVBVEVfSU1BR0VfQklUTUFQKSByZXR1cm4gbnVsbDtcblxuICAgICAgX3RoaXMzLmRlYnVnKCdEZWNvZGUgaW1hZ2UgdmlhIGNyZWF0ZUltYWdlQml0bWFwJyk7XG5cbiAgICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChmcm9tKS50aGVuKGZ1bmN0aW9uIChpbWFnZUJpdG1hcCkge1xuICAgICAgICBzdGFnZUVudi5zcmNJbWFnZUJpdG1hcCA9IGltYWdlQml0bWFwO1xuICAgICAgfSkgLy8gU3VwcHJlc3MgZXJyb3IgdG8gdXNlIGZhbGxiYWNrLCBpZiBtZXRob2QgZmFpbHNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYS9pc3N1ZXMvMTkwXG5cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICBbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignUGljYTogXCIuZnJvbVwiIHNob3VsZCBiZSBJbWFnZSwgQ2FudmFzIG9yIEltYWdlQml0bWFwJyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcHRzLmNhbmNlbGVkKSByZXR1cm4gb3B0cy5jYW5jZWxUb2tlbjtcblxuICAgIF90aGlzMy5kZWJ1ZygnQ2FsY3VsYXRlIHRpbGVzJyk7IC8vXG4gICAgLy8gSGVyZSB3ZSBhcmUgd2l0aCBcIm5vcm1hbGl6ZWRcIiBzb3VyY2UsXG4gICAgLy8gZm9sbG93IHRvIHRpbGluZ1xuICAgIC8vXG5cblxuICAgIHZhciByZWdpb25zID0gY3JlYXRlUmVnaW9ucyh7XG4gICAgICB3aWR0aDogb3B0cy53aWR0aCxcbiAgICAgIGhlaWdodDogb3B0cy5oZWlnaHQsXG4gICAgICBzcmNUaWxlU2l6ZTogX3RoaXMzLm9wdGlvbnMudGlsZSxcbiAgICAgIHRvV2lkdGg6IG9wdHMudG9XaWR0aCxcbiAgICAgIHRvSGVpZ2h0OiBvcHRzLnRvSGVpZ2h0LFxuICAgICAgZGVzdFRpbGVCb3JkZXI6IG9wdHMuX19kZXN0VGlsZUJvcmRlclxuICAgIH0pO1xuICAgIHZhciBqb2JzID0gcmVnaW9ucy5tYXAoZnVuY3Rpb24gKHRpbGUpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzVGlsZSh0aWxlKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNsZWFudXAoc3RhZ2VFbnYpIHtcbiAgICAgIGlmIChzdGFnZUVudi5zcmNJbWFnZUJpdG1hcCkge1xuICAgICAgICBpZiAoIXN0YWdlRW52LmlzSW1hZ2VCaXRtYXBSZXVzZWQpIHN0YWdlRW52LnNyY0ltYWdlQml0bWFwLmNsb3NlKCk7XG4gICAgICAgIHN0YWdlRW52LnNyY0ltYWdlQml0bWFwID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpczMuZGVidWcoJ1Byb2Nlc3MgdGlsZXMnKTtcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChqb2JzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMy5kZWJ1ZygnRmluaXNoZWQhJyk7XG5cbiAgICAgIGNsZWFudXAoc3RhZ2VFbnYpO1xuICAgICAgcmV0dXJuIHRvO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGNsZWFudXAoc3RhZ2VFbnYpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblBpY2EucHJvdG90eXBlLl9fcHJvY2Vzc1N0YWdlcyA9IGZ1bmN0aW9uIChzdGFnZXMsIGZyb20sIHRvLCBvcHRzKSB7XG4gIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gIGlmIChvcHRzLmNhbmNlbGVkKSByZXR1cm4gb3B0cy5jYW5jZWxUb2tlbjtcblxuICB2YXIgX3N0YWdlcyRzaGlmdCA9IHN0YWdlcy5zaGlmdCgpLFxuICAgICAgX3N0YWdlcyRzaGlmdDIgPSBfc2xpY2VkVG9BcnJheShfc3RhZ2VzJHNoaWZ0LCAyKSxcbiAgICAgIHRvV2lkdGggPSBfc3RhZ2VzJHNoaWZ0MlswXSxcbiAgICAgIHRvSGVpZ2h0ID0gX3N0YWdlcyRzaGlmdDJbMV07XG5cbiAgdmFyIGlzTGFzdFN0YWdlID0gc3RhZ2VzLmxlbmd0aCA9PT0gMDtcbiAgb3B0cyA9IGFzc2lnbih7fSwgb3B0cywge1xuICAgIHRvV2lkdGg6IHRvV2lkdGgsXG4gICAgdG9IZWlnaHQ6IHRvSGVpZ2h0LFxuICAgIC8vIG9ubHkgdXNlIHVzZXItZGVmaW5lZCBxdWFsaXR5IGZvciB0aGUgbGFzdCBzdGFnZSxcbiAgICAvLyB1c2Ugc2ltcGxlciAoSGFtbWluZykgZmlsdGVyIGZvciB0aGUgZmlyc3Qgc3RhZ2VzIHdoZXJlXG4gICAgLy8gc2NhbGUgZmFjdG9yIGlzIGxhcmdlIGVub3VnaCAobW9yZSB0aGFuIDItMylcbiAgICBxdWFsaXR5OiBpc0xhc3RTdGFnZSA/IG9wdHMucXVhbGl0eSA6IE1hdGgubWluKDEsIG9wdHMucXVhbGl0eSlcbiAgfSk7XG4gIHZhciB0bXBDYW52YXM7XG5cbiAgaWYgKCFpc0xhc3RTdGFnZSkge1xuICAgIC8vIGNyZWF0ZSB0ZW1wb3JhcnkgY2FudmFzXG4gICAgdG1wQ2FudmFzID0gdGhpcy5vcHRpb25zLmNyZWF0ZUNhbnZhcyh0b1dpZHRoLCB0b0hlaWdodCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fX3RpbGVBbmRSZXNpemUoZnJvbSwgaXNMYXN0U3RhZ2UgPyB0byA6IHRtcENhbnZhcywgb3B0cykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzTGFzdFN0YWdlKSByZXR1cm4gdG87XG4gICAgb3B0cy53aWR0aCA9IHRvV2lkdGg7XG4gICAgb3B0cy5oZWlnaHQgPSB0b0hlaWdodDtcbiAgICByZXR1cm4gX3RoaXM0Ll9fcHJvY2Vzc1N0YWdlcyhzdGFnZXMsIHRtcENhbnZhcywgdG8sIG9wdHMpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICBpZiAodG1wQ2FudmFzKSB7XG4gICAgICAvLyBTYWZhcmkgMTIgd29ya2Fyb3VuZFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9waWNhL2lzc3Vlcy8xOTlcbiAgICAgIHRtcENhbnZhcy53aWR0aCA9IHRtcENhbnZhcy5oZWlnaHQgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH0pO1xufTtcblxuUGljYS5wcm90b3R5cGUuX19yZXNpemVWaWFDcmVhdGVJbWFnZUJpdG1hcCA9IGZ1bmN0aW9uIChmcm9tLCB0bywgb3B0cykge1xuICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICB2YXIgdG9DdHggPSB0by5nZXRDb250ZXh0KCcyZCcsIHtcbiAgICBhbHBoYTogQm9vbGVhbihvcHRzLmFscGhhKVxuICB9KTtcbiAgdGhpcy5kZWJ1ZygnUmVzaXplIHZpYSBjcmVhdGVJbWFnZUJpdG1hcCgpJyk7XG4gIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChmcm9tLCB7XG4gICAgcmVzaXplV2lkdGg6IG9wdHMudG9XaWR0aCxcbiAgICByZXNpemVIZWlnaHQ6IG9wdHMudG9IZWlnaHQsXG4gICAgcmVzaXplUXVhbGl0eTogdXRpbHMuY2liX3F1YWxpdHlfbmFtZShvcHRzLnF1YWxpdHkpXG4gIH0pLnRoZW4oZnVuY3Rpb24gKGltYWdlQml0bWFwKSB7XG4gICAgaWYgKG9wdHMuY2FuY2VsZWQpIHJldHVybiBvcHRzLmNhbmNlbFRva2VuOyAvLyBpZiBubyB1bnNoYXJwIC0gZHJhdyBkaXJlY3RseSB0byBvdXRwdXQgY2FudmFzXG5cbiAgICBpZiAoIW9wdHMudW5zaGFycEFtb3VudCkge1xuICAgICAgdG9DdHguZHJhd0ltYWdlKGltYWdlQml0bWFwLCAwLCAwKTtcbiAgICAgIGltYWdlQml0bWFwLmNsb3NlKCk7XG4gICAgICB0b0N0eCA9IG51bGw7XG5cbiAgICAgIF90aGlzNS5kZWJ1ZygnRmluaXNoZWQhJyk7XG5cbiAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICBfdGhpczUuZGVidWcoJ1Vuc2hhcnAgcmVzdWx0Jyk7XG5cbiAgICB2YXIgdG1wQ2FudmFzID0gX3RoaXM1Lm9wdGlvbnMuY3JlYXRlQ2FudmFzKG9wdHMudG9XaWR0aCwgb3B0cy50b0hlaWdodCk7XG5cbiAgICB2YXIgdG1wQ3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJywge1xuICAgICAgYWxwaGE6IEJvb2xlYW4ob3B0cy5hbHBoYSlcbiAgICB9KTtcbiAgICB0bXBDdHguZHJhd0ltYWdlKGltYWdlQml0bWFwLCAwLCAwKTtcbiAgICBpbWFnZUJpdG1hcC5jbG9zZSgpO1xuICAgIHZhciBpRGF0YSA9IHRtcEN0eC5nZXRJbWFnZURhdGEoMCwgMCwgb3B0cy50b1dpZHRoLCBvcHRzLnRvSGVpZ2h0KTtcblxuICAgIF90aGlzNS5fX21hdGhsaWIudW5zaGFycF9tYXNrKGlEYXRhLmRhdGEsIG9wdHMudG9XaWR0aCwgb3B0cy50b0hlaWdodCwgb3B0cy51bnNoYXJwQW1vdW50LCBvcHRzLnVuc2hhcnBSYWRpdXMsIG9wdHMudW5zaGFycFRocmVzaG9sZCk7XG5cbiAgICB0b0N0eC5wdXRJbWFnZURhdGEoaURhdGEsIDAsIDApOyAvLyBTYWZhcmkgMTIgd29ya2Fyb3VuZFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYS9pc3N1ZXMvMTk5XG5cbiAgICB0bXBDYW52YXMud2lkdGggPSB0bXBDYW52YXMuaGVpZ2h0ID0gMDtcbiAgICBpRGF0YSA9IHRtcEN0eCA9IHRtcENhbnZhcyA9IHRvQ3R4ID0gbnVsbDtcblxuICAgIF90aGlzNS5kZWJ1ZygnRmluaXNoZWQhJyk7XG5cbiAgICByZXR1cm4gdG87XG4gIH0pO1xufTtcblxuUGljYS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gIHRoaXMuZGVidWcoJ1N0YXJ0IHJlc2l6ZS4uLicpO1xuICB2YXIgb3B0cyA9IGFzc2lnbih7fSwgREVGQVVMVF9SRVNJWkVfT1BUUyk7XG5cbiAgaWYgKCFpc05hTihvcHRpb25zKSkge1xuICAgIG9wdHMgPSBhc3NpZ24ob3B0cywge1xuICAgICAgcXVhbGl0eTogb3B0aW9uc1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcbiAgICBvcHRzID0gYXNzaWduKG9wdHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgb3B0cy50b1dpZHRoID0gdG8ud2lkdGg7XG4gIG9wdHMudG9IZWlnaHQgPSB0by5oZWlnaHQ7XG4gIG9wdHMud2lkdGggPSBmcm9tLm5hdHVyYWxXaWR0aCB8fCBmcm9tLndpZHRoO1xuICBvcHRzLmhlaWdodCA9IGZyb20ubmF0dXJhbEhlaWdodCB8fCBmcm9tLmhlaWdodDsgLy8gUHJldmVudCBzdGVwcGVyIGZyb20gaW5maW5pdGUgbG9vcFxuXG4gIGlmICh0by53aWR0aCA9PT0gMCB8fCB0by5oZWlnaHQgPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBvdXRwdXQgc2l6ZTogXCIuY29uY2F0KHRvLndpZHRoLCBcInhcIikuY29uY2F0KHRvLmhlaWdodCkpKTtcbiAgfVxuXG4gIGlmIChvcHRzLnVuc2hhcnBSYWRpdXMgPiAyKSBvcHRzLnVuc2hhcnBSYWRpdXMgPSAyO1xuICBvcHRzLmNhbmNlbGVkID0gZmFsc2U7XG5cbiAgaWYgKG9wdHMuY2FuY2VsVG9rZW4pIHtcbiAgICAvLyBXcmFwIGNhbmNlbFRva2VuIHRvIGF2b2lkIHN1Y2Nlc3NpdmUgcmVzb2x2ZSAmIHNldCBmbGFnXG4gICAgb3B0cy5jYW5jZWxUb2tlbiA9IG9wdHMuY2FuY2VsVG9rZW4udGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgb3B0cy5jYW5jZWxlZCA9IHRydWU7XG4gICAgICB0aHJvdyBkYXRhO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIG9wdHMuY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIERFU1RfVElMRV9CT1JERVIgPSAzOyAvLyBNYXggcG9zc2libGUgZmlsdGVyIHdpbmRvdyBzaXplXG5cbiAgb3B0cy5fX2Rlc3RUaWxlQm9yZGVyID0gTWF0aC5jZWlsKE1hdGgubWF4KERFU1RfVElMRV9CT1JERVIsIDIuNSAqIG9wdHMudW5zaGFycFJhZGl1cyB8IDApKTtcbiAgcmV0dXJuIHRoaXMuaW5pdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcHRzLmNhbmNlbGVkKSByZXR1cm4gb3B0cy5jYW5jZWxUb2tlbjsgLy8gaWYgY3JlYXRlSW1hZ2VCaXRtYXAgc3VwcG9ydHMgcmVzaXplLCBqdXN0IGRvIGl0IGFuZCByZXR1cm5cblxuICAgIGlmIChfdGhpczYuZmVhdHVyZXMuY2liKSB7XG4gICAgICByZXR1cm4gX3RoaXM2Ll9fcmVzaXplVmlhQ3JlYXRlSW1hZ2VCaXRtYXAoZnJvbSwgdG8sIG9wdHMpO1xuICAgIH1cblxuICAgIGlmICghQ0FOX1VTRV9DQU5WQVNfR0VUX0lNQUdFX0RBVEEpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1BpY2E6IGNhbm5vdCB1c2UgZ2V0SW1hZ2VEYXRhIG9uIGNhbnZhcywgJyArIFwibWFrZSBzdXJlIGZpbmdlcnByaW50aW5nIHByb3RlY3Rpb24gaXNuJ3QgZW5hYmxlZFwiKTtcbiAgICAgIGVyci5jb2RlID0gJ0VSUl9HRVRfSU1BR0VfREFUQSc7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSAvL1xuICAgIC8vIE5vIGVhc3kgd2F5LCBsZXQncyByZXNpemUgbWFudWFsbHkgdmlhIGFycmF5c1xuICAgIC8vXG5cblxuICAgIHZhciBzdGFnZXMgPSBjcmVhdGVTdGFnZXMob3B0cy53aWR0aCwgb3B0cy5oZWlnaHQsIG9wdHMudG9XaWR0aCwgb3B0cy50b0hlaWdodCwgX3RoaXM2Lm9wdGlvbnMudGlsZSwgb3B0cy5fX2Rlc3RUaWxlQm9yZGVyKTtcbiAgICByZXR1cm4gX3RoaXM2Ll9fcHJvY2Vzc1N0YWdlcyhzdGFnZXMsIGZyb20sIHRvLCBvcHRzKTtcbiAgfSk7XG59OyAvLyBSR0JBIGJ1ZmZlciByZXNpemVcbi8vXG5cblxuUGljYS5wcm90b3R5cGUucmVzaXplQnVmZmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgdmFyIG9wdHMgPSBhc3NpZ24oe30sIERFRkFVTFRfUkVTSVpFX09QVFMsIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcy5pbml0KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90aGlzNy5fX21hdGhsaWIucmVzaXplQW5kVW5zaGFycChvcHRzKTtcbiAgfSk7XG59O1xuXG5QaWNhLnByb3RvdHlwZS50b0Jsb2IgPSBmdW5jdGlvbiAoY2FudmFzLCBtaW1lVHlwZSwgcXVhbGl0eSkge1xuICBtaW1lVHlwZSA9IG1pbWVUeXBlIHx8ICdpbWFnZS9wbmcnO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICBpZiAoY2FudmFzLnRvQmxvYikge1xuICAgICAgY2FudmFzLnRvQmxvYihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShibG9iKTtcbiAgICAgIH0sIG1pbWVUeXBlLCBxdWFsaXR5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2FudmFzLmNvbnZlcnRUb0Jsb2IpIHtcbiAgICAgIHJlc29sdmUoY2FudmFzLmNvbnZlcnRUb0Jsb2Ioe1xuICAgICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICAgICAgcXVhbGl0eTogcXVhbGl0eVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmFsbGJhY2sgZm9yIG9sZCBicm93c2Vyc1xuXG5cbiAgICB2YXIgYXNTdHJpbmcgPSBhdG9iKGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIHF1YWxpdHkpLnNwbGl0KCcsJylbMV0pO1xuICAgIHZhciBsZW4gPSBhc1N0cmluZy5sZW5ndGg7XG4gICAgdmFyIGFzQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFzQnVmZmVyW2ldID0gYXNTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXNvbHZlKG5ldyBCbG9iKFthc0J1ZmZlcl0sIHtcbiAgICAgIHR5cGU6IG1pbWVUeXBlXG4gICAgfSkpO1xuICB9KTtcbn07XG5cblBpY2EucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKCkge307XG5cbm1vZHVsZS5leHBvcnRzID0gUGljYTtcblxufSx7XCIuL2xpYi9tYXRobGliXCI6MSxcIi4vbGliL3Bvb2xcIjoxMyxcIi4vbGliL3N0ZXBwZXJcIjoxNCxcIi4vbGliL3RpbGVyXCI6MTUsXCIuL2xpYi91dGlsc1wiOjE2LFwiLi9saWIvd29ya2VyXCI6MTcsXCJvYmplY3QtYXNzaWduXCI6MjMsXCJ3ZWJ3b3JraWZ5XCI6MjR9XX0se30sW10pKFwiL2luZGV4LmpzXCIpXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/pica@7.1.1/node_modules/pica/dist/pica.js\n");

/***/ }),

/***/ "../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/directory-open-01563666.js":
/*!***************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/directory-open-01563666.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ e)\n/* harmony export */ });\nvar e=async(e=[{}])=>(Array.isArray(e)||(e=[e]),e[0].recursive=e[0].recursive||!1,new Promise((t,r)=>{const i=document.createElement(\"input\");i.type=\"file\",i.webkitdirectory=!0;const c=e=>{\"function\"==typeof a&&a(),t(e)},a=e[0].legacySetup&&e[0].legacySetup(c,()=>a(r),i);i.addEventListener(\"change\",()=>{let t=Array.from(i.files);e[0].recursive?e[0].recursive&&e[0].skipDirectory&&(t=t.filter(t=>t.webkitRelativePath.split(\"/\").every(t=>!e[0].skipDirectory({name:t,kind:\"directory\"})))):t=t.filter(e=>2===e.webkitRelativePath.split(\"/\").length),c(t)}),i.click()}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jyb3dzZXItZnMtYWNjZXNzQDAuMjkuMS9ub2RlX21vZHVsZXMvYnJvd3Nlci1mcy1hY2Nlc3MvZGlzdC9kaXJlY3Rvcnktb3Blbi0wMTU2MzY2Ni5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUJBQWlCLHFGQUFxRix3Q0FBd0MsbUNBQW1DLFlBQVksK0JBQStCLG9EQUFvRCxpQ0FBaUMsMEJBQTBCLGdJQUFnSSx3QkFBd0Isb0VBQW9FLFlBQVksR0FBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jyb3dzZXItZnMtYWNjZXNzQDAuMjkuMS9ub2RlX21vZHVsZXMvYnJvd3Nlci1mcy1hY2Nlc3MvZGlzdC9kaXJlY3Rvcnktb3Blbi0wMTU2MzY2Ni5qcz8wM2E1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBlPWFzeW5jKGU9W3t9XSk9PihBcnJheS5pc0FycmF5KGUpfHwoZT1bZV0pLGVbMF0ucmVjdXJzaXZlPWVbMF0ucmVjdXJzaXZlfHwhMSxuZXcgUHJvbWlzZSgodCxyKT0+e2NvbnN0IGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO2kudHlwZT1cImZpbGVcIixpLndlYmtpdGRpcmVjdG9yeT0hMDtjb25zdCBjPWU9PntcImZ1bmN0aW9uXCI9PXR5cGVvZiBhJiZhKCksdChlKX0sYT1lWzBdLmxlZ2FjeVNldHVwJiZlWzBdLmxlZ2FjeVNldHVwKGMsKCk9PmEociksaSk7aS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsKCk9PntsZXQgdD1BcnJheS5mcm9tKGkuZmlsZXMpO2VbMF0ucmVjdXJzaXZlP2VbMF0ucmVjdXJzaXZlJiZlWzBdLnNraXBEaXJlY3RvcnkmJih0PXQuZmlsdGVyKHQ9PnQud2Via2l0UmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKS5ldmVyeSh0PT4hZVswXS5za2lwRGlyZWN0b3J5KHtuYW1lOnQsa2luZDpcImRpcmVjdG9yeVwifSkpKSk6dD10LmZpbHRlcihlPT4yPT09ZS53ZWJraXRSZWxhdGl2ZVBhdGguc3BsaXQoXCIvXCIpLmxlbmd0aCksYyh0KX0pLGkuY2xpY2soKX0pKTtleHBvcnR7ZSBhcyBkZWZhdWx0fTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/directory-open-01563666.js\n");

/***/ }),

/***/ "../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/directory-open-4ed118d0.js":
/*!***************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/directory-open-4ed118d0.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ t)\n/* harmony export */ });\nfunction e(r){function t(e){if(Object(e)!==e)return Promise.reject(new TypeError(e+\" is not an object.\"));var r=e.done;return Promise.resolve(e.value).then(function(e){return{value:e,done:r}})}return e=function(e){this.s=e,this.n=e.next},e.prototype={s:null,n:null,next:function(){return t(this.n.apply(this.s,arguments))},return:function(e){var r=this.s.return;return void 0===r?Promise.resolve({value:e,done:!0}):t(r.apply(this.s,arguments))},throw:function(e){var r=this.s.return;return void 0===r?Promise.reject(e):t(r.apply(this.s,arguments))}},new e(r)}const r=async(t,n,i=t.name,a)=>{const o=[],l=[];var s,u=!1,c=!1;try{for(var y,f=function(r){var t,n,i,a=2;for(\"undefined\"!=typeof Symbol&&(n=Symbol.asyncIterator,i=Symbol.iterator);a--;){if(n&&null!=(t=r[n]))return t.call(r);if(i&&null!=(t=r[i]))return new e(t.call(r));n=\"@@asyncIterator\",i=\"@@iterator\"}throw new TypeError(\"Object is not async iterable\")}(t.values());u=!(y=await f.next()).done;u=!1){const e=y.value,s=`${i}/${e.name}`;\"file\"===e.kind?l.push(e.getFile().then(r=>(r.directoryHandle=t,r.handle=e,Object.defineProperty(r,\"webkitRelativePath\",{configurable:!0,enumerable:!0,get:()=>s})))):\"directory\"!==e.kind||!n||a&&a(e)||o.push(r(e,n,s,a))}}catch(e){c=!0,s=e}finally{try{u&&null!=f.return&&await f.return()}finally{if(c)throw s}}return[...(await Promise.all(o)).flat(),...await Promise.all(l)]};var t=async(e={})=>{e.recursive=e.recursive||!1;const t=await window.showDirectoryPicker({id:e.id,startIn:e.startIn});return r(t,e.recursive,void 0,e.skipDirectory)};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jyb3dzZXItZnMtYWNjZXNzQDAuMjkuMS9ub2RlX21vZHVsZXMvYnJvd3Nlci1mcy1hY2Nlc3MvZGlzdC9kaXJlY3Rvcnktb3Blbi00ZWQxMThkMC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsY0FBYyxjQUFjLDhFQUE4RSxhQUFhLGlEQUFpRCxPQUFPLGdCQUFnQixFQUFFLHFCQUFxQix1QkFBdUIsY0FBYyw4QkFBOEIseUNBQXlDLG9CQUFvQixvQkFBb0IsbUNBQW1DLGdCQUFnQiwrQkFBK0IsbUJBQW1CLG9CQUFvQixrRUFBa0UsVUFBVSxnQ0FBZ0MsZ0JBQWdCLGdCQUFnQixJQUFJLHdCQUF3QixjQUFjLDJFQUEyRSxJQUFJLEVBQUUsc0NBQXNDLDZDQUE2QyxtQ0FBbUMsb0RBQW9ELGFBQWEsMkJBQTJCLE1BQU0scUJBQXFCLEVBQUUsR0FBRyxPQUFPLEVBQUUseUhBQXlILHdDQUF3Qyw0REFBNEQsU0FBUyxTQUFTLFFBQVEsSUFBSSxvQ0FBb0MsUUFBUSxjQUFjLGtFQUFrRSxnQkFBZ0IsSUFBSSw0QkFBNEIsMENBQTBDLDBCQUEwQixFQUFFLGdEQUFxRSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYnJvd3Nlci1mcy1hY2Nlc3NAMC4yOS4xL25vZGVfbW9kdWxlcy9icm93c2VyLWZzLWFjY2Vzcy9kaXN0L2RpcmVjdG9yeS1vcGVuLTRlZDExOGQwLmpzPzNhYjEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZShyKXtmdW5jdGlvbiB0KGUpe2lmKE9iamVjdChlKSE9PWUpcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoZStcIiBpcyBub3QgYW4gb2JqZWN0LlwiKSk7dmFyIHI9ZS5kb25lO3JldHVybiBQcm9taXNlLnJlc29sdmUoZS52YWx1ZSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm57dmFsdWU6ZSxkb25lOnJ9fSl9cmV0dXJuIGU9ZnVuY3Rpb24oZSl7dGhpcy5zPWUsdGhpcy5uPWUubmV4dH0sZS5wcm90b3R5cGU9e3M6bnVsbCxuOm51bGwsbmV4dDpmdW5jdGlvbigpe3JldHVybiB0KHRoaXMubi5hcHBseSh0aGlzLnMsYXJndW1lbnRzKSl9LHJldHVybjpmdW5jdGlvbihlKXt2YXIgcj10aGlzLnMucmV0dXJuO3JldHVybiB2b2lkIDA9PT1yP1Byb21pc2UucmVzb2x2ZSh7dmFsdWU6ZSxkb25lOiEwfSk6dChyLmFwcGx5KHRoaXMucyxhcmd1bWVudHMpKX0sdGhyb3c6ZnVuY3Rpb24oZSl7dmFyIHI9dGhpcy5zLnJldHVybjtyZXR1cm4gdm9pZCAwPT09cj9Qcm9taXNlLnJlamVjdChlKTp0KHIuYXBwbHkodGhpcy5zLGFyZ3VtZW50cykpfX0sbmV3IGUocil9Y29uc3Qgcj1hc3luYyh0LG4saT10Lm5hbWUsYSk9Pntjb25zdCBvPVtdLGw9W107dmFyIHMsdT0hMSxjPSExO3RyeXtmb3IodmFyIHksZj1mdW5jdGlvbihyKXt2YXIgdCxuLGksYT0yO2ZvcihcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiYobj1TeW1ib2wuYXN5bmNJdGVyYXRvcixpPVN5bWJvbC5pdGVyYXRvcik7YS0tOyl7aWYobiYmbnVsbCE9KHQ9cltuXSkpcmV0dXJuIHQuY2FsbChyKTtpZihpJiZudWxsIT0odD1yW2ldKSlyZXR1cm4gbmV3IGUodC5jYWxsKHIpKTtuPVwiQEBhc3luY0l0ZXJhdG9yXCIsaT1cIkBAaXRlcmF0b3JcIn10aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGlzIG5vdCBhc3luYyBpdGVyYWJsZVwiKX0odC52YWx1ZXMoKSk7dT0hKHk9YXdhaXQgZi5uZXh0KCkpLmRvbmU7dT0hMSl7Y29uc3QgZT15LnZhbHVlLHM9YCR7aX0vJHtlLm5hbWV9YDtcImZpbGVcIj09PWUua2luZD9sLnB1c2goZS5nZXRGaWxlKCkudGhlbihyPT4oci5kaXJlY3RvcnlIYW5kbGU9dCxyLmhhbmRsZT1lLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwid2Via2l0UmVsYXRpdmVQYXRoXCIse2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLGdldDooKT0+c30pKSkpOlwiZGlyZWN0b3J5XCIhPT1lLmtpbmR8fCFufHxhJiZhKGUpfHxvLnB1c2gocihlLG4scyxhKSl9fWNhdGNoKGUpe2M9ITAscz1lfWZpbmFsbHl7dHJ5e3UmJm51bGwhPWYucmV0dXJuJiZhd2FpdCBmLnJldHVybigpfWZpbmFsbHl7aWYoYyl0aHJvdyBzfX1yZXR1cm5bLi4uKGF3YWl0IFByb21pc2UuYWxsKG8pKS5mbGF0KCksLi4uYXdhaXQgUHJvbWlzZS5hbGwobCldfTt2YXIgdD1hc3luYyhlPXt9KT0+e2UucmVjdXJzaXZlPWUucmVjdXJzaXZlfHwhMTtjb25zdCB0PWF3YWl0IHdpbmRvdy5zaG93RGlyZWN0b3J5UGlja2VyKHtpZDplLmlkLHN0YXJ0SW46ZS5zdGFydElufSk7cmV0dXJuIHIodCxlLnJlY3Vyc2l2ZSx2b2lkIDAsZS5za2lwRGlyZWN0b3J5KX07ZXhwb3J0e3QgYXMgZGVmYXVsdH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/directory-open-4ed118d0.js\n");

/***/ }),

/***/ "../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/file-open-002ab408.js":
/*!**********************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/file-open-002ab408.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ t)\n/* harmony export */ });\nconst e=async e=>{const t=await e.getFile();return t.handle=e,t};var t=async(t=[{}])=>{Array.isArray(t)||(t=[t]);const i=[];t.forEach((e,t)=>{i[t]={description:e.description||\"\",accept:{}},e.mimeTypes?e.mimeTypes.map(a=>{i[t].accept[a]=e.extensions||[]}):i[t].accept[\"*/*\"]=e.extensions||[]});const a=await window.showOpenFilePicker({id:t[0].id,startIn:t[0].startIn,types:i,multiple:t[0].multiple||!1,excludeAcceptAllOption:t[0].excludeAcceptAllOption||!1}),c=await Promise.all(a.map(e));return t[0].multiple?c:c[0]};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jyb3dzZXItZnMtYWNjZXNzQDAuMjkuMS9ub2RlX21vZHVsZXMvYnJvd3Nlci1mcy1hY2Nlc3MvZGlzdC9maWxlLW9wZW4tMDAyYWI0MDguanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGtCQUFrQiwwQkFBMEIscUJBQXFCLGlCQUFpQixLQUFLLDBCQUEwQixXQUFXLGtCQUFrQixNQUFNLHdDQUF3QyxpQ0FBaUMsZ0NBQWdDLHNDQUFzQyxFQUFFLHlDQUF5QywwSEFBMEgsZ0NBQWdDLDZCQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYnJvd3Nlci1mcy1hY2Nlc3NAMC4yOS4xL25vZGVfbW9kdWxlcy9icm93c2VyLWZzLWFjY2Vzcy9kaXN0L2ZpbGUtb3Blbi0wMDJhYjQwOC5qcz81Nzg2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGU9YXN5bmMgZT0+e2NvbnN0IHQ9YXdhaXQgZS5nZXRGaWxlKCk7cmV0dXJuIHQuaGFuZGxlPWUsdH07dmFyIHQ9YXN5bmModD1be31dKT0+e0FycmF5LmlzQXJyYXkodCl8fCh0PVt0XSk7Y29uc3QgaT1bXTt0LmZvckVhY2goKGUsdCk9PntpW3RdPXtkZXNjcmlwdGlvbjplLmRlc2NyaXB0aW9ufHxcIlwiLGFjY2VwdDp7fX0sZS5taW1lVHlwZXM/ZS5taW1lVHlwZXMubWFwKGE9PntpW3RdLmFjY2VwdFthXT1lLmV4dGVuc2lvbnN8fFtdfSk6aVt0XS5hY2NlcHRbXCIqLypcIl09ZS5leHRlbnNpb25zfHxbXX0pO2NvbnN0IGE9YXdhaXQgd2luZG93LnNob3dPcGVuRmlsZVBpY2tlcih7aWQ6dFswXS5pZCxzdGFydEluOnRbMF0uc3RhcnRJbix0eXBlczppLG11bHRpcGxlOnRbMF0ubXVsdGlwbGV8fCExLGV4Y2x1ZGVBY2NlcHRBbGxPcHRpb246dFswXS5leGNsdWRlQWNjZXB0QWxsT3B0aW9ufHwhMX0pLGM9YXdhaXQgUHJvbWlzZS5hbGwoYS5tYXAoZSkpO3JldHVybiB0WzBdLm11bHRpcGxlP2M6Y1swXX07ZXhwb3J0e3QgYXMgZGVmYXVsdH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/file-open-002ab408.js\n");

/***/ }),

/***/ "../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/file-open-7c801643.js":
/*!**********************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/file-open-7c801643.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ e)\n/* harmony export */ });\nvar e=async(e=[{}])=>(Array.isArray(e)||(e=[e]),new Promise((t,n)=>{const a=document.createElement(\"input\");a.type=\"file\";const i=[...e.map(e=>e.mimeTypes||[]),...e.map(e=>e.extensions||[])].join();a.multiple=e[0].multiple||!1,a.accept=i||\"\";const c=e=>{\"function\"==typeof l&&l(),t(e)},l=e[0].legacySetup&&e[0].legacySetup(c,()=>l(n),a);a.addEventListener(\"change\",()=>{c(a.multiple?Array.from(a.files):a.files[0])}),a.click()}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jyb3dzZXItZnMtYWNjZXNzQDAuMjkuMS9ub2RlX21vZHVsZXMvYnJvd3Nlci1mcy1hY2Nlc3MvZGlzdC9maWxlLW9wZW4tN2M4MDE2NDMuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlCQUFpQixtREFBbUQsd0NBQXdDLGNBQWMsNEVBQTRFLDRDQUE0QyxZQUFZLCtCQUErQixvREFBb0QsaUNBQWlDLDZDQUE2QyxZQUFZLEdBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9icm93c2VyLWZzLWFjY2Vzc0AwLjI5LjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXItZnMtYWNjZXNzL2Rpc3QvZmlsZS1vcGVuLTdjODAxNjQzLmpzPzRmNjEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGU9YXN5bmMoZT1be31dKT0+KEFycmF5LmlzQXJyYXkoZSl8fChlPVtlXSksbmV3IFByb21pc2UoKHQsbik9Pntjb25zdCBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTthLnR5cGU9XCJmaWxlXCI7Y29uc3QgaT1bLi4uZS5tYXAoZT0+ZS5taW1lVHlwZXN8fFtdKSwuLi5lLm1hcChlPT5lLmV4dGVuc2lvbnN8fFtdKV0uam9pbigpO2EubXVsdGlwbGU9ZVswXS5tdWx0aXBsZXx8ITEsYS5hY2NlcHQ9aXx8XCJcIjtjb25zdCBjPWU9PntcImZ1bmN0aW9uXCI9PXR5cGVvZiBsJiZsKCksdChlKX0sbD1lWzBdLmxlZ2FjeVNldHVwJiZlWzBdLmxlZ2FjeVNldHVwKGMsKCk9PmwobiksYSk7YS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsKCk9PntjKGEubXVsdGlwbGU/QXJyYXkuZnJvbShhLmZpbGVzKTphLmZpbGVzWzBdKX0pLGEuY2xpY2soKX0pKTtleHBvcnR7ZSBhcyBkZWZhdWx0fTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/file-open-7c801643.js\n");

/***/ }),

/***/ "../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/file-save-3189631c.js":
/*!**********************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/file-save-3189631c.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ e)\n/* harmony export */ });\nvar e=async(e,t={})=>{Array.isArray(t)&&(t=t[0]);const n=document.createElement(\"a\");let a=e;\"body\"in e&&(a=await async function(e,t){const n=e.getReader(),a=new ReadableStream({start:e=>async function t(){return n.read().then(({done:n,value:a})=>{if(!n)return e.enqueue(a),t();e.close()})}()}),r=new Response(a),c=await r.blob();return n.releaseLock(),new Blob([c],{type:t})}(e.body,e.headers.get(\"content-type\"))),n.download=t.fileName||\"Untitled\",n.href=URL.createObjectURL(await a);const r=()=>{\"function\"==typeof c&&c()},c=t.legacySetup&&t.legacySetup(r,()=>c(reject),n);return n.addEventListener(\"click\",()=>{setTimeout(()=>URL.revokeObjectURL(n.href),3e4),r()}),n.click(),null};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jyb3dzZXItZnMtYWNjZXNzQDAuMjkuMS9ub2RlX21vZHVsZXMvYnJvd3Nlci1mcy1hY2Nlc3MvZGlzdC9maWxlLXNhdmUtMzE4OTYzMWMuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGtCQUFrQixJQUFJLDJCQUEyQixvQ0FBb0MsUUFBUSx5Q0FBeUMsNENBQTRDLDRCQUE0Qix1QkFBdUIsZUFBZSxJQUFJLDhCQUE4QixVQUFVLEVBQUUsR0FBRyxxQ0FBcUMscUNBQXFDLE9BQU8sRUFBRSw4R0FBOEcsYUFBYSwwQkFBMEIsbURBQW1ELHVDQUF1QyxvREFBb0Qsa0JBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9icm93c2VyLWZzLWFjY2Vzc0AwLjI5LjEvbm9kZV9tb2R1bGVzL2Jyb3dzZXItZnMtYWNjZXNzL2Rpc3QvZmlsZS1zYXZlLTMxODk2MzFjLmpzPzYwMGQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGU9YXN5bmMoZSx0PXt9KT0+e0FycmF5LmlzQXJyYXkodCkmJih0PXRbMF0pO2NvbnN0IG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7bGV0IGE9ZTtcImJvZHlcImluIGUmJihhPWF3YWl0IGFzeW5jIGZ1bmN0aW9uKGUsdCl7Y29uc3Qgbj1lLmdldFJlYWRlcigpLGE9bmV3IFJlYWRhYmxlU3RyZWFtKHtzdGFydDplPT5hc3luYyBmdW5jdGlvbiB0KCl7cmV0dXJuIG4ucmVhZCgpLnRoZW4oKHtkb25lOm4sdmFsdWU6YX0pPT57aWYoIW4pcmV0dXJuIGUuZW5xdWV1ZShhKSx0KCk7ZS5jbG9zZSgpfSl9KCl9KSxyPW5ldyBSZXNwb25zZShhKSxjPWF3YWl0IHIuYmxvYigpO3JldHVybiBuLnJlbGVhc2VMb2NrKCksbmV3IEJsb2IoW2NdLHt0eXBlOnR9KX0oZS5ib2R5LGUuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikpKSxuLmRvd25sb2FkPXQuZmlsZU5hbWV8fFwiVW50aXRsZWRcIixuLmhyZWY9VVJMLmNyZWF0ZU9iamVjdFVSTChhd2FpdCBhKTtjb25zdCByPSgpPT57XCJmdW5jdGlvblwiPT10eXBlb2YgYyYmYygpfSxjPXQubGVnYWN5U2V0dXAmJnQubGVnYWN5U2V0dXAociwoKT0+YyhyZWplY3QpLG4pO3JldHVybiBuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCgpPT57c2V0VGltZW91dCgoKT0+VVJMLnJldm9rZU9iamVjdFVSTChuLmhyZWYpLDNlNCkscigpfSksbi5jbGljaygpLG51bGx9O2V4cG9ydHtlIGFzIGRlZmF1bHR9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/file-save-3189631c.js\n");

/***/ }),

/***/ "../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/file-save-745eba88.js":
/*!**********************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/file-save-745eba88.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ e)\n/* harmony export */ });\nvar e=async(e,t=[{}],a=null,i=!1,n=null)=>{Array.isArray(t)||(t=[t]),t[0].fileName=t[0].fileName||\"Untitled\";const s=[];let c=null;if(e instanceof Blob&&e.type?c=e.type:e.headers&&e.headers.get(\"content-type\")&&(c=e.headers.get(\"content-type\")),t.forEach((e,t)=>{s[t]={description:e.description||\"\",accept:{}},e.mimeTypes?(0===t&&c&&e.mimeTypes.push(c),e.mimeTypes.map(a=>{s[t].accept[a]=e.extensions||[]})):c&&(s[t].accept[c]=e.extensions||[])}),a)try{await a.getFile()}catch(e){if(a=null,i)throw e}const r=a||await window.showSaveFilePicker({suggestedName:t[0].fileName,id:t[0].id,startIn:t[0].startIn,types:s,excludeAcceptAllOption:t[0].excludeAcceptAllOption||!1});!a&&n&&n();const l=await r.createWritable();if(\"stream\"in e){const t=e.stream();return await t.pipeTo(l),r}return\"body\"in e?(await e.body.pipeTo(l),r):(await l.write(await e),await l.close(),r)};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jyb3dzZXItZnMtYWNjZXNzQDAuMjkuMS9ub2RlX21vZHVsZXMvYnJvd3Nlci1mcy1hY2Nlc3MvZGlzdC9maWxlLXNhdmUtNzQ1ZWJhODguanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG1CQUFtQix3QkFBd0Isa0VBQWtFLFdBQVcsV0FBVyxvSUFBb0ksTUFBTSx3Q0FBd0MsZ0VBQWdFLGdDQUFnQyx3Q0FBd0MsUUFBUSxrQkFBa0IsU0FBUyxvQkFBb0IsNENBQTRDLDJIQUEySCxFQUFFLFdBQVcsaUNBQWlDLGlCQUFpQixtQkFBbUIsMkJBQTJCLHdGQUE2RyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYnJvd3Nlci1mcy1hY2Nlc3NAMC4yOS4xL25vZGVfbW9kdWxlcy9icm93c2VyLWZzLWFjY2Vzcy9kaXN0L2ZpbGUtc2F2ZS03NDVlYmE4OC5qcz84ZGEwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBlPWFzeW5jKGUsdD1be31dLGE9bnVsbCxpPSExLG49bnVsbCk9PntBcnJheS5pc0FycmF5KHQpfHwodD1bdF0pLHRbMF0uZmlsZU5hbWU9dFswXS5maWxlTmFtZXx8XCJVbnRpdGxlZFwiO2NvbnN0IHM9W107bGV0IGM9bnVsbDtpZihlIGluc3RhbmNlb2YgQmxvYiYmZS50eXBlP2M9ZS50eXBlOmUuaGVhZGVycyYmZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSYmKGM9ZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSksdC5mb3JFYWNoKChlLHQpPT57c1t0XT17ZGVzY3JpcHRpb246ZS5kZXNjcmlwdGlvbnx8XCJcIixhY2NlcHQ6e319LGUubWltZVR5cGVzPygwPT09dCYmYyYmZS5taW1lVHlwZXMucHVzaChjKSxlLm1pbWVUeXBlcy5tYXAoYT0+e3NbdF0uYWNjZXB0W2FdPWUuZXh0ZW5zaW9uc3x8W119KSk6YyYmKHNbdF0uYWNjZXB0W2NdPWUuZXh0ZW5zaW9uc3x8W10pfSksYSl0cnl7YXdhaXQgYS5nZXRGaWxlKCl9Y2F0Y2goZSl7aWYoYT1udWxsLGkpdGhyb3cgZX1jb25zdCByPWF8fGF3YWl0IHdpbmRvdy5zaG93U2F2ZUZpbGVQaWNrZXIoe3N1Z2dlc3RlZE5hbWU6dFswXS5maWxlTmFtZSxpZDp0WzBdLmlkLHN0YXJ0SW46dFswXS5zdGFydEluLHR5cGVzOnMsZXhjbHVkZUFjY2VwdEFsbE9wdGlvbjp0WzBdLmV4Y2x1ZGVBY2NlcHRBbGxPcHRpb258fCExfSk7IWEmJm4mJm4oKTtjb25zdCBsPWF3YWl0IHIuY3JlYXRlV3JpdGFibGUoKTtpZihcInN0cmVhbVwiaW4gZSl7Y29uc3QgdD1lLnN0cmVhbSgpO3JldHVybiBhd2FpdCB0LnBpcGVUbyhsKSxyfXJldHVyblwiYm9keVwiaW4gZT8oYXdhaXQgZS5ib2R5LnBpcGVUbyhsKSxyKTooYXdhaXQgbC53cml0ZShhd2FpdCBlKSxhd2FpdCBsLmNsb3NlKCkscil9O2V4cG9ydHtlIGFzIGRlZmF1bHR9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/browser-fs-access@0.29.1/node_modules/browser-fs-access/dist/file-save-745eba88.js\n");

/***/ }),

/***/ "../../../node_modules/.pnpm/image-blob-reduce@3.0.1/node_modules/image-blob-reduce/dist/image-blob-reduce.esm.mjs":
/*!*************************************************************************************************************************!*\
  !*** ../../../node_modules/.pnpm/image-blob-reduce@3.0.1/node_modules/image-blob-reduce/dist/image-blob-reduce.esm.mjs ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\n/*! image-blob-reduce 3.0.1 https://github.com/nodeca/image-blob-reduce @license MIT */\nvar assign$1 = function assign(to) {\n  var from;\n\n  for (var s = 1; s < arguments.length; s++) {\n    from = Object(arguments[s]);\n\n    for (var key in from) {\n      if (Object.prototype.hasOwnProperty.call(from, key)) to[key] = from[key];\n    }\n  }\n\n  return to;\n};\n\n\nfunction pick(from, props) {\n  var to = {};\n\n  props.forEach(function (key) {\n    if (Object.prototype.hasOwnProperty.call(from, key)) to[key] = from[key];\n  });\n\n  return to;\n}\n\n\nfunction pick_pica_resize_options(from) {\n  return pick(from, [\n    'alpha',\n    'unsharpAmount',\n    'unsharpRadius',\n    'unsharpThreshold',\n    'cancelToken'\n  ]);\n}\n\n\nvar pick_1 = pick;\nvar pick_pica_resize_options_1 = pick_pica_resize_options;\n\nvar utils = {\n\tassign: assign$1,\n\tpick: pick_1,\n\tpick_pica_resize_options: pick_pica_resize_options_1\n};\n\nfunction createCommonjsModule(fn) {\n  var module = { exports: {} };\n\treturn fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire (target) {\n\tthrow new Error('Could not dynamically require \"' + target + '\". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');\n}\n\n/*!\n\npica\nhttps://github.com/nodeca/pica\n\n*/\n\nvar pica = createCommonjsModule(function (module, exports) {\n(function(f){{module.exports=f();}})(function(){return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof commonjsRequire&&commonjsRequire;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t);}return n[i].exports}for(var u=\"function\"==typeof commonjsRequire&&commonjsRequire,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(_dereq_,module,exports){\n\nvar inherits = _dereq_('inherits');\n\nvar Multimath = _dereq_('multimath');\n\nvar mm_unsharp_mask = _dereq_('./mm_unsharp_mask');\n\nvar mm_resize = _dereq_('./mm_resize');\n\nfunction MathLib(requested_features) {\n  var __requested_features = requested_features || [];\n\n  var features = {\n    js: __requested_features.indexOf('js') >= 0,\n    wasm: __requested_features.indexOf('wasm') >= 0\n  };\n  Multimath.call(this, features);\n  this.features = {\n    js: features.js,\n    wasm: features.wasm && this.has_wasm()\n  };\n  this.use(mm_unsharp_mask);\n  this.use(mm_resize);\n}\n\ninherits(MathLib, Multimath);\n\nMathLib.prototype.resizeAndUnsharp = function resizeAndUnsharp(options, cache) {\n  var result = this.resize(options, cache);\n\n  if (options.unsharpAmount) {\n    this.unsharp_mask(result, options.toWidth, options.toHeight, options.unsharpAmount, options.unsharpRadius, options.unsharpThreshold);\n  }\n\n  return result;\n};\n\nmodule.exports = MathLib;\n\n},{\"./mm_resize\":4,\"./mm_unsharp_mask\":9,\"inherits\":19,\"multimath\":20}],2:[function(_dereq_,module,exports){\n//var FIXED_FRAC_BITS = 14;\n\nfunction clampTo8(i) {\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n} // Convolve image in horizontal directions and transpose output. In theory,\n// transpose allow:\n//\n// - use the same convolver for both passes (this fails due different\n//   types of input array and temporary buffer)\n// - making vertical pass by horisonltal lines inprove CPU cache use.\n//\n// But in real life this doesn't work :)\n//\n\n\nfunction convolveHorizontally(src, dest, srcW, srcH, destW, filters) {\n  var r, g, b, a;\n  var filterPtr, filterShift, filterSize;\n  var srcPtr, srcY, destX, filterVal;\n  var srcOffset = 0,\n      destOffset = 0; // For each row\n\n  for (srcY = 0; srcY < srcH; srcY++) {\n    filterPtr = 0; // Apply precomputed filters to each destination row point\n\n    for (destX = 0; destX < destW; destX++) {\n      // Get the filter that determines the current output pixel.\n      filterShift = filters[filterPtr++];\n      filterSize = filters[filterPtr++];\n      srcPtr = srcOffset + filterShift * 4 | 0;\n      r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a\n\n      for (; filterSize > 0; filterSize--) {\n        filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)\n        // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.\n\n        a = a + filterVal * src[srcPtr + 3] | 0;\n        b = b + filterVal * src[srcPtr + 2] | 0;\n        g = g + filterVal * src[srcPtr + 1] | 0;\n        r = r + filterVal * src[srcPtr] | 0;\n        srcPtr = srcPtr + 4 | 0;\n      } // Bring this value back in range. All of the filter scaling factors\n      // are in fixed point with FIXED_FRAC_BITS bits of fractional part.\n      //\n      // (!) Add 1/2 of value before clamping to get proper rounding. In other\n      // case brightness loss will be noticeable if you resize image with white\n      // border and place it on white background.\n      //\n\n\n      dest[destOffset + 3] = clampTo8(a + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      dest[destOffset] = clampTo8(r + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      destOffset = destOffset + srcH * 4 | 0;\n    }\n\n    destOffset = (srcY + 1) * 4 | 0;\n    srcOffset = (srcY + 1) * srcW * 4 | 0;\n  }\n} // Technically, convolvers are the same. But input array and temporary\n// buffer can be of different type (especially, in old browsers). So,\n// keep code in separate functions to avoid deoptimizations & speed loss.\n\n\nfunction convolveVertically(src, dest, srcW, srcH, destW, filters) {\n  var r, g, b, a;\n  var filterPtr, filterShift, filterSize;\n  var srcPtr, srcY, destX, filterVal;\n  var srcOffset = 0,\n      destOffset = 0; // For each row\n\n  for (srcY = 0; srcY < srcH; srcY++) {\n    filterPtr = 0; // Apply precomputed filters to each destination row point\n\n    for (destX = 0; destX < destW; destX++) {\n      // Get the filter that determines the current output pixel.\n      filterShift = filters[filterPtr++];\n      filterSize = filters[filterPtr++];\n      srcPtr = srcOffset + filterShift * 4 | 0;\n      r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a\n\n      for (; filterSize > 0; filterSize--) {\n        filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)\n        // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.\n\n        a = a + filterVal * src[srcPtr + 3] | 0;\n        b = b + filterVal * src[srcPtr + 2] | 0;\n        g = g + filterVal * src[srcPtr + 1] | 0;\n        r = r + filterVal * src[srcPtr] | 0;\n        srcPtr = srcPtr + 4 | 0;\n      } // Bring this value back in range. All of the filter scaling factors\n      // are in fixed point with FIXED_FRAC_BITS bits of fractional part.\n      //\n      // (!) Add 1/2 of value before clamping to get proper rounding. In other\n      // case brightness loss will be noticeable if you resize image with white\n      // border and place it on white background.\n      //\n\n\n      dest[destOffset + 3] = clampTo8(a + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      dest[destOffset] = clampTo8(r + (1 << 13) >> 14\n      /*FIXED_FRAC_BITS*/\n      );\n      destOffset = destOffset + srcH * 4 | 0;\n    }\n\n    destOffset = (srcY + 1) * 4 | 0;\n    srcOffset = (srcY + 1) * srcW * 4 | 0;\n  }\n}\n\nmodule.exports = {\n  convolveHorizontally: convolveHorizontally,\n  convolveVertically: convolveVertically\n};\n\n},{}],3:[function(_dereq_,module,exports){\n/* eslint-disable max-len */\n\nmodule.exports = 'AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEXA2AAAGAGf39/f39/AGAHf39/f39/fwACDwEDZW52Bm1lbW9yeQIAAAMEAwABAgYGAX8AQQALB1cFEV9fd2FzbV9jYWxsX2N0b3JzAAAIY29udm9sdmUAAQpjb252b2x2ZUhWAAIMX19kc29faGFuZGxlAwAYX193YXNtX2FwcGx5X2RhdGFfcmVsb2NzAAAK7AMDAwABC8YDAQ9/AkAgA0UNACAERQ0AA0AgDCENQQAhE0EAIQcDQCAHQQJqIQYCfyAHQQF0IAVqIgcuAQIiFEUEQEGAwAAhCEGAwAAhCUGAwAAhCkGAwAAhCyAGDAELIBIgBy4BAGohCEEAIQsgFCEHQQAhDiAGIQlBACEPQQAhEANAIAUgCUEBdGouAQAiESAAIAhBAnRqKAIAIgpBGHZsIBBqIRAgCkH/AXEgEWwgC2ohCyAKQRB2Qf8BcSARbCAPaiEPIApBCHZB/wFxIBFsIA5qIQ4gCEEBaiEIIAlBAWohCSAHQQFrIgcNAAsgC0GAQGshCCAOQYBAayEJIA9BgEBrIQogEEGAQGshCyAGIBRqCyEHIAEgDUECdGogCUEOdSIGQf8BIAZB/wFIGyIGQQAgBkEAShtBCHRBgP4DcSAKQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG0EQdEGAgPwHcSALQQ51IgZB/wEgBkH/AUgbIgZBACAGQQBKG0EYdHJyIAhBDnUiBkH/ASAGQf8BSBsiBkEAIAZBAEobcjYCACADIA1qIQ0gE0EBaiITIARHDQALIAxBAWoiDCACbCESIAMgDEcNAAsLCx4AQQAgAiADIAQgBSAAEAEgAkEAIAQgBSAGIAEQAQs=';\n\n},{}],4:[function(_dereq_,module,exports){\n\nmodule.exports = {\n  name: 'resize',\n  fn: _dereq_('./resize'),\n  wasm_fn: _dereq_('./resize_wasm'),\n  wasm_src: _dereq_('./convolve_wasm_base64')\n};\n\n},{\"./convolve_wasm_base64\":3,\"./resize\":5,\"./resize_wasm\":8}],5:[function(_dereq_,module,exports){\n\nvar createFilters = _dereq_('./resize_filter_gen');\n\nvar convolveHorizontally = _dereq_('./convolve').convolveHorizontally;\n\nvar convolveVertically = _dereq_('./convolve').convolveVertically;\n\nfunction resetAlpha(dst, width, height) {\n  var ptr = 3,\n      len = width * height * 4 | 0;\n\n  while (ptr < len) {\n    dst[ptr] = 0xFF;\n    ptr = ptr + 4 | 0;\n  }\n}\n\nmodule.exports = function resize(options) {\n  var src = options.src;\n  var srcW = options.width;\n  var srcH = options.height;\n  var destW = options.toWidth;\n  var destH = options.toHeight;\n  var scaleX = options.scaleX || options.toWidth / options.width;\n  var scaleY = options.scaleY || options.toHeight / options.height;\n  var offsetX = options.offsetX || 0;\n  var offsetY = options.offsetY || 0;\n  var dest = options.dest || new Uint8Array(destW * destH * 4);\n  var quality = typeof options.quality === 'undefined' ? 3 : options.quality;\n  var alpha = options.alpha || false;\n  var filtersX = createFilters(quality, srcW, destW, scaleX, offsetX),\n      filtersY = createFilters(quality, srcH, destH, scaleY, offsetY);\n  var tmp = new Uint8Array(destW * srcH * 4); // To use single function we need src & tmp of the same type.\n  // But src can be CanvasPixelArray, and tmp - Uint8Array. So, keep\n  // vertical and horizontal passes separately to avoid deoptimization.\n\n  convolveHorizontally(src, tmp, srcW, srcH, destW, filtersX);\n  convolveVertically(tmp, dest, srcH, destW, destH, filtersY); // That's faster than doing checks in convolver.\n  // !!! Note, canvas data is not premultipled. We don't need other\n  // alpha corrections.\n\n  if (!alpha) resetAlpha(dest, destW, destH);\n  return dest;\n};\n\n},{\"./convolve\":2,\"./resize_filter_gen\":6}],6:[function(_dereq_,module,exports){\n\nvar FILTER_INFO = _dereq_('./resize_filter_info'); // Precision of fixed FP values\n\n\nvar FIXED_FRAC_BITS = 14;\n\nfunction toFixedPoint(num) {\n  return Math.round(num * ((1 << FIXED_FRAC_BITS) - 1));\n}\n\nmodule.exports = function resizeFilterGen(quality, srcSize, destSize, scale, offset) {\n  var filterFunction = FILTER_INFO[quality].filter;\n  var scaleInverted = 1.0 / scale;\n  var scaleClamped = Math.min(1.0, scale); // For upscale\n  // Filter window (averaging interval), scaled to src image\n\n  var srcWindow = FILTER_INFO[quality].win / scaleClamped;\n  var destPixel, srcPixel, srcFirst, srcLast, filterElementSize, floatFilter, fxpFilter, total, pxl, idx, floatVal, filterTotal, filterVal;\n  var leftNotEmpty, rightNotEmpty, filterShift, filterSize;\n  var maxFilterElementSize = Math.floor((srcWindow + 1) * 2);\n  var packedFilter = new Int16Array((maxFilterElementSize + 2) * destSize);\n  var packedFilterPtr = 0;\n  var slowCopy = !packedFilter.subarray || !packedFilter.set; // For each destination pixel calculate source range and built filter values\n\n  for (destPixel = 0; destPixel < destSize; destPixel++) {\n    // Scaling should be done relative to central pixel point\n    srcPixel = (destPixel + 0.5) * scaleInverted + offset;\n    srcFirst = Math.max(0, Math.floor(srcPixel - srcWindow));\n    srcLast = Math.min(srcSize - 1, Math.ceil(srcPixel + srcWindow));\n    filterElementSize = srcLast - srcFirst + 1;\n    floatFilter = new Float32Array(filterElementSize);\n    fxpFilter = new Int16Array(filterElementSize);\n    total = 0.0; // Fill filter values for calculated range\n\n    for (pxl = srcFirst, idx = 0; pxl <= srcLast; pxl++, idx++) {\n      floatVal = filterFunction((pxl + 0.5 - srcPixel) * scaleClamped);\n      total += floatVal;\n      floatFilter[idx] = floatVal;\n    } // Normalize filter, convert to fixed point and accumulate conversion error\n\n\n    filterTotal = 0;\n\n    for (idx = 0; idx < floatFilter.length; idx++) {\n      filterVal = floatFilter[idx] / total;\n      filterTotal += filterVal;\n      fxpFilter[idx] = toFixedPoint(filterVal);\n    } // Compensate normalization error, to minimize brightness drift\n\n\n    fxpFilter[destSize >> 1] += toFixedPoint(1.0 - filterTotal); //\n    // Now pack filter to useable form\n    //\n    // 1. Trim heading and tailing zero values, and compensate shitf/length\n    // 2. Put all to single array in this format:\n    //\n    //    [ pos shift, data length, value1, value2, value3, ... ]\n    //\n\n    leftNotEmpty = 0;\n\n    while (leftNotEmpty < fxpFilter.length && fxpFilter[leftNotEmpty] === 0) {\n      leftNotEmpty++;\n    }\n\n    if (leftNotEmpty < fxpFilter.length) {\n      rightNotEmpty = fxpFilter.length - 1;\n\n      while (rightNotEmpty > 0 && fxpFilter[rightNotEmpty] === 0) {\n        rightNotEmpty--;\n      }\n\n      filterShift = srcFirst + leftNotEmpty;\n      filterSize = rightNotEmpty - leftNotEmpty + 1;\n      packedFilter[packedFilterPtr++] = filterShift; // shift\n\n      packedFilter[packedFilterPtr++] = filterSize; // size\n\n      if (!slowCopy) {\n        packedFilter.set(fxpFilter.subarray(leftNotEmpty, rightNotEmpty + 1), packedFilterPtr);\n        packedFilterPtr += filterSize;\n      } else {\n        // fallback for old IE < 11, without subarray/set methods\n        for (idx = leftNotEmpty; idx <= rightNotEmpty; idx++) {\n          packedFilter[packedFilterPtr++] = fxpFilter[idx];\n        }\n      }\n    } else {\n      // zero data, write header only\n      packedFilter[packedFilterPtr++] = 0; // shift\n\n      packedFilter[packedFilterPtr++] = 0; // size\n    }\n  }\n\n  return packedFilter;\n};\n\n},{\"./resize_filter_info\":7}],7:[function(_dereq_,module,exports){\n\nmodule.exports = [{\n  // Nearest neibor (Box)\n  win: 0.5,\n  filter: function filter(x) {\n    return x >= -0.5 && x < 0.5 ? 1.0 : 0.0;\n  }\n}, {\n  // Hamming\n  win: 1.0,\n  filter: function filter(x) {\n    if (x <= -1.0 || x >= 1.0) {\n      return 0.0;\n    }\n\n    if (x > -1.19209290E-07 && x < 1.19209290E-07) {\n      return 1.0;\n    }\n\n    var xpi = x * Math.PI;\n    return Math.sin(xpi) / xpi * (0.54 + 0.46 * Math.cos(xpi / 1.0));\n  }\n}, {\n  // Lanczos, win = 2\n  win: 2.0,\n  filter: function filter(x) {\n    if (x <= -2.0 || x >= 2.0) {\n      return 0.0;\n    }\n\n    if (x > -1.19209290E-07 && x < 1.19209290E-07) {\n      return 1.0;\n    }\n\n    var xpi = x * Math.PI;\n    return Math.sin(xpi) / xpi * Math.sin(xpi / 2.0) / (xpi / 2.0);\n  }\n}, {\n  // Lanczos, win = 3\n  win: 3.0,\n  filter: function filter(x) {\n    if (x <= -3.0 || x >= 3.0) {\n      return 0.0;\n    }\n\n    if (x > -1.19209290E-07 && x < 1.19209290E-07) {\n      return 1.0;\n    }\n\n    var xpi = x * Math.PI;\n    return Math.sin(xpi) / xpi * Math.sin(xpi / 3.0) / (xpi / 3.0);\n  }\n}];\n\n},{}],8:[function(_dereq_,module,exports){\n\nvar createFilters = _dereq_('./resize_filter_gen');\n\nfunction resetAlpha(dst, width, height) {\n  var ptr = 3,\n      len = width * height * 4 | 0;\n\n  while (ptr < len) {\n    dst[ptr] = 0xFF;\n    ptr = ptr + 4 | 0;\n  }\n}\n\nfunction asUint8Array(src) {\n  return new Uint8Array(src.buffer, 0, src.byteLength);\n}\n\nvar IS_LE = true; // should not crash everything on module load in old browsers\n\ntry {\n  IS_LE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;\n} catch (__) {}\n\nfunction copyInt16asLE(src, target, target_offset) {\n  if (IS_LE) {\n    target.set(asUint8Array(src), target_offset);\n    return;\n  }\n\n  for (var ptr = target_offset, i = 0; i < src.length; i++) {\n    var data = src[i];\n    target[ptr++] = data & 0xFF;\n    target[ptr++] = data >> 8 & 0xFF;\n  }\n}\n\nmodule.exports = function resize_wasm(options) {\n  var src = options.src;\n  var srcW = options.width;\n  var srcH = options.height;\n  var destW = options.toWidth;\n  var destH = options.toHeight;\n  var scaleX = options.scaleX || options.toWidth / options.width;\n  var scaleY = options.scaleY || options.toHeight / options.height;\n  var offsetX = options.offsetX || 0.0;\n  var offsetY = options.offsetY || 0.0;\n  var dest = options.dest || new Uint8Array(destW * destH * 4);\n  var quality = typeof options.quality === 'undefined' ? 3 : options.quality;\n  var alpha = options.alpha || false;\n  var filtersX = createFilters(quality, srcW, destW, scaleX, offsetX),\n      filtersY = createFilters(quality, srcH, destH, scaleY, offsetY); // destination is 0 too.\n\n  var src_offset = 0; // buffer between convolve passes\n\n  var tmp_offset = this.__align(src_offset + Math.max(src.byteLength, dest.byteLength));\n\n  var filtersX_offset = this.__align(tmp_offset + srcH * destW * 4);\n\n  var filtersY_offset = this.__align(filtersX_offset + filtersX.byteLength);\n\n  var alloc_bytes = filtersY_offset + filtersY.byteLength;\n\n  var instance = this.__instance('resize', alloc_bytes); //\n  // Fill memory block with data to process\n  //\n\n\n  var mem = new Uint8Array(this.__memory.buffer);\n  var mem32 = new Uint32Array(this.__memory.buffer); // 32-bit copy is much faster in chrome\n\n  var src32 = new Uint32Array(src.buffer);\n  mem32.set(src32); // We should guarantee LE bytes order. Filters are not big, so\n  // speed difference is not significant vs direct .set()\n\n  copyInt16asLE(filtersX, mem, filtersX_offset);\n  copyInt16asLE(filtersY, mem, filtersY_offset); //\n  // Now call webassembly method\n  // emsdk does method names with '_'\n\n  var fn = instance.exports.convolveHV || instance.exports._convolveHV;\n  fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH); //\n  // Copy data back to typed array\n  //\n  // 32-bit copy is much faster in chrome\n\n  var dest32 = new Uint32Array(dest.buffer);\n  dest32.set(new Uint32Array(this.__memory.buffer, 0, destH * destW)); // That's faster than doing checks in convolver.\n  // !!! Note, canvas data is not premultipled. We don't need other\n  // alpha corrections.\n\n  if (!alpha) resetAlpha(dest, destW, destH);\n  return dest;\n};\n\n},{\"./resize_filter_gen\":6}],9:[function(_dereq_,module,exports){\n\nmodule.exports = {\n  name: 'unsharp_mask',\n  fn: _dereq_('./unsharp_mask'),\n  wasm_fn: _dereq_('./unsharp_mask_wasm'),\n  wasm_src: _dereq_('./unsharp_mask_wasm_base64')\n};\n\n},{\"./unsharp_mask\":10,\"./unsharp_mask_wasm\":11,\"./unsharp_mask_wasm_base64\":12}],10:[function(_dereq_,module,exports){\n\nvar glur_mono16 = _dereq_('glur/mono16');\n\nfunction hsv_v16(img, width, height) {\n  var size = width * height;\n  var out = new Uint16Array(size);\n  var r, g, b, max;\n\n  for (var i = 0; i < size; i++) {\n    r = img[4 * i];\n    g = img[4 * i + 1];\n    b = img[4 * i + 2];\n    max = r >= g && r >= b ? r : g >= b && g >= r ? g : b;\n    out[i] = max << 8;\n  }\n\n  return out;\n}\n\nmodule.exports = function unsharp(img, width, height, amount, radius, threshold) {\n  var v1, v2, vmul;\n  var diff, iTimes4;\n\n  if (amount === 0 || radius < 0.5) {\n    return;\n  }\n\n  if (radius > 2.0) {\n    radius = 2.0;\n  }\n\n  var brightness = hsv_v16(img, width, height);\n  var blured = new Uint16Array(brightness); // copy, because blur modify src\n\n  glur_mono16(blured, width, height, radius);\n  var amountFp = amount / 100 * 0x1000 + 0.5 | 0;\n  var thresholdFp = threshold << 8;\n  var size = width * height;\n  /* eslint-disable indent */\n\n  for (var i = 0; i < size; i++) {\n    v1 = brightness[i];\n    diff = v1 - blured[i];\n\n    if (Math.abs(diff) >= thresholdFp) {\n      // add unsharp mask to the brightness channel\n      v2 = v1 + (amountFp * diff + 0x800 >> 12); // Both v1 and v2 are within [0.0 .. 255.0] (0000-FF00) range, never going into\n      // [255.003 .. 255.996] (FF01-FFFF). This allows to round this value as (x+.5)|0\n      // later without overflowing.\n\n      v2 = v2 > 0xff00 ? 0xff00 : v2;\n      v2 = v2 < 0x0000 ? 0x0000 : v2; // Avoid division by 0. V=0 means rgb(0,0,0), unsharp with unsharpAmount>0 cannot\n      // change this value (because diff between colors gets inflated), so no need to verify correctness.\n\n      v1 = v1 !== 0 ? v1 : 1; // Multiplying V in HSV model by a constant is equivalent to multiplying each component\n      // in RGB by the same constant (same for HSL), see also:\n      // https://beesbuzz.biz/code/16-hsv-color-transforms\n\n      vmul = (v2 << 12) / v1 | 0; // Result will be in [0..255] range because:\n      //  - all numbers are positive\n      //  - r,g,b <= (v1/256)\n      //  - r,g,b,(v1/256),(v2/256) <= 255\n      // So highest this number can get is X*255/X+0.5=255.5 which is < 256 and rounds down.\n\n      iTimes4 = i * 4;\n      img[iTimes4] = img[iTimes4] * vmul + 0x800 >> 12; // R\n\n      img[iTimes4 + 1] = img[iTimes4 + 1] * vmul + 0x800 >> 12; // G\n\n      img[iTimes4 + 2] = img[iTimes4 + 2] * vmul + 0x800 >> 12; // B\n    }\n  }\n};\n\n},{\"glur/mono16\":18}],11:[function(_dereq_,module,exports){\n\nmodule.exports = function unsharp(img, width, height, amount, radius, threshold) {\n  if (amount === 0 || radius < 0.5) {\n    return;\n  }\n\n  if (radius > 2.0) {\n    radius = 2.0;\n  }\n\n  var pixels = width * height;\n  var img_bytes_cnt = pixels * 4;\n  var hsv_bytes_cnt = pixels * 2;\n  var blur_bytes_cnt = pixels * 2;\n  var blur_line_byte_cnt = Math.max(width, height) * 4; // float32 array\n\n  var blur_coeffs_byte_cnt = 8 * 4; // float32 array\n\n  var img_offset = 0;\n  var hsv_offset = img_bytes_cnt;\n  var blur_offset = hsv_offset + hsv_bytes_cnt;\n  var blur_tmp_offset = blur_offset + blur_bytes_cnt;\n  var blur_line_offset = blur_tmp_offset + blur_bytes_cnt;\n  var blur_coeffs_offset = blur_line_offset + blur_line_byte_cnt;\n\n  var instance = this.__instance('unsharp_mask', img_bytes_cnt + hsv_bytes_cnt + blur_bytes_cnt * 2 + blur_line_byte_cnt + blur_coeffs_byte_cnt, {\n    exp: Math.exp\n  }); // 32-bit copy is much faster in chrome\n\n\n  var img32 = new Uint32Array(img.buffer);\n  var mem32 = new Uint32Array(this.__memory.buffer);\n  mem32.set(img32); // HSL\n\n  var fn = instance.exports.hsv_v16 || instance.exports._hsv_v16;\n  fn(img_offset, hsv_offset, width, height); // BLUR\n\n  fn = instance.exports.blurMono16 || instance.exports._blurMono16;\n  fn(hsv_offset, blur_offset, blur_tmp_offset, blur_line_offset, blur_coeffs_offset, width, height, radius); // UNSHARP\n\n  fn = instance.exports.unsharp || instance.exports._unsharp;\n  fn(img_offset, img_offset, hsv_offset, blur_offset, width, height, amount, threshold); // 32-bit copy is much faster in chrome\n\n  img32.set(new Uint32Array(this.__memory.buffer, 0, pixels));\n};\n\n},{}],12:[function(_dereq_,module,exports){\n/* eslint-disable max-len */\n\nmodule.exports = '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';\n\n},{}],13:[function(_dereq_,module,exports){\n\nvar GC_INTERVAL = 100;\n\nfunction Pool(create, idle) {\n  this.create = create;\n  this.available = [];\n  this.acquired = {};\n  this.lastId = 1;\n  this.timeoutId = 0;\n  this.idle = idle || 2000;\n}\n\nPool.prototype.acquire = function () {\n  var _this = this;\n\n  var resource;\n\n  if (this.available.length !== 0) {\n    resource = this.available.pop();\n  } else {\n    resource = this.create();\n    resource.id = this.lastId++;\n\n    resource.release = function () {\n      return _this.release(resource);\n    };\n  }\n\n  this.acquired[resource.id] = resource;\n  return resource;\n};\n\nPool.prototype.release = function (resource) {\n  var _this2 = this;\n\n  delete this.acquired[resource.id];\n  resource.lastUsed = Date.now();\n  this.available.push(resource);\n\n  if (this.timeoutId === 0) {\n    this.timeoutId = setTimeout(function () {\n      return _this2.gc();\n    }, GC_INTERVAL);\n  }\n};\n\nPool.prototype.gc = function () {\n  var _this3 = this;\n\n  var now = Date.now();\n  this.available = this.available.filter(function (resource) {\n    if (now - resource.lastUsed > _this3.idle) {\n      resource.destroy();\n      return false;\n    }\n\n    return true;\n  });\n\n  if (this.available.length !== 0) {\n    this.timeoutId = setTimeout(function () {\n      return _this3.gc();\n    }, GC_INTERVAL);\n  } else {\n    this.timeoutId = 0;\n  }\n};\n\nmodule.exports = Pool;\n\n},{}],14:[function(_dereq_,module,exports){\n// min size = 1 can consume large amount of memory\n\nvar MIN_INNER_TILE_SIZE = 2;\n\nmodule.exports = function createStages(fromWidth, fromHeight, toWidth, toHeight, srcTileSize, destTileBorder) {\n  var scaleX = toWidth / fromWidth;\n  var scaleY = toHeight / fromHeight; // derived from createRegions equation:\n  // innerTileWidth = pixelFloor(srcTileSize * scaleX) - 2 * destTileBorder;\n\n  var minScale = (2 * destTileBorder + MIN_INNER_TILE_SIZE + 1) / srcTileSize; // refuse to scale image multiple times by less than twice each time,\n  // it could only happen because of invalid options\n\n  if (minScale > 0.5) return [[toWidth, toHeight]];\n  var stageCount = Math.ceil(Math.log(Math.min(scaleX, scaleY)) / Math.log(minScale)); // no additional resizes are necessary,\n  // stageCount can be zero or be negative when enlarging the image\n\n  if (stageCount <= 1) return [[toWidth, toHeight]];\n  var result = [];\n\n  for (var i = 0; i < stageCount; i++) {\n    var width = Math.round(Math.pow(Math.pow(fromWidth, stageCount - i - 1) * Math.pow(toWidth, i + 1), 1 / stageCount));\n    var height = Math.round(Math.pow(Math.pow(fromHeight, stageCount - i - 1) * Math.pow(toHeight, i + 1), 1 / stageCount));\n    result.push([width, height]);\n  }\n\n  return result;\n};\n\n},{}],15:[function(_dereq_,module,exports){\n/*\n * pixelFloor and pixelCeil are modified versions of Math.floor and Math.ceil\n * functions which take into account floating point arithmetic errors.\n * Those errors can cause undesired increments/decrements of sizes and offsets:\n * Math.ceil(36 / (36 / 500)) = 501\n * pixelCeil(36 / (36 / 500)) = 500\n */\n\nvar PIXEL_EPSILON = 1e-5;\n\nfunction pixelFloor(x) {\n  var nearest = Math.round(x);\n\n  if (Math.abs(x - nearest) < PIXEL_EPSILON) {\n    return nearest;\n  }\n\n  return Math.floor(x);\n}\n\nfunction pixelCeil(x) {\n  var nearest = Math.round(x);\n\n  if (Math.abs(x - nearest) < PIXEL_EPSILON) {\n    return nearest;\n  }\n\n  return Math.ceil(x);\n}\n\nmodule.exports = function createRegions(options) {\n  var scaleX = options.toWidth / options.width;\n  var scaleY = options.toHeight / options.height;\n  var innerTileWidth = pixelFloor(options.srcTileSize * scaleX) - 2 * options.destTileBorder;\n  var innerTileHeight = pixelFloor(options.srcTileSize * scaleY) - 2 * options.destTileBorder; // prevent infinite loop, this should never happen\n\n  if (innerTileWidth < 1 || innerTileHeight < 1) {\n    throw new Error('Internal error in pica: target tile width/height is too small.');\n  }\n\n  var x, y;\n  var innerX, innerY, toTileWidth, toTileHeight;\n  var tiles = [];\n  var tile; // we go top-to-down instead of left-to-right to make image displayed from top to\n  // doesn in the browser\n\n  for (innerY = 0; innerY < options.toHeight; innerY += innerTileHeight) {\n    for (innerX = 0; innerX < options.toWidth; innerX += innerTileWidth) {\n      x = innerX - options.destTileBorder;\n\n      if (x < 0) {\n        x = 0;\n      }\n\n      toTileWidth = innerX + innerTileWidth + options.destTileBorder - x;\n\n      if (x + toTileWidth >= options.toWidth) {\n        toTileWidth = options.toWidth - x;\n      }\n\n      y = innerY - options.destTileBorder;\n\n      if (y < 0) {\n        y = 0;\n      }\n\n      toTileHeight = innerY + innerTileHeight + options.destTileBorder - y;\n\n      if (y + toTileHeight >= options.toHeight) {\n        toTileHeight = options.toHeight - y;\n      }\n\n      tile = {\n        toX: x,\n        toY: y,\n        toWidth: toTileWidth,\n        toHeight: toTileHeight,\n        toInnerX: innerX,\n        toInnerY: innerY,\n        toInnerWidth: innerTileWidth,\n        toInnerHeight: innerTileHeight,\n        offsetX: x / scaleX - pixelFloor(x / scaleX),\n        offsetY: y / scaleY - pixelFloor(y / scaleY),\n        scaleX: scaleX,\n        scaleY: scaleY,\n        x: pixelFloor(x / scaleX),\n        y: pixelFloor(y / scaleY),\n        width: pixelCeil(toTileWidth / scaleX),\n        height: pixelCeil(toTileHeight / scaleY)\n      };\n      tiles.push(tile);\n    }\n  }\n\n  return tiles;\n};\n\n},{}],16:[function(_dereq_,module,exports){\n\nfunction objClass(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nmodule.exports.isCanvas = function isCanvas(element) {\n  var cname = objClass(element);\n  return cname === '[object HTMLCanvasElement]'\n  /* browser */\n  || cname === '[object OffscreenCanvas]' || cname === '[object Canvas]'\n  /* node-canvas */\n  ;\n};\n\nmodule.exports.isImage = function isImage(element) {\n  return objClass(element) === '[object HTMLImageElement]';\n};\n\nmodule.exports.isImageBitmap = function isImageBitmap(element) {\n  return objClass(element) === '[object ImageBitmap]';\n};\n\nmodule.exports.limiter = function limiter(concurrency) {\n  var active = 0,\n      queue = [];\n\n  function roll() {\n    if (active < concurrency && queue.length) {\n      active++;\n      queue.shift()();\n    }\n  }\n\n  return function limit(fn) {\n    return new Promise(function (resolve, reject) {\n      queue.push(function () {\n        fn().then(function (result) {\n          resolve(result);\n          active--;\n          roll();\n        }, function (err) {\n          reject(err);\n          active--;\n          roll();\n        });\n      });\n      roll();\n    });\n  };\n};\n\nmodule.exports.cib_quality_name = function cib_quality_name(num) {\n  switch (num) {\n    case 0:\n      return 'pixelated';\n\n    case 1:\n      return 'low';\n\n    case 2:\n      return 'medium';\n  }\n\n  return 'high';\n};\n\nmodule.exports.cib_support = function cib_support(createCanvas) {\n  return Promise.resolve().then(function () {\n    if (typeof createImageBitmap === 'undefined') {\n      return false;\n    }\n\n    var c = createCanvas(100, 100);\n    return createImageBitmap(c, 0, 0, 100, 100, {\n      resizeWidth: 10,\n      resizeHeight: 10,\n      resizeQuality: 'high'\n    }).then(function (bitmap) {\n      var status = bitmap.width === 10; // Branch below is filtered on upper level. We do not call resize\n      // detection for basic ImageBitmap.\n      //\n      // https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap\n      // old Crome 51 has ImageBitmap without .close(). Then this code\n      // will throw and return 'false' as expected.\n      //\n\n      bitmap.close();\n      c = null;\n      return status;\n    });\n  })[\"catch\"](function () {\n    return false;\n  });\n};\n\nmodule.exports.worker_offscreen_canvas_support = function worker_offscreen_canvas_support() {\n  return new Promise(function (resolve, reject) {\n    if (typeof OffscreenCanvas === 'undefined') {\n      // if OffscreenCanvas is present, we assume browser supports Worker and built-in Promise as well\n      resolve(false);\n      return;\n    }\n\n    function workerPayload(self) {\n      if (typeof createImageBitmap === 'undefined') {\n        self.postMessage(false);\n        return;\n      }\n\n      Promise.resolve().then(function () {\n        var canvas = new OffscreenCanvas(10, 10); // test that 2d context can be used in worker\n\n        var ctx = canvas.getContext('2d');\n        ctx.rect(0, 0, 1, 1); // test that cib can be used to return image bitmap from worker\n\n        return createImageBitmap(canvas, 0, 0, 1, 1);\n      }).then(function () {\n        return self.postMessage(true);\n      }, function () {\n        return self.postMessage(false);\n      });\n    }\n\n    var code = btoa(\"(\".concat(workerPayload.toString(), \")(self);\"));\n    var w = new Worker(\"data:text/javascript;base64,\".concat(code));\n\n    w.onmessage = function (ev) {\n      return resolve(ev.data);\n    };\n\n    w.onerror = reject;\n  }).then(function (result) {\n    return result;\n  }, function () {\n    return false;\n  });\n}; // Check if canvas.getContext('2d').getImageData can be used,\n// FireFox randomizes the output of that function in `privacy.resistFingerprinting` mode\n\n\nmodule.exports.can_use_canvas = function can_use_canvas(createCanvas) {\n  var usable = false;\n\n  try {\n    var canvas = createCanvas(2, 1);\n    var ctx = canvas.getContext('2d');\n    var d = ctx.createImageData(2, 1);\n    d.data[0] = 12;\n    d.data[1] = 23;\n    d.data[2] = 34;\n    d.data[3] = 255;\n    d.data[4] = 45;\n    d.data[5] = 56;\n    d.data[6] = 67;\n    d.data[7] = 255;\n    ctx.putImageData(d, 0, 0);\n    d = null;\n    d = ctx.getImageData(0, 0, 2, 1);\n\n    if (d.data[0] === 12 && d.data[1] === 23 && d.data[2] === 34 && d.data[3] === 255 && d.data[4] === 45 && d.data[5] === 56 && d.data[6] === 67 && d.data[7] === 255) {\n      usable = true;\n    }\n  } catch (err) {}\n\n  return usable;\n}; // Check if createImageBitmap(img, sx, sy, sw, sh) signature works correctly\n// with JPEG images oriented with Exif;\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1220671\n// TODO: remove after it's fixed in chrome for at least 2 releases\n\n\nmodule.exports.cib_can_use_region = function cib_can_use_region() {\n  return new Promise(function (resolve) {\n    if (typeof createImageBitmap === 'undefined') {\n      resolve(false);\n      return;\n    }\n\n    var image = new Image();\n    image.src = 'data:image/jpeg;base64,' + '/9j/4QBiRXhpZgAATU0AKgAAAAgABQESAAMAAAABAAYAAAEaAAUAAAABAAAASgEbAAUAA' + 'AABAAAAUgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAABIAAAAAQAAAEgAAAAB/9' + 'sAQwAEAwMEAwMEBAMEBQQEBQYKBwYGBgYNCQoICg8NEBAPDQ8OERMYFBESFxIODxUcFRc' + 'ZGRsbGxAUHR8dGh8YGhsa/9sAQwEEBQUGBQYMBwcMGhEPERoaGhoaGhoaGhoaGhoaGhoa' + 'GhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa/8IAEQgAAQACAwERAAIRAQMRA' + 'f/EABQAAQAAAAAAAAAAAAAAAAAAAAf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAA' + 'IQAxAAAAF/P//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAQUCf//EABQRAQAAAAA' + 'AAAAAAAAAAAAAAAD/2gAIAQMBAT8Bf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIB' + 'AT8Bf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEABj8Cf//EABQQAQAAAAAAAAAAA' + 'AAAAAAAAAD/2gAIAQEAAT8hf//aAAwDAQACAAMAAAAQH//EABQRAQAAAAAAAAAAAAAAAA' + 'AAAAD/2gAIAQMBAT8Qf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Qf//EABQ' + 'QAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8Qf//Z';\n\n    image.onload = function () {\n      createImageBitmap(image, 0, 0, image.width, image.height).then(function (bitmap) {\n        if (bitmap.width === image.width && bitmap.height === image.height) {\n          resolve(true);\n        } else {\n          resolve(false);\n        }\n      }, function () {\n        return resolve(false);\n      });\n    };\n\n    image.onerror = function () {\n      return resolve(false);\n    };\n  });\n};\n\n},{}],17:[function(_dereq_,module,exports){\n\nmodule.exports = function () {\n  var MathLib = _dereq_('./mathlib');\n\n  var mathLib;\n  /* eslint-disable no-undef */\n\n  onmessage = function onmessage(ev) {\n    var tileOpts = ev.data.opts;\n    var returnBitmap = false;\n\n    if (!tileOpts.src && tileOpts.srcBitmap) {\n      var canvas = new OffscreenCanvas(tileOpts.width, tileOpts.height);\n      var ctx = canvas.getContext('2d', {\n        alpha: Boolean(tileOpts.alpha)\n      });\n      ctx.drawImage(tileOpts.srcBitmap, 0, 0);\n      tileOpts.src = ctx.getImageData(0, 0, tileOpts.width, tileOpts.height).data;\n      canvas.width = canvas.height = 0;\n      canvas = null;\n      tileOpts.srcBitmap.close();\n      tileOpts.srcBitmap = null;\n      returnBitmap = true;\n    }\n\n    if (!mathLib) mathLib = new MathLib(ev.data.features); // Use multimath's sync auto-init. Avoid Promise use in old browsers,\n    // because polyfills are not propagated to webworker.\n\n    var data = mathLib.resizeAndUnsharp(tileOpts);\n\n    if (returnBitmap) {\n      var toImageData = new ImageData(new Uint8ClampedArray(data), tileOpts.toWidth, tileOpts.toHeight);\n\n      var _canvas = new OffscreenCanvas(tileOpts.toWidth, tileOpts.toHeight);\n\n      var _ctx = _canvas.getContext('2d', {\n        alpha: Boolean(tileOpts.alpha)\n      });\n\n      _ctx.putImageData(toImageData, 0, 0);\n\n      createImageBitmap(_canvas).then(function (bitmap) {\n        postMessage({\n          bitmap: bitmap\n        }, [bitmap]);\n      });\n    } else {\n      postMessage({\n        data: data\n      }, [data.buffer]);\n    }\n  };\n};\n\n},{\"./mathlib\":1}],18:[function(_dereq_,module,exports){\n// Calculate Gaussian blur of an image using IIR filter\n// The method is taken from Intel's white paper and code example attached to it:\n// https://software.intel.com/en-us/articles/iir-gaussian-blur-filter\n// -implementation-using-intel-advanced-vector-extensions\n\nvar a0, a1, a2, a3, b1, b2, left_corner, right_corner;\n\nfunction gaussCoef(sigma) {\n  if (sigma < 0.5) {\n    sigma = 0.5;\n  }\n\n  var a = Math.exp(0.726 * 0.726) / sigma,\n      g1 = Math.exp(-a),\n      g2 = Math.exp(-2 * a),\n      k = (1 - g1) * (1 - g1) / (1 + 2 * a * g1 - g2);\n\n  a0 = k;\n  a1 = k * (a - 1) * g1;\n  a2 = k * (a + 1) * g1;\n  a3 = -k * g2;\n  b1 = 2 * g1;\n  b2 = -g2;\n  left_corner = (a0 + a1) / (1 - b1 - b2);\n  right_corner = (a2 + a3) / (1 - b1 - b2);\n\n  // Attempt to force type to FP32.\n  return new Float32Array([ a0, a1, a2, a3, b1, b2, left_corner, right_corner ]);\n}\n\nfunction convolveMono16(src, out, line, coeff, width, height) {\n  // takes src image and writes the blurred and transposed result into out\n\n  var prev_src, curr_src, curr_out, prev_out, prev_prev_out;\n  var src_index, out_index, line_index;\n  var i, j;\n  var coeff_a0, coeff_a1, coeff_b1, coeff_b2;\n\n  for (i = 0; i < height; i++) {\n    src_index = i * width;\n    out_index = i;\n    line_index = 0;\n\n    // left to right\n    prev_src = src[src_index];\n    prev_prev_out = prev_src * coeff[6];\n    prev_out = prev_prev_out;\n\n    coeff_a0 = coeff[0];\n    coeff_a1 = coeff[1];\n    coeff_b1 = coeff[4];\n    coeff_b2 = coeff[5];\n\n    for (j = 0; j < width; j++) {\n      curr_src = src[src_index];\n\n      curr_out = curr_src * coeff_a0 +\n                 prev_src * coeff_a1 +\n                 prev_out * coeff_b1 +\n                 prev_prev_out * coeff_b2;\n\n      prev_prev_out = prev_out;\n      prev_out = curr_out;\n      prev_src = curr_src;\n\n      line[line_index] = prev_out;\n      line_index++;\n      src_index++;\n    }\n\n    src_index--;\n    line_index--;\n    out_index += height * (width - 1);\n\n    // right to left\n    prev_src = src[src_index];\n    prev_prev_out = prev_src * coeff[7];\n    prev_out = prev_prev_out;\n    curr_src = prev_src;\n\n    coeff_a0 = coeff[2];\n    coeff_a1 = coeff[3];\n\n    for (j = width - 1; j >= 0; j--) {\n      curr_out = curr_src * coeff_a0 +\n                 prev_src * coeff_a1 +\n                 prev_out * coeff_b1 +\n                 prev_prev_out * coeff_b2;\n\n      prev_prev_out = prev_out;\n      prev_out = curr_out;\n\n      prev_src = curr_src;\n      curr_src = src[src_index];\n\n      out[out_index] = line[line_index] + prev_out;\n\n      src_index--;\n      line_index--;\n      out_index -= height;\n    }\n  }\n}\n\n\nfunction blurMono16(src, width, height, radius) {\n  // Quick exit on zero radius\n  if (!radius) { return; }\n\n  var out      = new Uint16Array(src.length),\n      tmp_line = new Float32Array(Math.max(width, height));\n\n  var coeff = gaussCoef(radius);\n\n  convolveMono16(src, out, tmp_line, coeff, width, height);\n  convolveMono16(out, src, tmp_line, coeff, height, width);\n}\n\nmodule.exports = blurMono16;\n\n},{}],19:[function(_dereq_,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      var TempCtor = function () {};\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    }\n  };\n}\n\n},{}],20:[function(_dereq_,module,exports){\n\n\nvar assign         = _dereq_('object-assign');\nvar base64decode   = _dereq_('./lib/base64decode');\nvar hasWebAssembly = _dereq_('./lib/wa_detect');\n\n\nvar DEFAULT_OPTIONS = {\n  js: true,\n  wasm: true\n};\n\n\nfunction MultiMath(options) {\n  if (!(this instanceof MultiMath)) return new MultiMath(options);\n\n  var opts = assign({}, DEFAULT_OPTIONS, options || {});\n\n  this.options         = opts;\n\n  this.__cache         = {};\n\n  this.__init_promise  = null;\n  this.__modules       = opts.modules || {};\n  this.__memory        = null;\n  this.__wasm          = {};\n\n  this.__isLE = ((new Uint32Array((new Uint8Array([ 1, 0, 0, 0 ])).buffer))[0] === 1);\n\n  if (!this.options.js && !this.options.wasm) {\n    throw new Error('mathlib: at least \"js\" or \"wasm\" should be enabled');\n  }\n}\n\n\nMultiMath.prototype.has_wasm = hasWebAssembly;\n\n\nMultiMath.prototype.use = function (module) {\n  this.__modules[module.name] = module;\n\n  // Pin the best possible implementation\n  if (this.options.wasm && this.has_wasm() && module.wasm_fn) {\n    this[module.name] = module.wasm_fn;\n  } else {\n    this[module.name] = module.fn;\n  }\n\n  return this;\n};\n\n\nMultiMath.prototype.init = function () {\n  if (this.__init_promise) return this.__init_promise;\n\n  if (!this.options.js && this.options.wasm && !this.has_wasm()) {\n    return Promise.reject(new Error('mathlib: only \"wasm\" was enabled, but it\\'s not supported'));\n  }\n\n  var self = this;\n\n  this.__init_promise = Promise.all(Object.keys(self.__modules).map(function (name) {\n    var module = self.__modules[name];\n\n    if (!self.options.wasm || !self.has_wasm() || !module.wasm_fn) return null;\n\n    // If already compiled - exit\n    if (self.__wasm[name]) return null;\n\n    // Compile wasm source\n    return WebAssembly.compile(self.__base64decode(module.wasm_src))\n      .then(function (m) { self.__wasm[name] = m; });\n  }))\n    .then(function () { return self; });\n\n  return this.__init_promise;\n};\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Methods below are for internal use from plugins\n\n\n// Simple decode base64 to typed array. Useful to load embedded webassembly\n// code. You probably don't need to call this method directly.\n//\nMultiMath.prototype.__base64decode = base64decode;\n\n\n// Increase current memory to include specified number of bytes. Do nothing if\n// size is already ok. You probably don't need to call this method directly,\n// because it will be invoked from `.__instance()`.\n//\nMultiMath.prototype.__reallocate = function mem_grow_to(bytes) {\n  if (!this.__memory) {\n    this.__memory = new WebAssembly.Memory({\n      initial: Math.ceil(bytes / (64 * 1024))\n    });\n    return this.__memory;\n  }\n\n  var mem_size = this.__memory.buffer.byteLength;\n\n  if (mem_size < bytes) {\n    this.__memory.grow(Math.ceil((bytes - mem_size) / (64 * 1024)));\n  }\n\n  return this.__memory;\n};\n\n\n// Returns instantinated webassembly item by name, with specified memory size\n// and environment.\n// - use cache if available\n// - do sync module init, if async init was not called earlier\n// - allocate memory if not enougth\n// - can export functions to webassembly via \"env_extra\",\n//   for example, { exp: Math.exp }\n//\nMultiMath.prototype.__instance = function instance(name, memsize, env_extra) {\n  if (memsize) this.__reallocate(memsize);\n\n  // If .init() was not called, do sync compile\n  if (!this.__wasm[name]) {\n    var module = this.__modules[name];\n    this.__wasm[name] = new WebAssembly.Module(this.__base64decode(module.wasm_src));\n  }\n\n  if (!this.__cache[name]) {\n    var env_base = {\n      memoryBase: 0,\n      memory: this.__memory,\n      tableBase: 0,\n      table: new WebAssembly.Table({ initial: 0, element: 'anyfunc' })\n    };\n\n    this.__cache[name] = new WebAssembly.Instance(this.__wasm[name], {\n      env: assign(env_base, env_extra || {})\n    });\n  }\n\n  return this.__cache[name];\n};\n\n\n// Helper to calculate memory aligh for pointers. Webassembly does not require\n// this, but you may wish to experiment. Default base = 8;\n//\nMultiMath.prototype.__align = function align(number, base) {\n  base = base || 8;\n  var reminder = number % base;\n  return number + (reminder ? base - reminder : 0);\n};\n\n\nmodule.exports = MultiMath;\n\n},{\"./lib/base64decode\":21,\"./lib/wa_detect\":22,\"object-assign\":23}],21:[function(_dereq_,module,exports){\n\n\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n\nmodule.exports = function base64decode(str) {\n  var input = str.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max   = input.length;\n\n  var out = new Uint8Array((max * 3) >> 2);\n\n  // Collect by 6*4 bits (3 bytes)\n\n  var bits = 0;\n  var ptr  = 0;\n\n  for (var idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      out[ptr++] = (bits >> 16) & 0xFF;\n      out[ptr++] = (bits >> 8) & 0xFF;\n      out[ptr++] = bits & 0xFF;\n    }\n\n    bits = (bits << 6) | BASE64_MAP.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  var tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    out[ptr++] = (bits >> 16) & 0xFF;\n    out[ptr++] = (bits >> 8) & 0xFF;\n    out[ptr++] = bits & 0xFF;\n  } else if (tailbits === 18) {\n    out[ptr++] = (bits >> 10) & 0xFF;\n    out[ptr++] = (bits >> 2) & 0xFF;\n  } else if (tailbits === 12) {\n    out[ptr++] = (bits >> 4) & 0xFF;\n  }\n\n  return out;\n};\n\n},{}],22:[function(_dereq_,module,exports){\n\n\nvar wa;\n\n\nmodule.exports = function hasWebAssembly() {\n  // use cache if called before;\n  if (typeof wa !== 'undefined') return wa;\n\n  wa = false;\n\n  if (typeof WebAssembly === 'undefined') return wa;\n\n  // If WebAssenbly is disabled, code can throw on compile\n  try {\n    // https://github.com/brion/min-wasm-fail/blob/master/min-wasm-fail.in.js\n    // Additional check that WA internals are correct\n\n    /* eslint-disable comma-spacing, max-len */\n    var bin      = new Uint8Array([ 0,97,115,109,1,0,0,0,1,6,1,96,1,127,1,127,3,2,1,0,5,3,1,0,1,7,8,1,4,116,101,115,116,0,0,10,16,1,14,0,32,0,65,1,54,2,0,32,0,40,2,0,11 ]);\n    var module   = new WebAssembly.Module(bin);\n    var instance = new WebAssembly.Instance(module, {});\n\n    // test storing to and loading from a non-zero location via a parameter.\n    // Safari on iOS 11.2.5 returns 0 unexpectedly at non-zero locations\n    if (instance.exports.test(4) !== 0) wa = true;\n\n    return wa;\n  } catch (__) {}\n\n  return wa;\n};\n\n},{}],23:[function(_dereq_,module,exports){\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n},{}],24:[function(_dereq_,module,exports){\nvar bundleFn = arguments[3];\nvar sources = arguments[4];\nvar cache = arguments[5];\n\nvar stringify = JSON.stringify;\n\nmodule.exports = function (fn, options) {\n    var wkey;\n    var cacheKeys = Object.keys(cache);\n\n    for (var i = 0, l = cacheKeys.length; i < l; i++) {\n        var key = cacheKeys[i];\n        var exp = cache[key].exports;\n        // Using babel as a transpiler to use esmodule, the export will always\n        // be an object with the default export as a property of it. To ensure\n        // the existing api and babel esmodule exports are both supported we\n        // check for both\n        if (exp === fn || exp && exp.default === fn) {\n            wkey = key;\n            break;\n        }\n    }\n\n    if (!wkey) {\n        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n        var wcache = {};\n        for (var i = 0, l = cacheKeys.length; i < l; i++) {\n            var key = cacheKeys[i];\n            wcache[key] = key;\n        }\n        sources[wkey] = [\n            'function(require,module,exports){' + fn + '(self); }',\n            wcache\n        ];\n    }\n    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n\n    var scache = {}; scache[wkey] = wkey;\n    sources[skey] = [\n        'function(require,module,exports){' +\n            // try to call default if defined to also support babel esmodule exports\n            'var f = require(' + stringify(wkey) + ');' +\n            '(f.default ? f.default : f)(self);' +\n        '}',\n        scache\n    ];\n\n    var workerSources = {};\n    resolveSources(skey);\n\n    function resolveSources(key) {\n        workerSources[key] = true;\n\n        for (var depPath in sources[key][1]) {\n            var depKey = sources[key][1][depPath];\n            if (!workerSources[depKey]) {\n                resolveSources(depKey);\n            }\n        }\n    }\n\n    var src = '(' + bundleFn + ')({'\n        + Object.keys(workerSources).map(function (key) {\n            return stringify(key) + ':['\n                + sources[key][0]\n                + ',' + stringify(sources[key][1]) + ']'\n            ;\n        }).join(',')\n        + '},{},[' + stringify(skey) + '])'\n    ;\n\n    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n    var blob = new Blob([src], { type: 'text/javascript' });\n    if (options && options.bare) { return blob; }\n    var workerUrl = URL.createObjectURL(blob);\n    var worker = new Worker(workerUrl);\n    worker.objectURL = workerUrl;\n    return worker;\n};\n\n},{}],\"/index.js\":[function(_dereq_,module,exports){\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar assign = _dereq_('object-assign');\n\nvar webworkify = _dereq_('webworkify');\n\nvar MathLib = _dereq_('./lib/mathlib');\n\nvar Pool = _dereq_('./lib/pool');\n\nvar utils = _dereq_('./lib/utils');\n\nvar worker = _dereq_('./lib/worker');\n\nvar createStages = _dereq_('./lib/stepper');\n\nvar createRegions = _dereq_('./lib/tiler'); // Deduplicate pools & limiters with the same configs\n// when user creates multiple pica instances.\n\n\nvar singletones = {};\nvar NEED_SAFARI_FIX = false;\n\ntry {\n  if (typeof navigator !== 'undefined' && navigator.userAgent) {\n    NEED_SAFARI_FIX = navigator.userAgent.indexOf('Safari') >= 0;\n  }\n} catch (e) {}\n\nvar concurrency = 1;\n\nif (typeof navigator !== 'undefined') {\n  concurrency = Math.min(navigator.hardwareConcurrency || 1, 4);\n}\n\nvar DEFAULT_PICA_OPTS = {\n  tile: 1024,\n  concurrency: concurrency,\n  features: ['js', 'wasm', 'ww'],\n  idle: 2000,\n  createCanvas: function createCanvas(width, height) {\n    var tmpCanvas = document.createElement('canvas');\n    tmpCanvas.width = width;\n    tmpCanvas.height = height;\n    return tmpCanvas;\n  }\n};\nvar DEFAULT_RESIZE_OPTS = {\n  quality: 3,\n  alpha: false,\n  unsharpAmount: 0,\n  unsharpRadius: 0.0,\n  unsharpThreshold: 0\n};\nvar CAN_NEW_IMAGE_DATA = false;\nvar CAN_CREATE_IMAGE_BITMAP = false;\nvar CAN_USE_CANVAS_GET_IMAGE_DATA = false;\nvar CAN_USE_OFFSCREEN_CANVAS = false;\nvar CAN_USE_CIB_REGION_FOR_IMAGE = false;\n\nfunction workerFabric() {\n  return {\n    value: webworkify(worker),\n    destroy: function destroy() {\n      this.value.terminate();\n\n      if (typeof window !== 'undefined') {\n        var url = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n        if (url && url.revokeObjectURL && this.value.objectURL) {\n          url.revokeObjectURL(this.value.objectURL);\n        }\n      }\n    }\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n// API methods\n\n\nfunction Pica(options) {\n  if (!(this instanceof Pica)) return new Pica(options);\n  this.options = assign({}, DEFAULT_PICA_OPTS, options || {});\n  var limiter_key = \"lk_\".concat(this.options.concurrency); // Share limiters to avoid multiple parallel workers when user creates\n  // multiple pica instances.\n\n  this.__limit = singletones[limiter_key] || utils.limiter(this.options.concurrency);\n  if (!singletones[limiter_key]) singletones[limiter_key] = this.__limit; // List of supported features, according to options & browser/node.js\n\n  this.features = {\n    js: false,\n    // pure JS implementation, can be disabled for testing\n    wasm: false,\n    // webassembly implementation for heavy functions\n    cib: false,\n    // resize via createImageBitmap (only FF at this moment)\n    ww: false // webworkers\n\n  };\n  this.__workersPool = null; // Store requested features for webworkers\n\n  this.__requested_features = [];\n  this.__mathlib = null;\n}\n\nPica.prototype.init = function () {\n  var _this = this;\n\n  if (this.__initPromise) return this.__initPromise; // Test if we can create ImageData without canvas and memory copy\n\n  if (typeof ImageData !== 'undefined' && typeof Uint8ClampedArray !== 'undefined') {\n    try {\n      /* eslint-disable no-new */\n      new ImageData(new Uint8ClampedArray(400), 10, 10);\n      CAN_NEW_IMAGE_DATA = true;\n    } catch (__) {}\n  } // ImageBitmap can be effective in 2 places:\n  //\n  // 1. Threaded jpeg unpack (basic)\n  // 2. Built-in resize (blocked due problem in chrome, see issue #89)\n  //\n  // For basic use we also need ImageBitmap wo support .close() method,\n  // see https://developer.mozilla.org/ru/docs/Web/API/ImageBitmap\n\n\n  if (typeof ImageBitmap !== 'undefined') {\n    if (ImageBitmap.prototype && ImageBitmap.prototype.close) {\n      CAN_CREATE_IMAGE_BITMAP = true;\n    } else {\n      this.debug('ImageBitmap does not support .close(), disabled');\n    }\n  }\n\n  var features = this.options.features.slice();\n\n  if (features.indexOf('all') >= 0) {\n    features = ['cib', 'wasm', 'js', 'ww'];\n  }\n\n  this.__requested_features = features;\n  this.__mathlib = new MathLib(features); // Check WebWorker support if requested\n\n  if (features.indexOf('ww') >= 0) {\n    if (typeof window !== 'undefined' && 'Worker' in window) {\n      // IE <= 11 don't allow to create webworkers from string. We should check it.\n      // https://connect.microsoft.com/IE/feedback/details/801810/web-workers-from-blob-urls-in-ie-10-and-11\n      try {\n        var wkr = _dereq_('webworkify')(function () {});\n\n        wkr.terminate();\n        this.features.ww = true; // pool uniqueness depends on pool config + webworker config\n\n        var wpool_key = \"wp_\".concat(JSON.stringify(this.options));\n\n        if (singletones[wpool_key]) {\n          this.__workersPool = singletones[wpool_key];\n        } else {\n          this.__workersPool = new Pool(workerFabric, this.options.idle);\n          singletones[wpool_key] = this.__workersPool;\n        }\n      } catch (__) {}\n    }\n  }\n\n  var initMath = this.__mathlib.init().then(function (mathlib) {\n    // Copy detected features\n    assign(_this.features, mathlib.features);\n  });\n\n  var checkCibResize;\n\n  if (!CAN_CREATE_IMAGE_BITMAP) {\n    checkCibResize = Promise.resolve(false);\n  } else {\n    checkCibResize = utils.cib_support(this.options.createCanvas).then(function (status) {\n      if (_this.features.cib && features.indexOf('cib') < 0) {\n        _this.debug('createImageBitmap() resize supported, but disabled by config');\n\n        return;\n      }\n\n      if (features.indexOf('cib') >= 0) _this.features.cib = status;\n    });\n  }\n\n  CAN_USE_CANVAS_GET_IMAGE_DATA = utils.can_use_canvas(this.options.createCanvas);\n  var checkOffscreenCanvas;\n\n  if (CAN_CREATE_IMAGE_BITMAP && CAN_NEW_IMAGE_DATA && features.indexOf('ww') !== -1) {\n    checkOffscreenCanvas = utils.worker_offscreen_canvas_support();\n  } else {\n    checkOffscreenCanvas = Promise.resolve(false);\n  }\n\n  checkOffscreenCanvas = checkOffscreenCanvas.then(function (result) {\n    CAN_USE_OFFSCREEN_CANVAS = result;\n  }); // we use createImageBitmap to crop image data and pass it to workers,\n  // so need to check whether function works correctly;\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1220671\n\n  var checkCibRegion = utils.cib_can_use_region().then(function (result) {\n    CAN_USE_CIB_REGION_FOR_IMAGE = result;\n  }); // Init math lib. That's async because can load some\n\n  this.__initPromise = Promise.all([initMath, checkCibResize, checkOffscreenCanvas, checkCibRegion]).then(function () {\n    return _this;\n  });\n  return this.__initPromise;\n}; // Call resizer in webworker or locally, depending on config\n\n\nPica.prototype.__invokeResize = function (tileOpts, opts) {\n  var _this2 = this;\n\n  // Share cache between calls:\n  //\n  // - wasm instance\n  // - wasm memory object\n  //\n  opts.__mathCache = opts.__mathCache || {};\n  return Promise.resolve().then(function () {\n    if (!_this2.features.ww) {\n      // not possible to have ImageBitmap here if user disabled WW\n      return {\n        data: _this2.__mathlib.resizeAndUnsharp(tileOpts, opts.__mathCache)\n      };\n    }\n\n    return new Promise(function (resolve, reject) {\n      var w = _this2.__workersPool.acquire();\n\n      if (opts.cancelToken) opts.cancelToken[\"catch\"](function (err) {\n        return reject(err);\n      });\n\n      w.value.onmessage = function (ev) {\n        w.release();\n        if (ev.data.err) reject(ev.data.err);else resolve(ev.data);\n      };\n\n      var transfer = [];\n      if (tileOpts.src) transfer.push(tileOpts.src.buffer);\n      if (tileOpts.srcBitmap) transfer.push(tileOpts.srcBitmap);\n      w.value.postMessage({\n        opts: tileOpts,\n        features: _this2.__requested_features,\n        preload: {\n          wasm_nodule: _this2.__mathlib.__\n        }\n      }, transfer);\n    });\n  });\n}; // this function can return promise if createImageBitmap is used\n\n\nPica.prototype.__extractTileData = function (tile, from, opts, stageEnv, extractTo) {\n  if (this.features.ww && CAN_USE_OFFSCREEN_CANVAS && ( // createImageBitmap doesn't work for images (Image, ImageBitmap) with Exif orientation in Chrome,\n  // can use canvas because canvas doesn't have orientation;\n  // see https://bugs.chromium.org/p/chromium/issues/detail?id=1220671\n  utils.isCanvas(from) || CAN_USE_CIB_REGION_FOR_IMAGE)) {\n    this.debug('Create tile for OffscreenCanvas');\n    return createImageBitmap(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height).then(function (bitmap) {\n      extractTo.srcBitmap = bitmap;\n      return extractTo;\n    });\n  } // Extract tile RGBA buffer, depending on input type\n\n\n  if (utils.isCanvas(from)) {\n    if (!stageEnv.srcCtx) stageEnv.srcCtx = from.getContext('2d', {\n      alpha: Boolean(opts.alpha)\n    }); // If input is Canvas - extract region data directly\n\n    this.debug('Get tile pixel data');\n    extractTo.src = stageEnv.srcCtx.getImageData(tile.x, tile.y, tile.width, tile.height).data;\n    return extractTo;\n  } // If input is Image or decoded to ImageBitmap,\n  // draw region to temporary canvas and extract data from it\n  //\n  // Note! Attempt to reuse this canvas causes significant slowdown in chrome\n  //\n\n\n  this.debug('Draw tile imageBitmap/image to temporary canvas');\n  var tmpCanvas = this.options.createCanvas(tile.width, tile.height);\n  var tmpCtx = tmpCanvas.getContext('2d', {\n    alpha: Boolean(opts.alpha)\n  });\n  tmpCtx.globalCompositeOperation = 'copy';\n  tmpCtx.drawImage(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height, 0, 0, tile.width, tile.height);\n  this.debug('Get tile pixel data');\n  extractTo.src = tmpCtx.getImageData(0, 0, tile.width, tile.height).data; // Safari 12 workaround\n  // https://github.com/nodeca/pica/issues/199\n\n  tmpCanvas.width = tmpCanvas.height = 0;\n  return extractTo;\n};\n\nPica.prototype.__landTileData = function (tile, result, stageEnv) {\n  var toImageData;\n  this.debug('Convert raw rgba tile result to ImageData');\n\n  if (result.bitmap) {\n    stageEnv.toCtx.drawImage(result.bitmap, tile.toX, tile.toY);\n    return null;\n  }\n\n  if (CAN_NEW_IMAGE_DATA) {\n    // this branch is for modern browsers\n    // If `new ImageData()` & Uint8ClampedArray suported\n    toImageData = new ImageData(new Uint8ClampedArray(result.data), tile.toWidth, tile.toHeight);\n  } else {\n    // fallback for `node-canvas` and old browsers\n    // (IE11 has ImageData but does not support `new ImageData()`)\n    toImageData = stageEnv.toCtx.createImageData(tile.toWidth, tile.toHeight);\n\n    if (toImageData.data.set) {\n      toImageData.data.set(result.data);\n    } else {\n      // IE9 don't have `.set()`\n      for (var i = toImageData.data.length - 1; i >= 0; i--) {\n        toImageData.data[i] = result.data[i];\n      }\n    }\n  }\n\n  this.debug('Draw tile');\n\n  if (NEED_SAFARI_FIX) {\n    // Safari draws thin white stripes between tiles without this fix\n    stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth + 1e-5, tile.toInnerHeight + 1e-5);\n  } else {\n    stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth, tile.toInnerHeight);\n  }\n\n  return null;\n};\n\nPica.prototype.__tileAndResize = function (from, to, opts) {\n  var _this3 = this;\n\n  var stageEnv = {\n    srcCtx: null,\n    srcImageBitmap: null,\n    isImageBitmapReused: false,\n    toCtx: null\n  };\n\n  var processTile = function processTile(tile) {\n    return _this3.__limit(function () {\n      if (opts.canceled) return opts.cancelToken;\n      var tileOpts = {\n        width: tile.width,\n        height: tile.height,\n        toWidth: tile.toWidth,\n        toHeight: tile.toHeight,\n        scaleX: tile.scaleX,\n        scaleY: tile.scaleY,\n        offsetX: tile.offsetX,\n        offsetY: tile.offsetY,\n        quality: opts.quality,\n        alpha: opts.alpha,\n        unsharpAmount: opts.unsharpAmount,\n        unsharpRadius: opts.unsharpRadius,\n        unsharpThreshold: opts.unsharpThreshold\n      };\n\n      _this3.debug('Invoke resize math');\n\n      return Promise.resolve(tileOpts).then(function (tileOpts) {\n        return _this3.__extractTileData(tile, from, opts, stageEnv, tileOpts);\n      }).then(function (tileOpts) {\n        _this3.debug('Invoke resize math');\n\n        return _this3.__invokeResize(tileOpts, opts);\n      }).then(function (result) {\n        if (opts.canceled) return opts.cancelToken;\n        stageEnv.srcImageData = null;\n        return _this3.__landTileData(tile, result, stageEnv);\n      });\n    });\n  }; // Need to normalize data source first. It can be canvas or image.\n  // If image - try to decode in background if possible\n\n\n  return Promise.resolve().then(function () {\n    stageEnv.toCtx = to.getContext('2d', {\n      alpha: Boolean(opts.alpha)\n    });\n    if (utils.isCanvas(from)) return null;\n\n    if (utils.isImageBitmap(from)) {\n      stageEnv.srcImageBitmap = from;\n      stageEnv.isImageBitmapReused = true;\n      return null;\n    }\n\n    if (utils.isImage(from)) {\n      // try do decode image in background for faster next operations;\n      // if we're using offscreen canvas, cib is called per tile, so not needed here\n      if (!CAN_CREATE_IMAGE_BITMAP) return null;\n\n      _this3.debug('Decode image via createImageBitmap');\n\n      return createImageBitmap(from).then(function (imageBitmap) {\n        stageEnv.srcImageBitmap = imageBitmap;\n      }) // Suppress error to use fallback, if method fails\n      // https://github.com/nodeca/pica/issues/190\n\n      /* eslint-disable no-unused-vars */\n      [\"catch\"](function (e) {\n        return null;\n      });\n    }\n\n    throw new Error('Pica: \".from\" should be Image, Canvas or ImageBitmap');\n  }).then(function () {\n    if (opts.canceled) return opts.cancelToken;\n\n    _this3.debug('Calculate tiles'); //\n    // Here we are with \"normalized\" source,\n    // follow to tiling\n    //\n\n\n    var regions = createRegions({\n      width: opts.width,\n      height: opts.height,\n      srcTileSize: _this3.options.tile,\n      toWidth: opts.toWidth,\n      toHeight: opts.toHeight,\n      destTileBorder: opts.__destTileBorder\n    });\n    var jobs = regions.map(function (tile) {\n      return processTile(tile);\n    });\n\n    function cleanup(stageEnv) {\n      if (stageEnv.srcImageBitmap) {\n        if (!stageEnv.isImageBitmapReused) stageEnv.srcImageBitmap.close();\n        stageEnv.srcImageBitmap = null;\n      }\n    }\n\n    _this3.debug('Process tiles');\n\n    return Promise.all(jobs).then(function () {\n      _this3.debug('Finished!');\n\n      cleanup(stageEnv);\n      return to;\n    }, function (err) {\n      cleanup(stageEnv);\n      throw err;\n    });\n  });\n};\n\nPica.prototype.__processStages = function (stages, from, to, opts) {\n  var _this4 = this;\n\n  if (opts.canceled) return opts.cancelToken;\n\n  var _stages$shift = stages.shift(),\n      _stages$shift2 = _slicedToArray(_stages$shift, 2),\n      toWidth = _stages$shift2[0],\n      toHeight = _stages$shift2[1];\n\n  var isLastStage = stages.length === 0;\n  opts = assign({}, opts, {\n    toWidth: toWidth,\n    toHeight: toHeight,\n    // only use user-defined quality for the last stage,\n    // use simpler (Hamming) filter for the first stages where\n    // scale factor is large enough (more than 2-3)\n    quality: isLastStage ? opts.quality : Math.min(1, opts.quality)\n  });\n  var tmpCanvas;\n\n  if (!isLastStage) {\n    // create temporary canvas\n    tmpCanvas = this.options.createCanvas(toWidth, toHeight);\n  }\n\n  return this.__tileAndResize(from, isLastStage ? to : tmpCanvas, opts).then(function () {\n    if (isLastStage) return to;\n    opts.width = toWidth;\n    opts.height = toHeight;\n    return _this4.__processStages(stages, tmpCanvas, to, opts);\n  }).then(function (res) {\n    if (tmpCanvas) {\n      // Safari 12 workaround\n      // https://github.com/nodeca/pica/issues/199\n      tmpCanvas.width = tmpCanvas.height = 0;\n    }\n\n    return res;\n  });\n};\n\nPica.prototype.__resizeViaCreateImageBitmap = function (from, to, opts) {\n  var _this5 = this;\n\n  var toCtx = to.getContext('2d', {\n    alpha: Boolean(opts.alpha)\n  });\n  this.debug('Resize via createImageBitmap()');\n  return createImageBitmap(from, {\n    resizeWidth: opts.toWidth,\n    resizeHeight: opts.toHeight,\n    resizeQuality: utils.cib_quality_name(opts.quality)\n  }).then(function (imageBitmap) {\n    if (opts.canceled) return opts.cancelToken; // if no unsharp - draw directly to output canvas\n\n    if (!opts.unsharpAmount) {\n      toCtx.drawImage(imageBitmap, 0, 0);\n      imageBitmap.close();\n      toCtx = null;\n\n      _this5.debug('Finished!');\n\n      return to;\n    }\n\n    _this5.debug('Unsharp result');\n\n    var tmpCanvas = _this5.options.createCanvas(opts.toWidth, opts.toHeight);\n\n    var tmpCtx = tmpCanvas.getContext('2d', {\n      alpha: Boolean(opts.alpha)\n    });\n    tmpCtx.drawImage(imageBitmap, 0, 0);\n    imageBitmap.close();\n    var iData = tmpCtx.getImageData(0, 0, opts.toWidth, opts.toHeight);\n\n    _this5.__mathlib.unsharp_mask(iData.data, opts.toWidth, opts.toHeight, opts.unsharpAmount, opts.unsharpRadius, opts.unsharpThreshold);\n\n    toCtx.putImageData(iData, 0, 0); // Safari 12 workaround\n    // https://github.com/nodeca/pica/issues/199\n\n    tmpCanvas.width = tmpCanvas.height = 0;\n    iData = tmpCtx = tmpCanvas = toCtx = null;\n\n    _this5.debug('Finished!');\n\n    return to;\n  });\n};\n\nPica.prototype.resize = function (from, to, options) {\n  var _this6 = this;\n\n  this.debug('Start resize...');\n  var opts = assign({}, DEFAULT_RESIZE_OPTS);\n\n  if (!isNaN(options)) {\n    opts = assign(opts, {\n      quality: options\n    });\n  } else if (options) {\n    opts = assign(opts, options);\n  }\n\n  opts.toWidth = to.width;\n  opts.toHeight = to.height;\n  opts.width = from.naturalWidth || from.width;\n  opts.height = from.naturalHeight || from.height; // Prevent stepper from infinite loop\n\n  if (to.width === 0 || to.height === 0) {\n    return Promise.reject(new Error(\"Invalid output size: \".concat(to.width, \"x\").concat(to.height)));\n  }\n\n  if (opts.unsharpRadius > 2) opts.unsharpRadius = 2;\n  opts.canceled = false;\n\n  if (opts.cancelToken) {\n    // Wrap cancelToken to avoid successive resolve & set flag\n    opts.cancelToken = opts.cancelToken.then(function (data) {\n      opts.canceled = true;\n      throw data;\n    }, function (err) {\n      opts.canceled = true;\n      throw err;\n    });\n  }\n\n  var DEST_TILE_BORDER = 3; // Max possible filter window size\n\n  opts.__destTileBorder = Math.ceil(Math.max(DEST_TILE_BORDER, 2.5 * opts.unsharpRadius | 0));\n  return this.init().then(function () {\n    if (opts.canceled) return opts.cancelToken; // if createImageBitmap supports resize, just do it and return\n\n    if (_this6.features.cib) {\n      return _this6.__resizeViaCreateImageBitmap(from, to, opts);\n    }\n\n    if (!CAN_USE_CANVAS_GET_IMAGE_DATA) {\n      var err = new Error('Pica: cannot use getImageData on canvas, ' + \"make sure fingerprinting protection isn't enabled\");\n      err.code = 'ERR_GET_IMAGE_DATA';\n      throw err;\n    } //\n    // No easy way, let's resize manually via arrays\n    //\n\n\n    var stages = createStages(opts.width, opts.height, opts.toWidth, opts.toHeight, _this6.options.tile, opts.__destTileBorder);\n    return _this6.__processStages(stages, from, to, opts);\n  });\n}; // RGBA buffer resize\n//\n\n\nPica.prototype.resizeBuffer = function (options) {\n  var _this7 = this;\n\n  var opts = assign({}, DEFAULT_RESIZE_OPTS, options);\n  return this.init().then(function () {\n    return _this7.__mathlib.resizeAndUnsharp(opts);\n  });\n};\n\nPica.prototype.toBlob = function (canvas, mimeType, quality) {\n  mimeType = mimeType || 'image/png';\n  return new Promise(function (resolve) {\n    if (canvas.toBlob) {\n      canvas.toBlob(function (blob) {\n        return resolve(blob);\n      }, mimeType, quality);\n      return;\n    }\n\n    if (canvas.convertToBlob) {\n      resolve(canvas.convertToBlob({\n        type: mimeType,\n        quality: quality\n      }));\n      return;\n    } // Fallback for old browsers\n\n\n    var asString = atob(canvas.toDataURL(mimeType, quality).split(',')[1]);\n    var len = asString.length;\n    var asBuffer = new Uint8Array(len);\n\n    for (var i = 0; i < len; i++) {\n      asBuffer[i] = asString.charCodeAt(i);\n    }\n\n    resolve(new Blob([asBuffer], {\n      type: mimeType\n    }));\n  });\n};\n\nPica.prototype.debug = function () {};\n\nmodule.exports = Pica;\n\n},{\"./lib/mathlib\":1,\"./lib/pool\":13,\"./lib/stepper\":14,\"./lib/tiler\":15,\"./lib/utils\":16,\"./lib/worker\":17,\"object-assign\":23,\"webworkify\":24}]},{},[])(\"/index.js\")\n});\n});\n\nvar image_traverse = createCommonjsModule(function (module) {\n\n//////////////////////////////////////////////////////////////////////////\n// Helpers\n//\nfunction error(message, code) {\n  var err = new Error(message);\n  err.code = code;\n  return err;\n}\n\n\n// Convert number to 0xHH string\n//\nfunction to_hex(number) {\n  var n = number.toString(16).toUpperCase();\n  for (var i = 2 - n.length; i > 0; i--) n = '0' + n;\n  return '0x' + n;\n}\n\n\nfunction utf8_encode(str) {\n  try {\n    return unescape(encodeURIComponent(str));\n  } catch (_) {\n    return str;\n  }\n}\n\n\nfunction utf8_decode(str) {\n  try {\n    return decodeURIComponent(escape(str));\n  } catch (_) {\n    return str;\n  }\n}\n\n\n// Check if input is a Uint8Array\n//\nfunction is_uint8array(bin) {\n  return Object.prototype.toString.call(bin) === '[object Uint8Array]';\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n// Exif parser\n//\n// Input:\n//  - jpeg_bin:   Uint8Array - jpeg file\n//  - exif_start: Number     - start of TIFF header (after Exif\\0\\0)\n//  - exif_end:   Number     - end of Exif segment\n//  - on_entry:   Number     - callback\n//\nfunction ExifParser(jpeg_bin, exif_start, exif_end) {\n  // Uint8Array, exif without signature (which isn't included in offsets)\n  this.input      = jpeg_bin.subarray(exif_start, exif_end);\n\n  // offset correction for `on_entry` callback\n  this.start      = exif_start;\n\n  // Check TIFF header (includes byte alignment and first IFD offset)\n  var sig = String.fromCharCode.apply(null, this.input.subarray(0, 4));\n\n  if (sig !== 'II\\x2A\\0' && sig !== 'MM\\0\\x2A') {\n    throw error('invalid TIFF signature', 'EBADDATA');\n  }\n\n  // true if motorola (big endian) byte alignment, false if intel\n  this.big_endian = sig[0] === 'M';\n}\n\n\nExifParser.prototype.each = function (on_entry) {\n  // allow premature exit\n  this.aborted = false;\n\n  var offset = this.read_uint32(4);\n\n  this.ifds_to_read = [ {\n    id:     0,\n    offset: offset\n  } ];\n\n  while (this.ifds_to_read.length > 0 && !this.aborted) {\n    var i = this.ifds_to_read.shift();\n    if (!i.offset) continue;\n    this.scan_ifd(i.id, i.offset, on_entry);\n  }\n};\n\n\nExifParser.prototype.filter = function (on_entry) {\n  var ifds = {};\n\n  // make sure IFD0 always exists\n  ifds.ifd0 = { id: 0, entries: [] };\n\n  this.each(function (entry) {\n    if (on_entry(entry) === false && !entry.is_subifd_link) return;\n    if (entry.is_subifd_link && entry.count !== 1 && entry.format !== 4) return; // filter out bogus links\n\n    if (!ifds['ifd' + entry.ifd]) {\n      ifds['ifd' + entry.ifd] = { id: entry.ifd, entries: [] };\n    }\n\n    ifds['ifd' + entry.ifd].entries.push(entry);\n  });\n\n  // thumbnails are not supported just yet, so delete all information related to it\n  delete ifds.ifd1;\n\n  // Calculate output size\n  var length = 8;\n  Object.keys(ifds).forEach(function (ifd_no) {\n    length += 2;\n\n    ifds[ifd_no].entries.forEach(function (entry) {\n      length += 12 + (entry.data_length > 4 ? Math.ceil(entry.data_length / 2) * 2 : 0);\n    });\n\n    length += 4;\n  });\n\n  this.output = new Uint8Array(length);\n  this.output[0] = this.output[1] = (this.big_endian ? 'M' : 'I').charCodeAt(0);\n  this.write_uint16(2, 0x2A);\n\n  var offset = 8;\n  var self = this;\n  this.write_uint32(4, offset);\n\n  Object.keys(ifds).forEach(function (ifd_no) {\n    ifds[ifd_no].written_offset = offset;\n\n    var ifd_start = offset;\n    var ifd_end   = ifd_start + 2 + ifds[ifd_no].entries.length * 12 + 4;\n    offset = ifd_end;\n\n    self.write_uint16(ifd_start, ifds[ifd_no].entries.length);\n\n    ifds[ifd_no].entries.sort(function (a, b) {\n      // IFD entries must be in order of increasing tag IDs\n      return a.tag - b.tag;\n    }).forEach(function (entry, idx) {\n      var entry_offset = ifd_start + 2 + idx * 12;\n\n      self.write_uint16(entry_offset, entry.tag);\n      self.write_uint16(entry_offset + 2, entry.format);\n      self.write_uint32(entry_offset + 4, entry.count);\n\n      if (entry.is_subifd_link) {\n        // filled in later\n        if (ifds['ifd' + entry.tag]) ifds['ifd' + entry.tag].link_offset = entry_offset + 8;\n      } else if (entry.data_length <= 4) {\n        self.output.set(\n          self.input.subarray(entry.data_offset - self.start, entry.data_offset - self.start + 4),\n          entry_offset + 8\n        );\n      } else {\n        self.write_uint32(entry_offset + 8, offset);\n        self.output.set(\n          self.input.subarray(entry.data_offset - self.start, entry.data_offset - self.start + entry.data_length),\n          offset\n        );\n        offset += Math.ceil(entry.data_length / 2) * 2;\n      }\n    });\n\n    var next_ifd = ifds['ifd' + (ifds[ifd_no].id + 1)];\n    if (next_ifd) next_ifd.link_offset = ifd_end - 4;\n  });\n\n  Object.keys(ifds).forEach(function (ifd_no) {\n    if (ifds[ifd_no].written_offset && ifds[ifd_no].link_offset) {\n      self.write_uint32(ifds[ifd_no].link_offset, ifds[ifd_no].written_offset);\n    }\n  });\n\n  if (this.output.length !== offset) throw error('internal error: incorrect buffer size allocated');\n\n  return this.output;\n};\n\n\nExifParser.prototype.read_uint16 = function (offset) {\n  var d = this.input;\n  if (offset + 2 > d.length) throw error('unexpected EOF', 'EBADDATA');\n\n  return this.big_endian ?\n    d[offset] * 0x100 + d[offset + 1] :\n    d[offset] + d[offset + 1] * 0x100;\n};\n\n\nExifParser.prototype.read_uint32 = function (offset) {\n  var d = this.input;\n  if (offset + 4 > d.length) throw error('unexpected EOF', 'EBADDATA');\n\n  return this.big_endian ?\n    d[offset] * 0x1000000 + d[offset + 1] * 0x10000 + d[offset + 2] * 0x100 + d[offset + 3] :\n    d[offset] + d[offset + 1] * 0x100 + d[offset + 2] * 0x10000 + d[offset + 3] * 0x1000000;\n};\n\n\nExifParser.prototype.write_uint16 = function (offset, value) {\n  var d = this.output;\n\n  if (this.big_endian) {\n    d[offset]     = (value >>> 8) & 0xFF;\n    d[offset + 1] = value & 0xFF;\n  } else {\n    d[offset]     = value & 0xFF;\n    d[offset + 1] = (value >>> 8) & 0xFF;\n  }\n};\n\n\nExifParser.prototype.write_uint32 = function (offset, value) {\n  var d = this.output;\n\n  if (this.big_endian) {\n    d[offset]     = (value >>> 24) & 0xFF;\n    d[offset + 1] = (value >>> 16) & 0xFF;\n    d[offset + 2] = (value >>> 8) & 0xFF;\n    d[offset + 3] = value & 0xFF;\n  } else {\n    d[offset]     = value & 0xFF;\n    d[offset + 1] = (value >>> 8) & 0xFF;\n    d[offset + 2] = (value >>> 16) & 0xFF;\n    d[offset + 3] = (value >>> 24) & 0xFF;\n  }\n};\n\n\nExifParser.prototype.is_subifd_link = function (ifd, tag) {\n  return (ifd === 0 && tag === 0x8769) || // SubIFD\n         (ifd === 0 && tag === 0x8825) || // GPS Info\n         (ifd === 0x8769 && tag === 0xA005); // Interop IFD\n};\n\n\n// Returns byte length of a single component of a given format\n//\nExifParser.prototype.exif_format_length = function (format) {\n  switch (format) {\n    case 1: // byte\n    case 2: // ascii\n    case 6: // sbyte\n    case 7: // undefined\n      return 1;\n\n    case 3: // short\n    case 8: // sshort\n      return 2;\n\n    case 4:  // long\n    case 9:  // slong\n    case 11: // float\n      return 4;\n\n    case 5:  // rational\n    case 10: // srational\n    case 12: // double\n      return 8;\n\n    default:\n      // unknown type\n      return 0;\n  }\n};\n\n\n// Reads Exif data\n//\nExifParser.prototype.exif_format_read = function (format, offset) {\n  var v;\n\n  switch (format) {\n    case 1: // byte\n    case 2: // ascii\n      v = this.input[offset];\n      return v;\n\n    case 6: // sbyte\n      v = this.input[offset];\n      return v | (v & 0x80) * 0x1fffffe;\n\n    case 3: // short\n      v = this.read_uint16(offset);\n      return v;\n\n    case 8: // sshort\n      v = this.read_uint16(offset);\n      return v | (v & 0x8000) * 0x1fffe;\n\n    case 4: // long\n      v = this.read_uint32(offset);\n      return v;\n\n    case 9: // slong\n      v = this.read_uint32(offset);\n      return v | 0;\n\n    case 5:  // rational\n    case 10: // srational\n    case 11: // float\n    case 12: // double\n      return null; // not implemented\n\n    case 7: // undefined\n      return null; // blob\n\n    default:\n      // unknown type\n      return null;\n  }\n};\n\n\nExifParser.prototype.scan_ifd = function (ifd_no, offset, on_entry) {\n  var entry_count = this.read_uint16(offset);\n\n  offset += 2;\n\n  for (var i = 0; i < entry_count; i++) {\n    var tag    = this.read_uint16(offset);\n    var format = this.read_uint16(offset + 2);\n    var count  = this.read_uint32(offset + 4);\n\n    var comp_length    = this.exif_format_length(format);\n    var data_length    = count * comp_length;\n    var data_offset    = data_length <= 4 ? offset + 8 : this.read_uint32(offset + 8);\n    var is_subifd_link = false;\n\n    if (data_offset + data_length > this.input.length) {\n      throw error('unexpected EOF', 'EBADDATA');\n    }\n\n    var value = [];\n    var comp_offset = data_offset;\n\n    for (var j = 0; j < count; j++, comp_offset += comp_length) {\n      var item = this.exif_format_read(format, comp_offset);\n      if (item === null) {\n        value = null;\n        break;\n      }\n      value.push(item);\n    }\n\n    if (Array.isArray(value) && format === 2) {\n      try {\n        value = utf8_decode(String.fromCharCode.apply(null, value));\n      } catch (_) {\n        value = null;\n      }\n\n      if (value && value[value.length - 1] === '\\0') value = value.slice(0, -1);\n    }\n\n    if (this.is_subifd_link(ifd_no, tag)) {\n      if (Array.isArray(value) && Number.isInteger(value[0]) && value[0] > 0) {\n        this.ifds_to_read.push({\n          id:     tag,\n          offset: value[0]\n        });\n        is_subifd_link = true;\n      }\n    }\n\n    var entry = {\n      is_big_endian:  this.big_endian,\n      ifd:            ifd_no,\n      tag:            tag,\n      format:         format,\n      count:          count,\n      entry_offset:   offset + this.start,\n      data_length:    data_length,\n      data_offset:    data_offset + this.start,\n      value:          value,\n      is_subifd_link: is_subifd_link\n    };\n\n    if (on_entry(entry) === false) {\n      this.aborted = true;\n      return;\n    }\n\n    offset += 12;\n  }\n\n  if (ifd_no === 0) {\n    this.ifds_to_read.push({\n      id:     1,\n      offset: this.read_uint32(offset)\n    });\n  }\n};\n\n\n// Check whether input is a JPEG image\n//\n// Input:\n//  - jpeg_bin: Uint8Array - jpeg file\n//\n// Returns true if it is and false otherwise\n//\nmodule.exports.is_jpeg = function (jpeg_bin) {\n  return jpeg_bin.length >= 4 && jpeg_bin[0] === 0xFF && jpeg_bin[1] === 0xD8 && jpeg_bin[2] === 0xFF;\n};\n\n\n// Call an iterator on each segment in the given JPEG image\n//\n// Input:\n//  - jpeg_bin:   Uint8Array - jpeg file\n//  - on_segment: Function - callback executed on each JPEG marker segment\n//    - segment:  Object\n//      - code:   Number - marker type (2nd byte, e.g. 0xE0 for APP0)\n//      - offset: Number - offset of the first byte (0xFF) relative to `jpeg_bin` start\n//      - length: Number - length of the entire marker segment including first two bytes and length\n//        - 2 for standalone markers\n//        - 4+length for markers with data\n//\n// Iteration stops when `EOI` (0xFFD9) marker is reached or if `on_segment`\n// function returns `false`.\n//\nmodule.exports.jpeg_segments_each = function (jpeg_bin, on_segment) {\n  if (!is_uint8array(jpeg_bin)) {\n    throw error('Invalid argument (jpeg_bin), Uint8Array expected', 'EINVAL');\n  }\n\n  if (typeof on_segment !== 'function') {\n    throw error('Invalid argument (on_segment), Function expected', 'EINVAL');\n  }\n\n  if (!module.exports.is_jpeg(jpeg_bin)) {\n    throw error('Unknown file format', 'ENOTJPEG');\n  }\n\n  var offset = 0, length = jpeg_bin.length, inside_scan = false;\n\n  for (;;) {\n    var segment_code, segment_length;\n\n    if (offset + 1 >= length) throw error('Unexpected EOF', 'EBADDATA');\n    var byte1 = jpeg_bin[offset];\n    var byte2 = jpeg_bin[offset + 1];\n\n    if (byte1 === 0xFF && byte2 === 0xFF) {\n      // padding\n      segment_code = 0xFF;\n      segment_length = 1;\n\n    } else if (byte1 === 0xFF && byte2 !== 0) {\n      // marker\n      segment_code = byte2;\n      segment_length = 2;\n\n      if ((0xD0 <= segment_code && segment_code <= 0xD9) || segment_code === 0x01) ; else {\n        if (offset + 3 >= length) throw error('Unexpected EOF', 'EBADDATA');\n        segment_length += jpeg_bin[offset + 2] * 0x100 + jpeg_bin[offset + 3];\n        if (segment_length < 2) throw error('Invalid segment length', 'EBADDATA');\n        if (offset + segment_length - 1 >= length) throw error('Unexpected EOF', 'EBADDATA');\n      }\n\n      if (inside_scan) {\n        if (segment_code >= 0xD0 && segment_code <= 0xD7) ; else {\n          inside_scan = false;\n        }\n      }\n\n      if (segment_code === 0xDA /* SOS */) inside_scan = true;\n    } else if (inside_scan) {\n      // entropy-encoded segment\n      for (var pos = offset + 1; ; pos++) {\n        // scan until we find FF\n        if (pos >= length) throw error('Unexpected EOF', 'EBADDATA');\n        if (jpeg_bin[pos] === 0xFF) {\n          if (pos + 1 >= length) throw error('Unexpected EOF', 'EBADDATA');\n          if (jpeg_bin[pos + 1] !== 0) {\n            segment_code = 0;\n            segment_length = pos - offset;\n            break;\n          }\n        }\n      }\n    } else {\n      throw error('Unexpected byte at segment start: ' + to_hex(byte1) +\n        ' (offset ' + to_hex(offset) + ')', 'EBADDATA');\n    }\n\n    if (on_segment({ code: segment_code, offset: offset, length: segment_length }) === false) break;\n    if (segment_code === 0xD9 /* EOI */) break;\n    offset += segment_length;\n  }\n};\n\n\n// Replace or remove segments in the given JPEG image\n//\n// Input:\n//  - jpeg_bin:   Uint8Array - jpeg file\n//  - on_segment: Function - callback executed on each JPEG marker segment\n//    - segment:  Object\n//      - code:   Number - marker type (2nd byte, e.g. 0xE0 for APP0)\n//      - offset: Number - offset of the first byte (0xFF) relative to `jpeg_bin` start\n//      - length: Number - length of the entire marker segment including first two bytes and length\n//        - 2 for standalone markers\n//        - 4+length for markers with data\n//\n// `on_segment` function should return one of the following:\n//  - `false`        - segment is removed from the output\n//  - Uint8Array     - segment is replaced with the new data\n//  - [ Uint8Array ] - segment is replaced with the new data\n//  - anything else  - segment is copied to the output as is\n//\n// Any data after `EOI` (0xFFD9) marker is removed.\n//\nmodule.exports.jpeg_segments_filter = function (jpeg_bin, on_segment) {\n  if (!is_uint8array(jpeg_bin)) {\n    throw error('Invalid argument (jpeg_bin), Uint8Array expected', 'EINVAL');\n  }\n\n  if (typeof on_segment !== 'function') {\n    throw error('Invalid argument (on_segment), Function expected', 'EINVAL');\n  }\n\n  var ranges = [];\n  var out_length = 0;\n\n  module.exports.jpeg_segments_each(jpeg_bin, function (segment) {\n    var new_segment = on_segment(segment);\n\n    if (is_uint8array(new_segment)) {\n      ranges.push({ data: new_segment });\n      out_length += new_segment.length;\n    } else if (Array.isArray(new_segment)) {\n      new_segment.filter(is_uint8array).forEach(function (s) {\n        ranges.push({ data: s });\n        out_length += s.length;\n      });\n    } else if (new_segment !== false) {\n      var new_range = { start: segment.offset, end: segment.offset + segment.length };\n\n      if (ranges.length > 0 && ranges[ranges.length - 1].end === new_range.start) {\n        ranges[ranges.length - 1].end = new_range.end;\n      } else {\n        ranges.push(new_range);\n      }\n\n      out_length += segment.length;\n    }\n  });\n\n  var result = new Uint8Array(out_length);\n  var offset = 0;\n\n  ranges.forEach(function (range) {\n    var data = range.data || jpeg_bin.subarray(range.start, range.end);\n    result.set(data, offset);\n    offset += data.length;\n  });\n\n  return result;\n};\n\n\n// Call an iterator on each Exif entry in the given JPEG image\n//\n// Input:\n//  - jpeg_bin: Uint8Array - jpeg file\n//  - on_entry: Function - callback executed on each Exif entry\n//    - entry:  Object\n//      - is_big_endian:  Boolean - whether Exif uses big or little endian byte alignment\n//      - ifd:            Number  - IFD identifier (0 for IFD0, 1 for IFD1, 0x8769 for SubIFD,\n//                                 0x8825 for GPS Info, 0xA005 for Interop IFD)\n//      - tag:            Number  - exif entry tag (0x0110 - camera name, 0x0112 - orientation, etc. - see Exif spec)\n//      - format:         Number  - exif entry format (1 - byte, 2 - ascii, 3 - short, etc. - see Exif spec)\n//      - count:          Number  - number of components of the given format inside data\n//                                 (usually 1, or string length for ascii format)\n//      - entry_offset:   Number  - start of Exif entry (entry length is always 12, so not included)\n//      - data_offset:    Number  - start of data attached to Exif entry (will overlap with entry if length <= 4)\n//      - data_length:    Number  - length of data attached to Exif entry\n//      - value:          Array|String|Null - our best attempt at parsing data (not all formats supported right now)\n//      - is_subifd_link: Boolean - whether this entry is recognized to be a link to subifd (can't filter these out)\n//\n// Iteration stops early if iterator returns `false`.\n//\n// If Exif wasn't found anywhere (before start of the image data, SOS),\n// iterator is never executed.\n//\nmodule.exports.jpeg_exif_tags_each = function (jpeg_bin, on_exif_entry) {\n  if (!is_uint8array(jpeg_bin)) {\n    throw error('Invalid argument (jpeg_bin), Uint8Array expected', 'EINVAL');\n  }\n\n  if (typeof on_exif_entry !== 'function') {\n    throw error('Invalid argument (on_exif_entry), Function expected', 'EINVAL');\n  }\n\n  /* eslint-disable consistent-return */\n  module.exports.jpeg_segments_each(jpeg_bin, function (segment) {\n    if (segment.code === 0xDA /* SOS */) return false;\n\n    // look for APP1 segment and compare header with 'Exif\\0\\0'\n    if (segment.code === 0xE1 && segment.length >= 10 &&\n        jpeg_bin[segment.offset + 4] === 0x45 && jpeg_bin[segment.offset + 5] === 0x78 &&\n        jpeg_bin[segment.offset + 6] === 0x69 && jpeg_bin[segment.offset + 7] === 0x66 &&\n        jpeg_bin[segment.offset + 8] === 0x00 && jpeg_bin[segment.offset + 9] === 0x00) {\n\n      new ExifParser(jpeg_bin, segment.offset + 10, segment.offset + segment.length).each(on_exif_entry);\n      return false;\n    }\n  });\n};\n\n\n// Remove Exif entries in the given JPEG image\n//\n// Input:\n//  - jpeg_bin: Uint8Array - jpeg file\n//  - on_entry: Function - callback executed on each Exif entry\n//    - entry:  Object\n//      - is_big_endian:  Boolean - whether Exif uses big or little endian byte alignment\n//      - ifd:            Number  - IFD identifier (0 for IFD0, 1 for IFD1, 0x8769 for SubIFD,\n//                                  0x8825 for GPS Info, 0xA005 for Interop IFD)\n//      - tag:            Number  - exif entry tag (0x0110 - camera name, 0x0112 - orientation, etc. - see Exif spec)\n//      - format:         Number  - exif entry format (1 - byte, 2 - ascii, 3 - short, etc. - see Exif spec)\n//      - count:          Number  - number of components of the given format inside data\n//                                  (usually 1, or string length for ascii format)\n//      - entry_offset:   Number  - start of Exif entry (entry length is always 12, so not included)\n//      - data_offset:    Number  - start of data attached to Exif entry (will overlap with entry if length <= 4)\n//      - data_length:    Number  - length of data attached to Exif entry\n//      - value:          Array|String|Null - our best attempt at parsing data (not all formats supported right now)\n//      - is_subifd_link: Boolean - whether this entry is recognized to be a link to subifd (can't filter these out)\n//\n// This function removes following from Exif:\n//  - all entries where iterator returned false (except subifd links which are mandatory)\n//  - IFD1 and thumbnail image (the purpose of this function is to reduce file size,\n//    so thumbnail is usually the first thing to go)\n//  - all other data that isn't in IFD0, SubIFD, GPSIFD, InteropIFD\n//    (theoretically possible proprietary extensions, I haven't seen any of these yet)\n//\n// Changing data inside Exif entries is NOT supported yet (modifying `entry` object inside callback may break stuff).\n//\n// If Exif wasn't found anywhere (before start of the image data, SOS),\n// iterator is never executed, and original JPEG is returned as is.\n//\nmodule.exports.jpeg_exif_tags_filter = function (jpeg_bin, on_exif_entry) {\n  if (!is_uint8array(jpeg_bin)) {\n    throw error('Invalid argument (jpeg_bin), Uint8Array expected', 'EINVAL');\n  }\n\n  if (typeof on_exif_entry !== 'function') {\n    throw error('Invalid argument (on_exif_entry), Function expected', 'EINVAL');\n  }\n\n  var stop_search = false;\n\n  return module.exports.jpeg_segments_filter(jpeg_bin, function (segment) {\n    if (stop_search) return;\n    if (segment.code === 0xDA /* SOS */) stop_search = true;\n\n    // look for APP1 segment and compare header with 'Exif\\0\\0'\n    if (segment.code === 0xE1 && segment.length >= 10 &&\n        jpeg_bin[segment.offset + 4] === 0x45 && jpeg_bin[segment.offset + 5] === 0x78 &&\n        jpeg_bin[segment.offset + 6] === 0x69 && jpeg_bin[segment.offset + 7] === 0x66 &&\n        jpeg_bin[segment.offset + 8] === 0x00 && jpeg_bin[segment.offset + 9] === 0x00) {\n\n      var new_exif = new ExifParser(jpeg_bin, segment.offset + 10, segment.offset + segment.length)\n        .filter(on_exif_entry);\n      if (!new_exif) return false;\n\n      var header = new Uint8Array(10);\n\n      header.set(jpeg_bin.slice(segment.offset, segment.offset + 10));\n      header[2] = ((new_exif.length + 8) >>> 8) & 0xFF;\n      header[3] = (new_exif.length + 8) & 0xFF;\n\n      stop_search = true;\n      return [ header, new_exif ];\n    }\n  });\n};\n\n\n// Inserts a custom comment marker segment into JPEG file.\n//\n// Input:\n//  - jpeg_bin: Uint8Array - jpeg file\n//  - comment:  String\n//\n// Comment is inserted after first two bytes (FFD8, SOI).\n//\n// If JFIF (APP0) marker exists immediately after SOI (as mandated by the JFIF\n// spec), we insert comment after it instead.\n//\nmodule.exports.jpeg_add_comment = function (jpeg_bin, comment) {\n  var comment_inserted = false, segment_count = 0;\n\n  return module.exports.jpeg_segments_filter(jpeg_bin, function (segment) {\n    segment_count++;\n    if (segment_count === 1 && segment.code === 0xD8 /* SOI  */) return;\n    if (segment_count === 2 && segment.code === 0xE0 /* APP0 */) return;\n\n    if (comment_inserted) return;\n    comment = utf8_encode(comment);\n\n    // comment segment\n    var csegment = new Uint8Array(5 + comment.length);\n    var offset = 0;\n\n    csegment[offset++] = 0xFF;\n    csegment[offset++] = 0xFE;\n    csegment[offset++] = ((comment.length + 3) >>> 8) & 0xFF;\n    csegment[offset++] = (comment.length + 3) & 0xFF;\n\n    comment.split('').forEach(function (c) {\n      csegment[offset++] = c.charCodeAt(0) & 0xFF;\n    });\n\n    csegment[offset++] = 0;\n    comment_inserted = true;\n\n    return [ csegment, jpeg_bin.subarray(segment.offset, segment.offset + segment.length) ];\n  });\n};\n});\n\nfunction jpeg_patch_exif(env) {\n  return this._getUint8Array(env.blob).then(function (data) {\n    env.is_jpeg = image_traverse.is_jpeg(data);\n\n    if (!env.is_jpeg) return Promise.resolve(env);\n\n    env.orig_blob = env.blob;\n\n    try {\n      var exif_is_big_endian, orientation_offset;\n\n      /* eslint-disable consistent-return */\n      image_traverse.jpeg_exif_tags_each(data, function (entry) {\n        if (entry.ifd === 0 && entry.tag === 0x112 && Array.isArray(entry.value)) {\n          env.orientation    = entry.value[0] || 1;\n          exif_is_big_endian = entry.is_big_endian;\n          orientation_offset = entry.data_offset;\n          return false;\n        }\n      });\n\n      if (orientation_offset) {\n        var orientation_patch = exif_is_big_endian ?\n          new Uint8Array([ 0, 1 ]) :\n          new Uint8Array([ 1, 0 ]);\n\n        env.blob = new Blob([\n          data.slice(0, orientation_offset),\n          orientation_patch,\n          data.slice(orientation_offset + 2)\n        ], { type: 'image/jpeg' });\n      }\n    } catch (_) {}\n\n    return env;\n  });\n}\n\n\nfunction jpeg_rotate_canvas(env) {\n  if (!env.is_jpeg) return Promise.resolve(env);\n\n  var orientation = env.orientation - 1;\n  if (!orientation) return Promise.resolve(env);\n\n  var canvas;\n\n  if (orientation & 4) {\n    canvas = this.pica.options.createCanvas(env.out_canvas.height, env.out_canvas.width);\n  } else {\n    canvas = this.pica.options.createCanvas(env.out_canvas.width, env.out_canvas.height);\n  }\n\n  var ctx = canvas.getContext('2d');\n\n  ctx.save();\n\n  if (orientation & 1) ctx.transform(-1, 0, 0, 1, canvas.width, 0);\n  if (orientation & 2) ctx.transform(-1, 0, 0, -1, canvas.width, canvas.height);\n  if (orientation & 4) ctx.transform(0, 1, 1, 0, 0, 0);\n\n  ctx.drawImage(env.out_canvas, 0, 0);\n  ctx.restore();\n\n  // Safari 12 workaround\n  // https://github.com/nodeca/pica/issues/199\n  env.out_canvas.width = env.out_canvas.height = 0;\n\n  env.out_canvas = canvas;\n\n  return Promise.resolve(env);\n}\n\n\nfunction jpeg_attach_orig_segments(env) {\n  if (!env.is_jpeg) return Promise.resolve(env);\n\n  return Promise.all([\n    this._getUint8Array(env.blob),\n    this._getUint8Array(env.out_blob)\n  ]).then(function (res) {\n    var data = res[0];\n    var data_out = res[1];\n\n    if (!image_traverse.is_jpeg(data)) return Promise.resolve(env);\n\n    var segments = [];\n\n    image_traverse.jpeg_segments_each(data, function (segment) {\n      if (segment.code === 0xDA /* SOS */) return false;\n      segments.push(segment);\n    });\n\n    segments = segments\n      .filter(function (segment) {\n        // Drop ICC_PROFILE\n        //\n        if (segment.code === 0xE2) return false;\n\n        // Keep all APPn segments excluding APP2 (ICC_PROFILE),\n        // remove others because most of them depend on image data (DCT and such).\n        //\n        // APP0 - JFIF, APP1 - Exif, the rest are photoshop metadata and such\n        //\n        // See full list at https://www.w3.org/Graphics/JPEG/itu-t81.pdf (table B.1 on page 32)\n        //\n        if (segment.code >= 0xE0 && segment.code < 0xF0) return true;\n\n        // Keep comments\n        //\n        if (segment.code === 0xFE) return true;\n\n        return false;\n      })\n      .map(function (segment) {\n        return data.slice(segment.offset, segment.offset + segment.length);\n      });\n\n    env.out_blob = new Blob(\n      // intentionally omitting expected JFIF segment (offset 2 to 20)\n      [ data_out.slice(0, 2) ].concat(segments).concat([ data_out.slice(20) ]),\n      { type: 'image/jpeg' }\n    );\n\n    return env;\n  });\n}\n\n\nfunction assign(reducer) {\n  reducer.before('_blob_to_image', jpeg_patch_exif);\n  reducer.after('_transform',      jpeg_rotate_canvas);\n  reducer.after('_create_blob',    jpeg_attach_orig_segments);\n}\n\n\nvar jpeg_patch_exif_1 = jpeg_patch_exif;\nvar jpeg_rotate_canvas_1 = jpeg_rotate_canvas;\nvar jpeg_attach_orig_segments_1 = jpeg_attach_orig_segments;\nvar assign_1 = assign;\n\nvar jpeg_plugins = {\n\tjpeg_patch_exif: jpeg_patch_exif_1,\n\tjpeg_rotate_canvas: jpeg_rotate_canvas_1,\n\tjpeg_attach_orig_segments: jpeg_attach_orig_segments_1,\n\tassign: assign_1\n};\n\nfunction ImageBlobReduce(options) {\n  if (!(this instanceof ImageBlobReduce)) return new ImageBlobReduce(options);\n\n  options = options || {};\n\n  this.pica = options.pica || pica({});\n  this.initialized = false;\n\n  this.utils = utils;\n}\n\n\nImageBlobReduce.prototype.use = function (plugin /*, params, ... */) {\n  var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));\n  plugin.apply(plugin, args);\n  return this;\n};\n\n\nImageBlobReduce.prototype.init = function () {\n  this.use(jpeg_plugins.assign);\n};\n\n\nImageBlobReduce.prototype.toBlob = function (blob, options) {\n  var opts = utils.assign({ max: Infinity }, options);\n  var env = {\n    blob: blob,\n    opts: opts\n  };\n\n  if (!this.initialized) {\n    this.init();\n    this.initialized = true;\n  }\n\n  return Promise.resolve(env)\n    .then(this._blob_to_image)\n    .then(this._calculate_size)\n    .then(this._transform)\n    .then(this._cleanup)\n    .then(this._create_blob)\n    .then(function (_env) {\n      // Safari 12 workaround\n      // https://github.com/nodeca/pica/issues/199\n      _env.out_canvas.width = _env.out_canvas.height = 0;\n\n      return _env.out_blob;\n    });\n};\n\n\nImageBlobReduce.prototype.toCanvas = function (blob, options) {\n  var opts = utils.assign({ max: Infinity }, options);\n  var env = {\n    blob: blob,\n    opts: opts\n  };\n\n  if (!this.initialized) {\n    this.init();\n    this.initialized = true;\n  }\n\n  return Promise.resolve(env)\n    .then(this._blob_to_image)\n    .then(this._calculate_size)\n    .then(this._transform)\n    .then(this._cleanup)\n    .then(function (_env) { return _env.out_canvas; });\n};\n\n\nImageBlobReduce.prototype.before = function (method_name, fn) {\n  if (!this[method_name]) throw new Error('Method \"' + method_name + '\" does not exist');\n  if (typeof fn !== 'function') throw new Error('Invalid argument \"fn\", function expected');\n\n  var old_fn = this[method_name];\n  var self = this;\n\n  this[method_name] = function (env) {\n    return fn.call(self, env).then(function (_env) {\n      return old_fn.call(self, _env);\n    });\n  };\n\n  return this;\n};\n\n\nImageBlobReduce.prototype.after = function (method_name, fn) {\n  if (!this[method_name]) throw new Error('Method \"' + method_name + '\" does not exist');\n  if (typeof fn !== 'function') throw new Error('Invalid argument \"fn\", function expected');\n\n  var old_fn = this[method_name];\n  var self = this;\n\n  this[method_name] = function (env) {\n    return old_fn.call(self, env).then(function (_env) {\n      return fn.call(self, _env);\n    });\n  };\n\n  return this;\n};\n\n\nImageBlobReduce.prototype._blob_to_image = function (env) {\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n  env.image = document.createElement('img');\n  env.image_url = URL.createObjectURL(env.blob);\n  env.image.src = env.image_url;\n\n  return new Promise(function (resolve, reject) {\n    env.image.onerror = function () { reject(new Error('ImageBlobReduce: failed to create Image() from blob')); };\n    env.image.onload = function () { resolve(env); };\n  });\n};\n\n\nImageBlobReduce.prototype._calculate_size = function (env) {\n  //\n  // Note, if your need not \"symmetric\" resize logic, you MUST check\n  // `env.orientation` (set by plugins) and swap width/height appropriately.\n  //\n  var scale_factor = env.opts.max / Math.max(env.image.width, env.image.height);\n\n  if (scale_factor > 1) scale_factor = 1;\n\n  env.transform_width = Math.max(Math.round(env.image.width * scale_factor), 1);\n  env.transform_height = Math.max(Math.round(env.image.height * scale_factor), 1);\n\n  // Info for user plugins, to check if scaling applied\n  env.scale_factor = scale_factor;\n\n  return Promise.resolve(env);\n};\n\n\nImageBlobReduce.prototype._transform = function (env) {\n  env.out_canvas = this.pica.options.createCanvas(env.transform_width, env.transform_height);\n\n  // Dim env temporary vars to prohibit use and avoid confusion when orientation\n  // changed. You should take real size from canvas.\n  env.transform_width = null;\n  env.transform_height = null;\n\n  // By default use alpha for png only\n  var pica_opts = { alpha: env.blob.type === 'image/png' };\n\n  // Extract pica options if been passed\n  this.utils.assign(pica_opts, this.utils.pick_pica_resize_options(env.opts));\n\n  return this.pica\n    .resize(env.image, env.out_canvas, pica_opts)\n    .then(function () { return env; });\n};\n\n\nImageBlobReduce.prototype._cleanup = function (env) {\n  env.image.src = '';\n  env.image = null;\n\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n  if (URL.revokeObjectURL) URL.revokeObjectURL(env.image_url);\n\n  env.image_url = null;\n\n  return Promise.resolve(env);\n};\n\n\nImageBlobReduce.prototype._create_blob = function (env) {\n  return this.pica.toBlob(env.out_canvas, env.blob.type)\n    .then(function (blob) {\n      env.out_blob = blob;\n      return env;\n    });\n};\n\n\nImageBlobReduce.prototype._getUint8Array = function (blob) {\n  if (blob.arrayBuffer) {\n    return blob.arrayBuffer().then(function (buf) {\n      return new Uint8Array(buf);\n    });\n  }\n\n  return new Promise(function (resolve, reject) {\n    var fr = new FileReader();\n\n    fr.readAsArrayBuffer(blob);\n\n    fr.onload = function () { resolve(new Uint8Array(fr.result)); };\n    fr.onerror = function () {\n      reject(new Error('ImageBlobReduce: failed to load data from input blob'));\n      fr.abort();\n    };\n    fr.onabort = function () {\n      reject(new Error('ImageBlobReduce: failed to load data from input blob (aborted)'));\n    };\n  });\n};\n\n\nImageBlobReduce.pica = pica;\n\nvar imageBlobReduce = ImageBlobReduce;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (imageBlobReduce);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ltYWdlLWJsb2ItcmVkdWNlQDMuMC4xL25vZGVfbW9kdWxlcy9pbWFnZS1ibG9iLXJlZHVjZS9kaXN0L2ltYWdlLWJsb2ItcmVkdWNlLmVzbS5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxjQUFjLHFCQUFxQixhQUFhLG1CQUFtQixrQkFBa0IsZ0JBQWdCLFVBQVUsVUFBVSwwREFBMEQsd0JBQXdCLG9CQUFvQiw4Q0FBOEMsa0NBQWtDLFlBQVksWUFBWSxtQ0FBbUMsaUJBQWlCLGVBQWUsdUJBQXVCLG9CQUFvQixrRUFBa0UsV0FBVyxZQUFZLFNBQVMsU0FBUyxLQUFLOztBQUVyaUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsbUVBQW1FO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEIsaUJBQWlCLGFBQWE7QUFDOUIsbUJB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QUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsNElBQTRJLEVBQUUsR0FBRztBQUNwSixDQUFDO0FBQ0QsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0EsaUZBQWlGOztBQUVqRjtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLHFCQUFxQiw0REFBNEQ7QUFDakY7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBLE1BQU07O0FBRU47QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEMscUNBQXFDO0FBQ3JDLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBOztBQUVBOztBQUVBLGlFQUFlLGVBQWUsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaW1hZ2UtYmxvYi1yZWR1Y2VAMy4wLjEvbm9kZV9tb2R1bGVzL2ltYWdlLWJsb2ItcmVkdWNlL2Rpc3QvaW1hZ2UtYmxvYi1yZWR1Y2UuZXNtLm1qcz85Y2VmIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohIGltYWdlLWJsb2ItcmVkdWNlIDMuMC4xIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvaW1hZ2UtYmxvYi1yZWR1Y2UgQGxpY2Vuc2UgTUlUICovXG52YXIgYXNzaWduJDEgPSBmdW5jdGlvbiBhc3NpZ24odG8pIHtcbiAgdmFyIGZyb207XG5cbiAgZm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcbiAgICBmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB0b1trZXldID0gZnJvbVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn07XG5cblxuZnVuY3Rpb24gcGljayhmcm9tLCBwcm9wcykge1xuICB2YXIgdG8gPSB7fTtcblxuICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHRvW2tleV0gPSBmcm9tW2tleV07XG4gIH0pO1xuXG4gIHJldHVybiB0bztcbn1cblxuXG5mdW5jdGlvbiBwaWNrX3BpY2FfcmVzaXplX29wdGlvbnMoZnJvbSkge1xuICByZXR1cm4gcGljayhmcm9tLCBbXG4gICAgJ2FscGhhJyxcbiAgICAndW5zaGFycEFtb3VudCcsXG4gICAgJ3Vuc2hhcnBSYWRpdXMnLFxuICAgICd1bnNoYXJwVGhyZXNob2xkJyxcbiAgICAnY2FuY2VsVG9rZW4nXG4gIF0pO1xufVxuXG5cbnZhciBwaWNrXzEgPSBwaWNrO1xudmFyIHBpY2tfcGljYV9yZXNpemVfb3B0aW9uc18xID0gcGlja19waWNhX3Jlc2l6ZV9vcHRpb25zO1xuXG52YXIgdXRpbHMgPSB7XG5cdGFzc2lnbjogYXNzaWduJDEsXG5cdHBpY2s6IHBpY2tfMSxcblx0cGlja19waWNhX3Jlc2l6ZV9vcHRpb25zOiBwaWNrX3BpY2FfcmVzaXplX29wdGlvbnNfMVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4pIHtcbiAgdmFyIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfTtcblx0cmV0dXJuIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxuZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlICh0YXJnZXQpIHtcblx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZHluYW1pY2FsbHkgcmVxdWlyZSBcIicgKyB0YXJnZXQgKyAnXCIuIFBsZWFzZSBjb25maWd1cmUgdGhlIGR5bmFtaWNSZXF1aXJlVGFyZ2V0cyBvcHRpb24gb2YgQHJvbGx1cC9wbHVnaW4tY29tbW9uanMgYXBwcm9wcmlhdGVseSBmb3IgdGhpcyByZXF1aXJlIGNhbGwgdG8gYmVoYXZlIHByb3Blcmx5LicpO1xufVxuXG4vKiFcblxucGljYVxuaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9waWNhXG5cbiovXG5cbnZhciBwaWNhID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuKGZ1bmN0aW9uKGYpe3ttb2R1bGUuZXhwb3J0cz1mKCk7fX0pKGZ1bmN0aW9uKCl7cmV0dXJuIChmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIGNvbW1vbmpzUmVxdWlyZSYmY29tbW9uanNSZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpO31yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBjb21tb25qc1JlcXVpcmUmJmNvbW1vbmpzUmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG52YXIgaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpO1xuXG52YXIgTXVsdGltYXRoID0gX2RlcmVxXygnbXVsdGltYXRoJyk7XG5cbnZhciBtbV91bnNoYXJwX21hc2sgPSBfZGVyZXFfKCcuL21tX3Vuc2hhcnBfbWFzaycpO1xuXG52YXIgbW1fcmVzaXplID0gX2RlcmVxXygnLi9tbV9yZXNpemUnKTtcblxuZnVuY3Rpb24gTWF0aExpYihyZXF1ZXN0ZWRfZmVhdHVyZXMpIHtcbiAgdmFyIF9fcmVxdWVzdGVkX2ZlYXR1cmVzID0gcmVxdWVzdGVkX2ZlYXR1cmVzIHx8IFtdO1xuXG4gIHZhciBmZWF0dXJlcyA9IHtcbiAgICBqczogX19yZXF1ZXN0ZWRfZmVhdHVyZXMuaW5kZXhPZignanMnKSA+PSAwLFxuICAgIHdhc206IF9fcmVxdWVzdGVkX2ZlYXR1cmVzLmluZGV4T2YoJ3dhc20nKSA+PSAwXG4gIH07XG4gIE11bHRpbWF0aC5jYWxsKHRoaXMsIGZlYXR1cmVzKTtcbiAgdGhpcy5mZWF0dXJlcyA9IHtcbiAgICBqczogZmVhdHVyZXMuanMsXG4gICAgd2FzbTogZmVhdHVyZXMud2FzbSAmJiB0aGlzLmhhc193YXNtKClcbiAgfTtcbiAgdGhpcy51c2UobW1fdW5zaGFycF9tYXNrKTtcbiAgdGhpcy51c2UobW1fcmVzaXplKTtcbn1cblxuaW5oZXJpdHMoTWF0aExpYiwgTXVsdGltYXRoKTtcblxuTWF0aExpYi5wcm90b3R5cGUucmVzaXplQW5kVW5zaGFycCA9IGZ1bmN0aW9uIHJlc2l6ZUFuZFVuc2hhcnAob3B0aW9ucywgY2FjaGUpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMucmVzaXplKG9wdGlvbnMsIGNhY2hlKTtcblxuICBpZiAob3B0aW9ucy51bnNoYXJwQW1vdW50KSB7XG4gICAgdGhpcy51bnNoYXJwX21hc2socmVzdWx0LCBvcHRpb25zLnRvV2lkdGgsIG9wdGlvbnMudG9IZWlnaHQsIG9wdGlvbnMudW5zaGFycEFtb3VudCwgb3B0aW9ucy51bnNoYXJwUmFkaXVzLCBvcHRpb25zLnVuc2hhcnBUaHJlc2hvbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0aExpYjtcblxufSx7XCIuL21tX3Jlc2l6ZVwiOjQsXCIuL21tX3Vuc2hhcnBfbWFza1wiOjksXCJpbmhlcml0c1wiOjE5LFwibXVsdGltYXRoXCI6MjB9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vdmFyIEZJWEVEX0ZSQUNfQklUUyA9IDE0O1xuXG5mdW5jdGlvbiBjbGFtcFRvOChpKSB7XG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbn0gLy8gQ29udm9sdmUgaW1hZ2UgaW4gaG9yaXpvbnRhbCBkaXJlY3Rpb25zIGFuZCB0cmFuc3Bvc2Ugb3V0cHV0LiBJbiB0aGVvcnksXG4vLyB0cmFuc3Bvc2UgYWxsb3c6XG4vL1xuLy8gLSB1c2UgdGhlIHNhbWUgY29udm9sdmVyIGZvciBib3RoIHBhc3NlcyAodGhpcyBmYWlscyBkdWUgZGlmZmVyZW50XG4vLyAgIHR5cGVzIG9mIGlucHV0IGFycmF5IGFuZCB0ZW1wb3JhcnkgYnVmZmVyKVxuLy8gLSBtYWtpbmcgdmVydGljYWwgcGFzcyBieSBob3Jpc29ubHRhbCBsaW5lcyBpbnByb3ZlIENQVSBjYWNoZSB1c2UuXG4vL1xuLy8gQnV0IGluIHJlYWwgbGlmZSB0aGlzIGRvZXNuJ3Qgd29yayA6KVxuLy9cblxuXG5mdW5jdGlvbiBjb252b2x2ZUhvcml6b250YWxseShzcmMsIGRlc3QsIHNyY1csIHNyY0gsIGRlc3RXLCBmaWx0ZXJzKSB7XG4gIHZhciByLCBnLCBiLCBhO1xuICB2YXIgZmlsdGVyUHRyLCBmaWx0ZXJTaGlmdCwgZmlsdGVyU2l6ZTtcbiAgdmFyIHNyY1B0ciwgc3JjWSwgZGVzdFgsIGZpbHRlclZhbDtcbiAgdmFyIHNyY09mZnNldCA9IDAsXG4gICAgICBkZXN0T2Zmc2V0ID0gMDsgLy8gRm9yIGVhY2ggcm93XG5cbiAgZm9yIChzcmNZID0gMDsgc3JjWSA8IHNyY0g7IHNyY1krKykge1xuICAgIGZpbHRlclB0ciA9IDA7IC8vIEFwcGx5IHByZWNvbXB1dGVkIGZpbHRlcnMgdG8gZWFjaCBkZXN0aW5hdGlvbiByb3cgcG9pbnRcblxuICAgIGZvciAoZGVzdFggPSAwOyBkZXN0WCA8IGRlc3RXOyBkZXN0WCsrKSB7XG4gICAgICAvLyBHZXQgdGhlIGZpbHRlciB0aGF0IGRldGVybWluZXMgdGhlIGN1cnJlbnQgb3V0cHV0IHBpeGVsLlxuICAgICAgZmlsdGVyU2hpZnQgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTtcbiAgICAgIGZpbHRlclNpemUgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTtcbiAgICAgIHNyY1B0ciA9IHNyY09mZnNldCArIGZpbHRlclNoaWZ0ICogNCB8IDA7XG4gICAgICByID0gZyA9IGIgPSBhID0gMDsgLy8gQXBwbHkgdGhlIGZpbHRlciB0byB0aGUgcm93IHRvIGdldCB0aGUgZGVzdGluYXRpb24gcGl4ZWwgciwgZywgYiwgYVxuXG4gICAgICBmb3IgKDsgZmlsdGVyU2l6ZSA+IDA7IGZpbHRlclNpemUtLSkge1xuICAgICAgICBmaWx0ZXJWYWwgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTsgLy8gVXNlIHJldmVyc2Ugb3JkZXIgdG8gd29ya2Fyb3VuZCBkZW9wdHMgaW4gb2xkIHY4IChub2RlIHYuMTApXG4gICAgICAgIC8vIEJpZyB0aGFua3MgdG8gQG1yYWxlcGggKFZ5YWNoZXNsYXYgRWdvcm92KSBmb3IgdGhlIHRpcC5cblxuICAgICAgICBhID0gYSArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHIgKyAzXSB8IDA7XG4gICAgICAgIGIgPSBiICsgZmlsdGVyVmFsICogc3JjW3NyY1B0ciArIDJdIHwgMDtcbiAgICAgICAgZyA9IGcgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyICsgMV0gfCAwO1xuICAgICAgICByID0gciArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHJdIHwgMDtcbiAgICAgICAgc3JjUHRyID0gc3JjUHRyICsgNCB8IDA7XG4gICAgICB9IC8vIEJyaW5nIHRoaXMgdmFsdWUgYmFjayBpbiByYW5nZS4gQWxsIG9mIHRoZSBmaWx0ZXIgc2NhbGluZyBmYWN0b3JzXG4gICAgICAvLyBhcmUgaW4gZml4ZWQgcG9pbnQgd2l0aCBGSVhFRF9GUkFDX0JJVFMgYml0cyBvZiBmcmFjdGlvbmFsIHBhcnQuXG4gICAgICAvL1xuICAgICAgLy8gKCEpIEFkZCAxLzIgb2YgdmFsdWUgYmVmb3JlIGNsYW1waW5nIHRvIGdldCBwcm9wZXIgcm91bmRpbmcuIEluIG90aGVyXG4gICAgICAvLyBjYXNlIGJyaWdodG5lc3MgbG9zcyB3aWxsIGJlIG5vdGljZWFibGUgaWYgeW91IHJlc2l6ZSBpbWFnZSB3aXRoIHdoaXRlXG4gICAgICAvLyBib3JkZXIgYW5kIHBsYWNlIGl0IG9uIHdoaXRlIGJhY2tncm91bmQuXG4gICAgICAvL1xuXG5cbiAgICAgIGRlc3RbZGVzdE9mZnNldCArIDNdID0gY2xhbXBUbzgoYSArICgxIDw8IDEzKSA+PiAxNFxuICAgICAgLypGSVhFRF9GUkFDX0JJVFMqL1xuICAgICAgKTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldCArIDJdID0gY2xhbXBUbzgoYiArICgxIDw8IDEzKSA+PiAxNFxuICAgICAgLypGSVhFRF9GUkFDX0JJVFMqL1xuICAgICAgKTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldCArIDFdID0gY2xhbXBUbzgoZyArICgxIDw8IDEzKSA+PiAxNFxuICAgICAgLypGSVhFRF9GUkFDX0JJVFMqL1xuICAgICAgKTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldF0gPSBjbGFtcFRvOChyICsgKDEgPDwgMTMpID4+IDE0XG4gICAgICAvKkZJWEVEX0ZSQUNfQklUUyovXG4gICAgICApO1xuICAgICAgZGVzdE9mZnNldCA9IGRlc3RPZmZzZXQgKyBzcmNIICogNCB8IDA7XG4gICAgfVxuXG4gICAgZGVzdE9mZnNldCA9IChzcmNZICsgMSkgKiA0IHwgMDtcbiAgICBzcmNPZmZzZXQgPSAoc3JjWSArIDEpICogc3JjVyAqIDQgfCAwO1xuICB9XG59IC8vIFRlY2huaWNhbGx5LCBjb252b2x2ZXJzIGFyZSB0aGUgc2FtZS4gQnV0IGlucHV0IGFycmF5IGFuZCB0ZW1wb3Jhcnlcbi8vIGJ1ZmZlciBjYW4gYmUgb2YgZGlmZmVyZW50IHR5cGUgKGVzcGVjaWFsbHksIGluIG9sZCBicm93c2VycykuIFNvLFxuLy8ga2VlcCBjb2RlIGluIHNlcGFyYXRlIGZ1bmN0aW9ucyB0byBhdm9pZCBkZW9wdGltaXphdGlvbnMgJiBzcGVlZCBsb3NzLlxuXG5cbmZ1bmN0aW9uIGNvbnZvbHZlVmVydGljYWxseShzcmMsIGRlc3QsIHNyY1csIHNyY0gsIGRlc3RXLCBmaWx0ZXJzKSB7XG4gIHZhciByLCBnLCBiLCBhO1xuICB2YXIgZmlsdGVyUHRyLCBmaWx0ZXJTaGlmdCwgZmlsdGVyU2l6ZTtcbiAgdmFyIHNyY1B0ciwgc3JjWSwgZGVzdFgsIGZpbHRlclZhbDtcbiAgdmFyIHNyY09mZnNldCA9IDAsXG4gICAgICBkZXN0T2Zmc2V0ID0gMDsgLy8gRm9yIGVhY2ggcm93XG5cbiAgZm9yIChzcmNZID0gMDsgc3JjWSA8IHNyY0g7IHNyY1krKykge1xuICAgIGZpbHRlclB0ciA9IDA7IC8vIEFwcGx5IHByZWNvbXB1dGVkIGZpbHRlcnMgdG8gZWFjaCBkZXN0aW5hdGlvbiByb3cgcG9pbnRcblxuICAgIGZvciAoZGVzdFggPSAwOyBkZXN0WCA8IGRlc3RXOyBkZXN0WCsrKSB7XG4gICAgICAvLyBHZXQgdGhlIGZpbHRlciB0aGF0IGRldGVybWluZXMgdGhlIGN1cnJlbnQgb3V0cHV0IHBpeGVsLlxuICAgICAgZmlsdGVyU2hpZnQgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTtcbiAgICAgIGZpbHRlclNpemUgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTtcbiAgICAgIHNyY1B0ciA9IHNyY09mZnNldCArIGZpbHRlclNoaWZ0ICogNCB8IDA7XG4gICAgICByID0gZyA9IGIgPSBhID0gMDsgLy8gQXBwbHkgdGhlIGZpbHRlciB0byB0aGUgcm93IHRvIGdldCB0aGUgZGVzdGluYXRpb24gcGl4ZWwgciwgZywgYiwgYVxuXG4gICAgICBmb3IgKDsgZmlsdGVyU2l6ZSA+IDA7IGZpbHRlclNpemUtLSkge1xuICAgICAgICBmaWx0ZXJWYWwgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTsgLy8gVXNlIHJldmVyc2Ugb3JkZXIgdG8gd29ya2Fyb3VuZCBkZW9wdHMgaW4gb2xkIHY4IChub2RlIHYuMTApXG4gICAgICAgIC8vIEJpZyB0aGFua3MgdG8gQG1yYWxlcGggKFZ5YWNoZXNsYXYgRWdvcm92KSBmb3IgdGhlIHRpcC5cblxuICAgICAgICBhID0gYSArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHIgKyAzXSB8IDA7XG4gICAgICAgIGIgPSBiICsgZmlsdGVyVmFsICogc3JjW3NyY1B0ciArIDJdIHwgMDtcbiAgICAgICAgZyA9IGcgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyICsgMV0gfCAwO1xuICAgICAgICByID0gciArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHJdIHwgMDtcbiAgICAgICAgc3JjUHRyID0gc3JjUHRyICsgNCB8IDA7XG4gICAgICB9IC8vIEJyaW5nIHRoaXMgdmFsdWUgYmFjayBpbiByYW5nZS4gQWxsIG9mIHRoZSBmaWx0ZXIgc2NhbGluZyBmYWN0b3JzXG4gICAgICAvLyBhcmUgaW4gZml4ZWQgcG9pbnQgd2l0aCBGSVhFRF9GUkFDX0JJVFMgYml0cyBvZiBmcmFjdGlvbmFsIHBhcnQuXG4gICAgICAvL1xuICAgICAgLy8gKCEpIEFkZCAxLzIgb2YgdmFsdWUgYmVmb3JlIGNsYW1waW5nIHRvIGdldCBwcm9wZXIgcm91bmRpbmcuIEluIG90aGVyXG4gICAgICAvLyBjYXNlIGJyaWdodG5lc3MgbG9zcyB3aWxsIGJlIG5vdGljZWFibGUgaWYgeW91IHJlc2l6ZSBpbWFnZSB3aXRoIHdoaXRlXG4gICAgICAvLyBib3JkZXIgYW5kIHBsYWNlIGl0IG9uIHdoaXRlIGJhY2tncm91bmQuXG4gICAgICAvL1xuXG5cbiAgICAgIGRlc3RbZGVzdE9mZnNldCArIDNdID0gY2xhbXBUbzgoYSArICgxIDw8IDEzKSA+PiAxNFxuICAgICAgLypGSVhFRF9GUkFDX0JJVFMqL1xuICAgICAgKTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldCArIDJdID0gY2xhbXBUbzgoYiArICgxIDw8IDEzKSA+PiAxNFxuICAgICAgLypGSVhFRF9GUkFDX0JJVFMqL1xuICAgICAgKTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldCArIDFdID0gY2xhbXBUbzgoZyArICgxIDw8IDEzKSA+PiAxNFxuICAgICAgLypGSVhFRF9GUkFDX0JJVFMqL1xuICAgICAgKTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldF0gPSBjbGFtcFRvOChyICsgKDEgPDwgMTMpID4+IDE0XG4gICAgICAvKkZJWEVEX0ZSQUNfQklUUyovXG4gICAgICApO1xuICAgICAgZGVzdE9mZnNldCA9IGRlc3RPZmZzZXQgKyBzcmNIICogNCB8IDA7XG4gICAgfVxuXG4gICAgZGVzdE9mZnNldCA9IChzcmNZICsgMSkgKiA0IHwgMDtcbiAgICBzcmNPZmZzZXQgPSAoc3JjWSArIDEpICogc3JjVyAqIDQgfCAwO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb252b2x2ZUhvcml6b250YWxseTogY29udm9sdmVIb3Jpem9udGFsbHksXG4gIGNvbnZvbHZlVmVydGljYWxseTogY29udm9sdmVWZXJ0aWNhbGx5XG59O1xuXG59LHt9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSAnQUdGemJRRUFBQUFBREFaa2VXeHBibXNBQUFBQUFBRVhBMkFBQUdBR2YzOS9mMzkvQUdBSGYzOS9mMzkvZndBQ0R3RURaVzUyQm0xbGJXOXllUUlBQUFNRUF3QUJBZ1lHQVg4QVFRQUxCMWNGRVY5ZmQyRnpiVjlqWVd4c1gyTjBiM0p6QUFBSVkyOXVkbTlzZG1VQUFRcGpiMjUyYjJ4MlpVaFdBQUlNWDE5a2MyOWZhR0Z1Wkd4bEF3QVlYMTkzWVhOdFgyRndjR3g1WDJSaGRHRmZjbVZzYjJOekFBQUs3QU1EQXdBQkM4WURBUTkvQWtBZ0EwVU5BQ0FFUlEwQUEwQWdEQ0VOUVFBaEUwRUFJUWNEUUNBSFFRSnFJUVlDZnlBSFFRRjBJQVZxSWdjdUFRSWlGRVVFUUVHQXdBQWhDRUdBd0FBaENVR0F3QUFoQ2tHQXdBQWhDeUFHREFFTElCSWdCeTRCQUdvaENFRUFJUXNnRkNFSFFRQWhEaUFHSVFsQkFDRVBRUUFoRUFOQUlBVWdDVUVCZEdvdUFRQWlFU0FBSUFoQkFuUnFLQUlBSWdwQkdIWnNJQkJxSVJBZ0NrSC9BWEVnRVd3Z0Myb2hDeUFLUVJCMlFmOEJjU0FSYkNBUGFpRVBJQXBCQ0haQi93RnhJQkZzSUE1cUlRNGdDRUVCYWlFSUlBbEJBV29oQ1NBSFFRRnJJZ2NOQUFzZ0MwR0FRR3NoQ0NBT1FZQkFheUVKSUE5QmdFQnJJUW9nRUVHQVFHc2hDeUFHSUJScUN5RUhJQUVnRFVFQ2RHb2dDVUVPZFNJR1FmOEJJQVpCL3dGSUd5SUdRUUFnQmtFQVNodEJDSFJCZ1A0RGNTQUtRUTUxSWdaQi93RWdCa0gvQVVnYklnWkJBQ0FHUVFCS0cwRVFkRUdBZ1B3SGNTQUxRUTUxSWdaQi93RWdCa0gvQVVnYklnWkJBQ0FHUVFCS0cwRVlkSEp5SUFoQkRuVWlCa0gvQVNBR1FmOEJTQnNpQmtFQUlBWkJBRW9iY2pZQ0FDQURJQTFxSVEwZ0UwRUJhaUlUSUFSSERRQUxJQXhCQVdvaURDQUNiQ0VTSUFNZ0RFY05BQXNMQ3g0QVFRQWdBaUFESUFRZ0JTQUFFQUVnQWtFQUlBUWdCU0FHSUFFUUFRcz0nO1xuXG59LHt9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdyZXNpemUnLFxuICBmbjogX2RlcmVxXygnLi9yZXNpemUnKSxcbiAgd2FzbV9mbjogX2RlcmVxXygnLi9yZXNpemVfd2FzbScpLFxuICB3YXNtX3NyYzogX2RlcmVxXygnLi9jb252b2x2ZV93YXNtX2Jhc2U2NCcpXG59O1xuXG59LHtcIi4vY29udm9sdmVfd2FzbV9iYXNlNjRcIjozLFwiLi9yZXNpemVcIjo1LFwiLi9yZXNpemVfd2FzbVwiOjh9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxudmFyIGNyZWF0ZUZpbHRlcnMgPSBfZGVyZXFfKCcuL3Jlc2l6ZV9maWx0ZXJfZ2VuJyk7XG5cbnZhciBjb252b2x2ZUhvcml6b250YWxseSA9IF9kZXJlcV8oJy4vY29udm9sdmUnKS5jb252b2x2ZUhvcml6b250YWxseTtcblxudmFyIGNvbnZvbHZlVmVydGljYWxseSA9IF9kZXJlcV8oJy4vY29udm9sdmUnKS5jb252b2x2ZVZlcnRpY2FsbHk7XG5cbmZ1bmN0aW9uIHJlc2V0QWxwaGEoZHN0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBwdHIgPSAzLFxuICAgICAgbGVuID0gd2lkdGggKiBoZWlnaHQgKiA0IHwgMDtcblxuICB3aGlsZSAocHRyIDwgbGVuKSB7XG4gICAgZHN0W3B0cl0gPSAweEZGO1xuICAgIHB0ciA9IHB0ciArIDQgfCAwO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVzaXplKG9wdGlvbnMpIHtcbiAgdmFyIHNyYyA9IG9wdGlvbnMuc3JjO1xuICB2YXIgc3JjVyA9IG9wdGlvbnMud2lkdGg7XG4gIHZhciBzcmNIID0gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBkZXN0VyA9IG9wdGlvbnMudG9XaWR0aDtcbiAgdmFyIGRlc3RIID0gb3B0aW9ucy50b0hlaWdodDtcbiAgdmFyIHNjYWxlWCA9IG9wdGlvbnMuc2NhbGVYIHx8IG9wdGlvbnMudG9XaWR0aCAvIG9wdGlvbnMud2lkdGg7XG4gIHZhciBzY2FsZVkgPSBvcHRpb25zLnNjYWxlWSB8fCBvcHRpb25zLnRvSGVpZ2h0IC8gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBvZmZzZXRYID0gb3B0aW9ucy5vZmZzZXRYIHx8IDA7XG4gIHZhciBvZmZzZXRZID0gb3B0aW9ucy5vZmZzZXRZIHx8IDA7XG4gIHZhciBkZXN0ID0gb3B0aW9ucy5kZXN0IHx8IG5ldyBVaW50OEFycmF5KGRlc3RXICogZGVzdEggKiA0KTtcbiAgdmFyIHF1YWxpdHkgPSB0eXBlb2Ygb3B0aW9ucy5xdWFsaXR5ID09PSAndW5kZWZpbmVkJyA/IDMgOiBvcHRpb25zLnF1YWxpdHk7XG4gIHZhciBhbHBoYSA9IG9wdGlvbnMuYWxwaGEgfHwgZmFsc2U7XG4gIHZhciBmaWx0ZXJzWCA9IGNyZWF0ZUZpbHRlcnMocXVhbGl0eSwgc3JjVywgZGVzdFcsIHNjYWxlWCwgb2Zmc2V0WCksXG4gICAgICBmaWx0ZXJzWSA9IGNyZWF0ZUZpbHRlcnMocXVhbGl0eSwgc3JjSCwgZGVzdEgsIHNjYWxlWSwgb2Zmc2V0WSk7XG4gIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShkZXN0VyAqIHNyY0ggKiA0KTsgLy8gVG8gdXNlIHNpbmdsZSBmdW5jdGlvbiB3ZSBuZWVkIHNyYyAmIHRtcCBvZiB0aGUgc2FtZSB0eXBlLlxuICAvLyBCdXQgc3JjIGNhbiBiZSBDYW52YXNQaXhlbEFycmF5LCBhbmQgdG1wIC0gVWludDhBcnJheS4gU28sIGtlZXBcbiAgLy8gdmVydGljYWwgYW5kIGhvcml6b250YWwgcGFzc2VzIHNlcGFyYXRlbHkgdG8gYXZvaWQgZGVvcHRpbWl6YXRpb24uXG5cbiAgY29udm9sdmVIb3Jpem9udGFsbHkoc3JjLCB0bXAsIHNyY1csIHNyY0gsIGRlc3RXLCBmaWx0ZXJzWCk7XG4gIGNvbnZvbHZlVmVydGljYWxseSh0bXAsIGRlc3QsIHNyY0gsIGRlc3RXLCBkZXN0SCwgZmlsdGVyc1kpOyAvLyBUaGF0J3MgZmFzdGVyIHRoYW4gZG9pbmcgY2hlY2tzIGluIGNvbnZvbHZlci5cbiAgLy8gISEhIE5vdGUsIGNhbnZhcyBkYXRhIGlzIG5vdCBwcmVtdWx0aXBsZWQuIFdlIGRvbid0IG5lZWQgb3RoZXJcbiAgLy8gYWxwaGEgY29ycmVjdGlvbnMuXG5cbiAgaWYgKCFhbHBoYSkgcmVzZXRBbHBoYShkZXN0LCBkZXN0VywgZGVzdEgpO1xuICByZXR1cm4gZGVzdDtcbn07XG5cbn0se1wiLi9jb252b2x2ZVwiOjIsXCIuL3Jlc2l6ZV9maWx0ZXJfZ2VuXCI6Nn1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG52YXIgRklMVEVSX0lORk8gPSBfZGVyZXFfKCcuL3Jlc2l6ZV9maWx0ZXJfaW5mbycpOyAvLyBQcmVjaXNpb24gb2YgZml4ZWQgRlAgdmFsdWVzXG5cblxudmFyIEZJWEVEX0ZSQUNfQklUUyA9IDE0O1xuXG5mdW5jdGlvbiB0b0ZpeGVkUG9pbnQobnVtKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bSAqICgoMSA8PCBGSVhFRF9GUkFDX0JJVFMpIC0gMSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlc2l6ZUZpbHRlckdlbihxdWFsaXR5LCBzcmNTaXplLCBkZXN0U2l6ZSwgc2NhbGUsIG9mZnNldCkge1xuICB2YXIgZmlsdGVyRnVuY3Rpb24gPSBGSUxURVJfSU5GT1txdWFsaXR5XS5maWx0ZXI7XG4gIHZhciBzY2FsZUludmVydGVkID0gMS4wIC8gc2NhbGU7XG4gIHZhciBzY2FsZUNsYW1wZWQgPSBNYXRoLm1pbigxLjAsIHNjYWxlKTsgLy8gRm9yIHVwc2NhbGVcbiAgLy8gRmlsdGVyIHdpbmRvdyAoYXZlcmFnaW5nIGludGVydmFsKSwgc2NhbGVkIHRvIHNyYyBpbWFnZVxuXG4gIHZhciBzcmNXaW5kb3cgPSBGSUxURVJfSU5GT1txdWFsaXR5XS53aW4gLyBzY2FsZUNsYW1wZWQ7XG4gIHZhciBkZXN0UGl4ZWwsIHNyY1BpeGVsLCBzcmNGaXJzdCwgc3JjTGFzdCwgZmlsdGVyRWxlbWVudFNpemUsIGZsb2F0RmlsdGVyLCBmeHBGaWx0ZXIsIHRvdGFsLCBweGwsIGlkeCwgZmxvYXRWYWwsIGZpbHRlclRvdGFsLCBmaWx0ZXJWYWw7XG4gIHZhciBsZWZ0Tm90RW1wdHksIHJpZ2h0Tm90RW1wdHksIGZpbHRlclNoaWZ0LCBmaWx0ZXJTaXplO1xuICB2YXIgbWF4RmlsdGVyRWxlbWVudFNpemUgPSBNYXRoLmZsb29yKChzcmNXaW5kb3cgKyAxKSAqIDIpO1xuICB2YXIgcGFja2VkRmlsdGVyID0gbmV3IEludDE2QXJyYXkoKG1heEZpbHRlckVsZW1lbnRTaXplICsgMikgKiBkZXN0U2l6ZSk7XG4gIHZhciBwYWNrZWRGaWx0ZXJQdHIgPSAwO1xuICB2YXIgc2xvd0NvcHkgPSAhcGFja2VkRmlsdGVyLnN1YmFycmF5IHx8ICFwYWNrZWRGaWx0ZXIuc2V0OyAvLyBGb3IgZWFjaCBkZXN0aW5hdGlvbiBwaXhlbCBjYWxjdWxhdGUgc291cmNlIHJhbmdlIGFuZCBidWlsdCBmaWx0ZXIgdmFsdWVzXG5cbiAgZm9yIChkZXN0UGl4ZWwgPSAwOyBkZXN0UGl4ZWwgPCBkZXN0U2l6ZTsgZGVzdFBpeGVsKyspIHtcbiAgICAvLyBTY2FsaW5nIHNob3VsZCBiZSBkb25lIHJlbGF0aXZlIHRvIGNlbnRyYWwgcGl4ZWwgcG9pbnRcbiAgICBzcmNQaXhlbCA9IChkZXN0UGl4ZWwgKyAwLjUpICogc2NhbGVJbnZlcnRlZCArIG9mZnNldDtcbiAgICBzcmNGaXJzdCA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3Ioc3JjUGl4ZWwgLSBzcmNXaW5kb3cpKTtcbiAgICBzcmNMYXN0ID0gTWF0aC5taW4oc3JjU2l6ZSAtIDEsIE1hdGguY2VpbChzcmNQaXhlbCArIHNyY1dpbmRvdykpO1xuICAgIGZpbHRlckVsZW1lbnRTaXplID0gc3JjTGFzdCAtIHNyY0ZpcnN0ICsgMTtcbiAgICBmbG9hdEZpbHRlciA9IG5ldyBGbG9hdDMyQXJyYXkoZmlsdGVyRWxlbWVudFNpemUpO1xuICAgIGZ4cEZpbHRlciA9IG5ldyBJbnQxNkFycmF5KGZpbHRlckVsZW1lbnRTaXplKTtcbiAgICB0b3RhbCA9IDAuMDsgLy8gRmlsbCBmaWx0ZXIgdmFsdWVzIGZvciBjYWxjdWxhdGVkIHJhbmdlXG5cbiAgICBmb3IgKHB4bCA9IHNyY0ZpcnN0LCBpZHggPSAwOyBweGwgPD0gc3JjTGFzdDsgcHhsKyssIGlkeCsrKSB7XG4gICAgICBmbG9hdFZhbCA9IGZpbHRlckZ1bmN0aW9uKChweGwgKyAwLjUgLSBzcmNQaXhlbCkgKiBzY2FsZUNsYW1wZWQpO1xuICAgICAgdG90YWwgKz0gZmxvYXRWYWw7XG4gICAgICBmbG9hdEZpbHRlcltpZHhdID0gZmxvYXRWYWw7XG4gICAgfSAvLyBOb3JtYWxpemUgZmlsdGVyLCBjb252ZXJ0IHRvIGZpeGVkIHBvaW50IGFuZCBhY2N1bXVsYXRlIGNvbnZlcnNpb24gZXJyb3JcblxuXG4gICAgZmlsdGVyVG90YWwgPSAwO1xuXG4gICAgZm9yIChpZHggPSAwOyBpZHggPCBmbG9hdEZpbHRlci5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBmaWx0ZXJWYWwgPSBmbG9hdEZpbHRlcltpZHhdIC8gdG90YWw7XG4gICAgICBmaWx0ZXJUb3RhbCArPSBmaWx0ZXJWYWw7XG4gICAgICBmeHBGaWx0ZXJbaWR4XSA9IHRvRml4ZWRQb2ludChmaWx0ZXJWYWwpO1xuICAgIH0gLy8gQ29tcGVuc2F0ZSBub3JtYWxpemF0aW9uIGVycm9yLCB0byBtaW5pbWl6ZSBicmlnaHRuZXNzIGRyaWZ0XG5cblxuICAgIGZ4cEZpbHRlcltkZXN0U2l6ZSA+PiAxXSArPSB0b0ZpeGVkUG9pbnQoMS4wIC0gZmlsdGVyVG90YWwpOyAvL1xuICAgIC8vIE5vdyBwYWNrIGZpbHRlciB0byB1c2VhYmxlIGZvcm1cbiAgICAvL1xuICAgIC8vIDEuIFRyaW0gaGVhZGluZyBhbmQgdGFpbGluZyB6ZXJvIHZhbHVlcywgYW5kIGNvbXBlbnNhdGUgc2hpdGYvbGVuZ3RoXG4gICAgLy8gMi4gUHV0IGFsbCB0byBzaW5nbGUgYXJyYXkgaW4gdGhpcyBmb3JtYXQ6XG4gICAgLy9cbiAgICAvLyAgICBbIHBvcyBzaGlmdCwgZGF0YSBsZW5ndGgsIHZhbHVlMSwgdmFsdWUyLCB2YWx1ZTMsIC4uLiBdXG4gICAgLy9cblxuICAgIGxlZnROb3RFbXB0eSA9IDA7XG5cbiAgICB3aGlsZSAobGVmdE5vdEVtcHR5IDwgZnhwRmlsdGVyLmxlbmd0aCAmJiBmeHBGaWx0ZXJbbGVmdE5vdEVtcHR5XSA9PT0gMCkge1xuICAgICAgbGVmdE5vdEVtcHR5Kys7XG4gICAgfVxuXG4gICAgaWYgKGxlZnROb3RFbXB0eSA8IGZ4cEZpbHRlci5sZW5ndGgpIHtcbiAgICAgIHJpZ2h0Tm90RW1wdHkgPSBmeHBGaWx0ZXIubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHJpZ2h0Tm90RW1wdHkgPiAwICYmIGZ4cEZpbHRlcltyaWdodE5vdEVtcHR5XSA9PT0gMCkge1xuICAgICAgICByaWdodE5vdEVtcHR5LS07XG4gICAgICB9XG5cbiAgICAgIGZpbHRlclNoaWZ0ID0gc3JjRmlyc3QgKyBsZWZ0Tm90RW1wdHk7XG4gICAgICBmaWx0ZXJTaXplID0gcmlnaHROb3RFbXB0eSAtIGxlZnROb3RFbXB0eSArIDE7XG4gICAgICBwYWNrZWRGaWx0ZXJbcGFja2VkRmlsdGVyUHRyKytdID0gZmlsdGVyU2hpZnQ7IC8vIHNoaWZ0XG5cbiAgICAgIHBhY2tlZEZpbHRlcltwYWNrZWRGaWx0ZXJQdHIrK10gPSBmaWx0ZXJTaXplOyAvLyBzaXplXG5cbiAgICAgIGlmICghc2xvd0NvcHkpIHtcbiAgICAgICAgcGFja2VkRmlsdGVyLnNldChmeHBGaWx0ZXIuc3ViYXJyYXkobGVmdE5vdEVtcHR5LCByaWdodE5vdEVtcHR5ICsgMSksIHBhY2tlZEZpbHRlclB0cik7XG4gICAgICAgIHBhY2tlZEZpbHRlclB0ciArPSBmaWx0ZXJTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgZm9yIG9sZCBJRSA8IDExLCB3aXRob3V0IHN1YmFycmF5L3NldCBtZXRob2RzXG4gICAgICAgIGZvciAoaWR4ID0gbGVmdE5vdEVtcHR5OyBpZHggPD0gcmlnaHROb3RFbXB0eTsgaWR4KyspIHtcbiAgICAgICAgICBwYWNrZWRGaWx0ZXJbcGFja2VkRmlsdGVyUHRyKytdID0gZnhwRmlsdGVyW2lkeF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gemVybyBkYXRhLCB3cml0ZSBoZWFkZXIgb25seVxuICAgICAgcGFja2VkRmlsdGVyW3BhY2tlZEZpbHRlclB0cisrXSA9IDA7IC8vIHNoaWZ0XG5cbiAgICAgIHBhY2tlZEZpbHRlcltwYWNrZWRGaWx0ZXJQdHIrK10gPSAwOyAvLyBzaXplXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhY2tlZEZpbHRlcjtcbn07XG5cbn0se1wiLi9yZXNpemVfZmlsdGVyX2luZm9cIjo3fV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbm1vZHVsZS5leHBvcnRzID0gW3tcbiAgLy8gTmVhcmVzdCBuZWlib3IgKEJveClcbiAgd2luOiAwLjUsXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKHgpIHtcbiAgICByZXR1cm4geCA+PSAtMC41ICYmIHggPCAwLjUgPyAxLjAgOiAwLjA7XG4gIH1cbn0sIHtcbiAgLy8gSGFtbWluZ1xuICB3aW46IDEuMCxcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoeCkge1xuICAgIGlmICh4IDw9IC0xLjAgfHwgeCA+PSAxLjApIHtcbiAgICAgIHJldHVybiAwLjA7XG4gICAgfVxuXG4gICAgaWYgKHggPiAtMS4xOTIwOTI5MEUtMDcgJiYgeCA8IDEuMTkyMDkyOTBFLTA3KSB7XG4gICAgICByZXR1cm4gMS4wO1xuICAgIH1cblxuICAgIHZhciB4cGkgPSB4ICogTWF0aC5QSTtcbiAgICByZXR1cm4gTWF0aC5zaW4oeHBpKSAvIHhwaSAqICgwLjU0ICsgMC40NiAqIE1hdGguY29zKHhwaSAvIDEuMCkpO1xuICB9XG59LCB7XG4gIC8vIExhbmN6b3MsIHdpbiA9IDJcbiAgd2luOiAyLjAsXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKHgpIHtcbiAgICBpZiAoeCA8PSAtMi4wIHx8IHggPj0gMi4wKSB7XG4gICAgICByZXR1cm4gMC4wO1xuICAgIH1cblxuICAgIGlmICh4ID4gLTEuMTkyMDkyOTBFLTA3ICYmIHggPCAxLjE5MjA5MjkwRS0wNykge1xuICAgICAgcmV0dXJuIDEuMDtcbiAgICB9XG5cbiAgICB2YXIgeHBpID0geCAqIE1hdGguUEk7XG4gICAgcmV0dXJuIE1hdGguc2luKHhwaSkgLyB4cGkgKiBNYXRoLnNpbih4cGkgLyAyLjApIC8gKHhwaSAvIDIuMCk7XG4gIH1cbn0sIHtcbiAgLy8gTGFuY3pvcywgd2luID0gM1xuICB3aW46IDMuMCxcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoeCkge1xuICAgIGlmICh4IDw9IC0zLjAgfHwgeCA+PSAzLjApIHtcbiAgICAgIHJldHVybiAwLjA7XG4gICAgfVxuXG4gICAgaWYgKHggPiAtMS4xOTIwOTI5MEUtMDcgJiYgeCA8IDEuMTkyMDkyOTBFLTA3KSB7XG4gICAgICByZXR1cm4gMS4wO1xuICAgIH1cblxuICAgIHZhciB4cGkgPSB4ICogTWF0aC5QSTtcbiAgICByZXR1cm4gTWF0aC5zaW4oeHBpKSAvIHhwaSAqIE1hdGguc2luKHhwaSAvIDMuMCkgLyAoeHBpIC8gMy4wKTtcbiAgfVxufV07XG5cbn0se31dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG52YXIgY3JlYXRlRmlsdGVycyA9IF9kZXJlcV8oJy4vcmVzaXplX2ZpbHRlcl9nZW4nKTtcblxuZnVuY3Rpb24gcmVzZXRBbHBoYShkc3QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHB0ciA9IDMsXG4gICAgICBsZW4gPSB3aWR0aCAqIGhlaWdodCAqIDQgfCAwO1xuXG4gIHdoaWxlIChwdHIgPCBsZW4pIHtcbiAgICBkc3RbcHRyXSA9IDB4RkY7XG4gICAgcHRyID0gcHRyICsgNCB8IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNVaW50OEFycmF5KHNyYykge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc3JjLmJ1ZmZlciwgMCwgc3JjLmJ5dGVMZW5ndGgpO1xufVxuXG52YXIgSVNfTEUgPSB0cnVlOyAvLyBzaG91bGQgbm90IGNyYXNoIGV2ZXJ5dGhpbmcgb24gbW9kdWxlIGxvYWQgaW4gb2xkIGJyb3dzZXJzXG5cbnRyeSB7XG4gIElTX0xFID0gbmV3IFVpbnQzMkFycmF5KG5ldyBVaW50OEFycmF5KFsxLCAwLCAwLCAwXSkuYnVmZmVyKVswXSA9PT0gMTtcbn0gY2F0Y2ggKF9fKSB7fVxuXG5mdW5jdGlvbiBjb3B5SW50MTZhc0xFKHNyYywgdGFyZ2V0LCB0YXJnZXRfb2Zmc2V0KSB7XG4gIGlmIChJU19MRSkge1xuICAgIHRhcmdldC5zZXQoYXNVaW50OEFycmF5KHNyYyksIHRhcmdldF9vZmZzZXQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIHB0ciA9IHRhcmdldF9vZmZzZXQsIGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRhdGEgPSBzcmNbaV07XG4gICAgdGFyZ2V0W3B0cisrXSA9IGRhdGEgJiAweEZGO1xuICAgIHRhcmdldFtwdHIrK10gPSBkYXRhID4+IDggJiAweEZGO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVzaXplX3dhc20ob3B0aW9ucykge1xuICB2YXIgc3JjID0gb3B0aW9ucy5zcmM7XG4gIHZhciBzcmNXID0gb3B0aW9ucy53aWR0aDtcbiAgdmFyIHNyY0ggPSBvcHRpb25zLmhlaWdodDtcbiAgdmFyIGRlc3RXID0gb3B0aW9ucy50b1dpZHRoO1xuICB2YXIgZGVzdEggPSBvcHRpb25zLnRvSGVpZ2h0O1xuICB2YXIgc2NhbGVYID0gb3B0aW9ucy5zY2FsZVggfHwgb3B0aW9ucy50b1dpZHRoIC8gb3B0aW9ucy53aWR0aDtcbiAgdmFyIHNjYWxlWSA9IG9wdGlvbnMuc2NhbGVZIHx8IG9wdGlvbnMudG9IZWlnaHQgLyBvcHRpb25zLmhlaWdodDtcbiAgdmFyIG9mZnNldFggPSBvcHRpb25zLm9mZnNldFggfHwgMC4wO1xuICB2YXIgb2Zmc2V0WSA9IG9wdGlvbnMub2Zmc2V0WSB8fCAwLjA7XG4gIHZhciBkZXN0ID0gb3B0aW9ucy5kZXN0IHx8IG5ldyBVaW50OEFycmF5KGRlc3RXICogZGVzdEggKiA0KTtcbiAgdmFyIHF1YWxpdHkgPSB0eXBlb2Ygb3B0aW9ucy5xdWFsaXR5ID09PSAndW5kZWZpbmVkJyA/IDMgOiBvcHRpb25zLnF1YWxpdHk7XG4gIHZhciBhbHBoYSA9IG9wdGlvbnMuYWxwaGEgfHwgZmFsc2U7XG4gIHZhciBmaWx0ZXJzWCA9IGNyZWF0ZUZpbHRlcnMocXVhbGl0eSwgc3JjVywgZGVzdFcsIHNjYWxlWCwgb2Zmc2V0WCksXG4gICAgICBmaWx0ZXJzWSA9IGNyZWF0ZUZpbHRlcnMocXVhbGl0eSwgc3JjSCwgZGVzdEgsIHNjYWxlWSwgb2Zmc2V0WSk7IC8vIGRlc3RpbmF0aW9uIGlzIDAgdG9vLlxuXG4gIHZhciBzcmNfb2Zmc2V0ID0gMDsgLy8gYnVmZmVyIGJldHdlZW4gY29udm9sdmUgcGFzc2VzXG5cbiAgdmFyIHRtcF9vZmZzZXQgPSB0aGlzLl9fYWxpZ24oc3JjX29mZnNldCArIE1hdGgubWF4KHNyYy5ieXRlTGVuZ3RoLCBkZXN0LmJ5dGVMZW5ndGgpKTtcblxuICB2YXIgZmlsdGVyc1hfb2Zmc2V0ID0gdGhpcy5fX2FsaWduKHRtcF9vZmZzZXQgKyBzcmNIICogZGVzdFcgKiA0KTtcblxuICB2YXIgZmlsdGVyc1lfb2Zmc2V0ID0gdGhpcy5fX2FsaWduKGZpbHRlcnNYX29mZnNldCArIGZpbHRlcnNYLmJ5dGVMZW5ndGgpO1xuXG4gIHZhciBhbGxvY19ieXRlcyA9IGZpbHRlcnNZX29mZnNldCArIGZpbHRlcnNZLmJ5dGVMZW5ndGg7XG5cbiAgdmFyIGluc3RhbmNlID0gdGhpcy5fX2luc3RhbmNlKCdyZXNpemUnLCBhbGxvY19ieXRlcyk7IC8vXG4gIC8vIEZpbGwgbWVtb3J5IGJsb2NrIHdpdGggZGF0YSB0byBwcm9jZXNzXG4gIC8vXG5cblxuICB2YXIgbWVtID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fX21lbW9yeS5idWZmZXIpO1xuICB2YXIgbWVtMzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fX21lbW9yeS5idWZmZXIpOyAvLyAzMi1iaXQgY29weSBpcyBtdWNoIGZhc3RlciBpbiBjaHJvbWVcblxuICB2YXIgc3JjMzIgPSBuZXcgVWludDMyQXJyYXkoc3JjLmJ1ZmZlcik7XG4gIG1lbTMyLnNldChzcmMzMik7IC8vIFdlIHNob3VsZCBndWFyYW50ZWUgTEUgYnl0ZXMgb3JkZXIuIEZpbHRlcnMgYXJlIG5vdCBiaWcsIHNvXG4gIC8vIHNwZWVkIGRpZmZlcmVuY2UgaXMgbm90IHNpZ25pZmljYW50IHZzIGRpcmVjdCAuc2V0KClcblxuICBjb3B5SW50MTZhc0xFKGZpbHRlcnNYLCBtZW0sIGZpbHRlcnNYX29mZnNldCk7XG4gIGNvcHlJbnQxNmFzTEUoZmlsdGVyc1ksIG1lbSwgZmlsdGVyc1lfb2Zmc2V0KTsgLy9cbiAgLy8gTm93IGNhbGwgd2ViYXNzZW1ibHkgbWV0aG9kXG4gIC8vIGVtc2RrIGRvZXMgbWV0aG9kIG5hbWVzIHdpdGggJ18nXG5cbiAgdmFyIGZuID0gaW5zdGFuY2UuZXhwb3J0cy5jb252b2x2ZUhWIHx8IGluc3RhbmNlLmV4cG9ydHMuX2NvbnZvbHZlSFY7XG4gIGZuKGZpbHRlcnNYX29mZnNldCwgZmlsdGVyc1lfb2Zmc2V0LCB0bXBfb2Zmc2V0LCBzcmNXLCBzcmNILCBkZXN0VywgZGVzdEgpOyAvL1xuICAvLyBDb3B5IGRhdGEgYmFjayB0byB0eXBlZCBhcnJheVxuICAvL1xuICAvLyAzMi1iaXQgY29weSBpcyBtdWNoIGZhc3RlciBpbiBjaHJvbWVcblxuICB2YXIgZGVzdDMyID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyKTtcbiAgZGVzdDMyLnNldChuZXcgVWludDMyQXJyYXkodGhpcy5fX21lbW9yeS5idWZmZXIsIDAsIGRlc3RIICogZGVzdFcpKTsgLy8gVGhhdCdzIGZhc3RlciB0aGFuIGRvaW5nIGNoZWNrcyBpbiBjb252b2x2ZXIuXG4gIC8vICEhISBOb3RlLCBjYW52YXMgZGF0YSBpcyBub3QgcHJlbXVsdGlwbGVkLiBXZSBkb24ndCBuZWVkIG90aGVyXG4gIC8vIGFscGhhIGNvcnJlY3Rpb25zLlxuXG4gIGlmICghYWxwaGEpIHJlc2V0QWxwaGEoZGVzdCwgZGVzdFcsIGRlc3RIKTtcbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG59LHtcIi4vcmVzaXplX2ZpbHRlcl9nZW5cIjo2fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAndW5zaGFycF9tYXNrJyxcbiAgZm46IF9kZXJlcV8oJy4vdW5zaGFycF9tYXNrJyksXG4gIHdhc21fZm46IF9kZXJlcV8oJy4vdW5zaGFycF9tYXNrX3dhc20nKSxcbiAgd2FzbV9zcmM6IF9kZXJlcV8oJy4vdW5zaGFycF9tYXNrX3dhc21fYmFzZTY0Jylcbn07XG5cbn0se1wiLi91bnNoYXJwX21hc2tcIjoxMCxcIi4vdW5zaGFycF9tYXNrX3dhc21cIjoxMSxcIi4vdW5zaGFycF9tYXNrX3dhc21fYmFzZTY0XCI6MTJ9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbnZhciBnbHVyX21vbm8xNiA9IF9kZXJlcV8oJ2dsdXIvbW9ubzE2Jyk7XG5cbmZ1bmN0aW9uIGhzdl92MTYoaW1nLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBzaXplID0gd2lkdGggKiBoZWlnaHQ7XG4gIHZhciBvdXQgPSBuZXcgVWludDE2QXJyYXkoc2l6ZSk7XG4gIHZhciByLCBnLCBiLCBtYXg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICByID0gaW1nWzQgKiBpXTtcbiAgICBnID0gaW1nWzQgKiBpICsgMV07XG4gICAgYiA9IGltZ1s0ICogaSArIDJdO1xuICAgIG1heCA9IHIgPj0gZyAmJiByID49IGIgPyByIDogZyA+PSBiICYmIGcgPj0gciA/IGcgOiBiO1xuICAgIG91dFtpXSA9IG1heCA8PCA4O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1bnNoYXJwKGltZywgd2lkdGgsIGhlaWdodCwgYW1vdW50LCByYWRpdXMsIHRocmVzaG9sZCkge1xuICB2YXIgdjEsIHYyLCB2bXVsO1xuICB2YXIgZGlmZiwgaVRpbWVzNDtcblxuICBpZiAoYW1vdW50ID09PSAwIHx8IHJhZGl1cyA8IDAuNSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyYWRpdXMgPiAyLjApIHtcbiAgICByYWRpdXMgPSAyLjA7XG4gIH1cblxuICB2YXIgYnJpZ2h0bmVzcyA9IGhzdl92MTYoaW1nLCB3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIGJsdXJlZCA9IG5ldyBVaW50MTZBcnJheShicmlnaHRuZXNzKTsgLy8gY29weSwgYmVjYXVzZSBibHVyIG1vZGlmeSBzcmNcblxuICBnbHVyX21vbm8xNihibHVyZWQsIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7XG4gIHZhciBhbW91bnRGcCA9IGFtb3VudCAvIDEwMCAqIDB4MTAwMCArIDAuNSB8IDA7XG4gIHZhciB0aHJlc2hvbGRGcCA9IHRocmVzaG9sZCA8PCA4O1xuICB2YXIgc2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xuICAvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHYxID0gYnJpZ2h0bmVzc1tpXTtcbiAgICBkaWZmID0gdjEgLSBibHVyZWRbaV07XG5cbiAgICBpZiAoTWF0aC5hYnMoZGlmZikgPj0gdGhyZXNob2xkRnApIHtcbiAgICAgIC8vIGFkZCB1bnNoYXJwIG1hc2sgdG8gdGhlIGJyaWdodG5lc3MgY2hhbm5lbFxuICAgICAgdjIgPSB2MSArIChhbW91bnRGcCAqIGRpZmYgKyAweDgwMCA+PiAxMik7IC8vIEJvdGggdjEgYW5kIHYyIGFyZSB3aXRoaW4gWzAuMCAuLiAyNTUuMF0gKDAwMDAtRkYwMCkgcmFuZ2UsIG5ldmVyIGdvaW5nIGludG9cbiAgICAgIC8vIFsyNTUuMDAzIC4uIDI1NS45OTZdIChGRjAxLUZGRkYpLiBUaGlzIGFsbG93cyB0byByb3VuZCB0aGlzIHZhbHVlIGFzICh4Ky41KXwwXG4gICAgICAvLyBsYXRlciB3aXRob3V0IG92ZXJmbG93aW5nLlxuXG4gICAgICB2MiA9IHYyID4gMHhmZjAwID8gMHhmZjAwIDogdjI7XG4gICAgICB2MiA9IHYyIDwgMHgwMDAwID8gMHgwMDAwIDogdjI7IC8vIEF2b2lkIGRpdmlzaW9uIGJ5IDAuIFY9MCBtZWFucyByZ2IoMCwwLDApLCB1bnNoYXJwIHdpdGggdW5zaGFycEFtb3VudD4wIGNhbm5vdFxuICAgICAgLy8gY2hhbmdlIHRoaXMgdmFsdWUgKGJlY2F1c2UgZGlmZiBiZXR3ZWVuIGNvbG9ycyBnZXRzIGluZmxhdGVkKSwgc28gbm8gbmVlZCB0byB2ZXJpZnkgY29ycmVjdG5lc3MuXG5cbiAgICAgIHYxID0gdjEgIT09IDAgPyB2MSA6IDE7IC8vIE11bHRpcGx5aW5nIFYgaW4gSFNWIG1vZGVsIGJ5IGEgY29uc3RhbnQgaXMgZXF1aXZhbGVudCB0byBtdWx0aXBseWluZyBlYWNoIGNvbXBvbmVudFxuICAgICAgLy8gaW4gUkdCIGJ5IHRoZSBzYW1lIGNvbnN0YW50IChzYW1lIGZvciBIU0wpLCBzZWUgYWxzbzpcbiAgICAgIC8vIGh0dHBzOi8vYmVlc2J1enouYml6L2NvZGUvMTYtaHN2LWNvbG9yLXRyYW5zZm9ybXNcblxuICAgICAgdm11bCA9ICh2MiA8PCAxMikgLyB2MSB8IDA7IC8vIFJlc3VsdCB3aWxsIGJlIGluIFswLi4yNTVdIHJhbmdlIGJlY2F1c2U6XG4gICAgICAvLyAgLSBhbGwgbnVtYmVycyBhcmUgcG9zaXRpdmVcbiAgICAgIC8vICAtIHIsZyxiIDw9ICh2MS8yNTYpXG4gICAgICAvLyAgLSByLGcsYiwodjEvMjU2KSwodjIvMjU2KSA8PSAyNTVcbiAgICAgIC8vIFNvIGhpZ2hlc3QgdGhpcyBudW1iZXIgY2FuIGdldCBpcyBYKjI1NS9YKzAuNT0yNTUuNSB3aGljaCBpcyA8IDI1NiBhbmQgcm91bmRzIGRvd24uXG5cbiAgICAgIGlUaW1lczQgPSBpICogNDtcbiAgICAgIGltZ1tpVGltZXM0XSA9IGltZ1tpVGltZXM0XSAqIHZtdWwgKyAweDgwMCA+PiAxMjsgLy8gUlxuXG4gICAgICBpbWdbaVRpbWVzNCArIDFdID0gaW1nW2lUaW1lczQgKyAxXSAqIHZtdWwgKyAweDgwMCA+PiAxMjsgLy8gR1xuXG4gICAgICBpbWdbaVRpbWVzNCArIDJdID0gaW1nW2lUaW1lczQgKyAyXSAqIHZtdWwgKyAweDgwMCA+PiAxMjsgLy8gQlxuICAgIH1cbiAgfVxufTtcblxufSx7XCJnbHVyL21vbm8xNlwiOjE4fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuc2hhcnAoaW1nLCB3aWR0aCwgaGVpZ2h0LCBhbW91bnQsIHJhZGl1cywgdGhyZXNob2xkKSB7XG4gIGlmIChhbW91bnQgPT09IDAgfHwgcmFkaXVzIDwgMC41KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJhZGl1cyA+IDIuMCkge1xuICAgIHJhZGl1cyA9IDIuMDtcbiAgfVxuXG4gIHZhciBwaXhlbHMgPSB3aWR0aCAqIGhlaWdodDtcbiAgdmFyIGltZ19ieXRlc19jbnQgPSBwaXhlbHMgKiA0O1xuICB2YXIgaHN2X2J5dGVzX2NudCA9IHBpeGVscyAqIDI7XG4gIHZhciBibHVyX2J5dGVzX2NudCA9IHBpeGVscyAqIDI7XG4gIHZhciBibHVyX2xpbmVfYnl0ZV9jbnQgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSAqIDQ7IC8vIGZsb2F0MzIgYXJyYXlcblxuICB2YXIgYmx1cl9jb2VmZnNfYnl0ZV9jbnQgPSA4ICogNDsgLy8gZmxvYXQzMiBhcnJheVxuXG4gIHZhciBpbWdfb2Zmc2V0ID0gMDtcbiAgdmFyIGhzdl9vZmZzZXQgPSBpbWdfYnl0ZXNfY250O1xuICB2YXIgYmx1cl9vZmZzZXQgPSBoc3Zfb2Zmc2V0ICsgaHN2X2J5dGVzX2NudDtcbiAgdmFyIGJsdXJfdG1wX29mZnNldCA9IGJsdXJfb2Zmc2V0ICsgYmx1cl9ieXRlc19jbnQ7XG4gIHZhciBibHVyX2xpbmVfb2Zmc2V0ID0gYmx1cl90bXBfb2Zmc2V0ICsgYmx1cl9ieXRlc19jbnQ7XG4gIHZhciBibHVyX2NvZWZmc19vZmZzZXQgPSBibHVyX2xpbmVfb2Zmc2V0ICsgYmx1cl9saW5lX2J5dGVfY250O1xuXG4gIHZhciBpbnN0YW5jZSA9IHRoaXMuX19pbnN0YW5jZSgndW5zaGFycF9tYXNrJywgaW1nX2J5dGVzX2NudCArIGhzdl9ieXRlc19jbnQgKyBibHVyX2J5dGVzX2NudCAqIDIgKyBibHVyX2xpbmVfYnl0ZV9jbnQgKyBibHVyX2NvZWZmc19ieXRlX2NudCwge1xuICAgIGV4cDogTWF0aC5leHBcbiAgfSk7IC8vIDMyLWJpdCBjb3B5IGlzIG11Y2ggZmFzdGVyIGluIGNocm9tZVxuXG5cbiAgdmFyIGltZzMyID0gbmV3IFVpbnQzMkFycmF5KGltZy5idWZmZXIpO1xuICB2YXIgbWVtMzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fX21lbW9yeS5idWZmZXIpO1xuICBtZW0zMi5zZXQoaW1nMzIpOyAvLyBIU0xcblxuICB2YXIgZm4gPSBpbnN0YW5jZS5leHBvcnRzLmhzdl92MTYgfHwgaW5zdGFuY2UuZXhwb3J0cy5faHN2X3YxNjtcbiAgZm4oaW1nX29mZnNldCwgaHN2X29mZnNldCwgd2lkdGgsIGhlaWdodCk7IC8vIEJMVVJcblxuICBmbiA9IGluc3RhbmNlLmV4cG9ydHMuYmx1ck1vbm8xNiB8fCBpbnN0YW5jZS5leHBvcnRzLl9ibHVyTW9ubzE2O1xuICBmbihoc3Zfb2Zmc2V0LCBibHVyX29mZnNldCwgYmx1cl90bXBfb2Zmc2V0LCBibHVyX2xpbmVfb2Zmc2V0LCBibHVyX2NvZWZmc19vZmZzZXQsIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7IC8vIFVOU0hBUlBcblxuICBmbiA9IGluc3RhbmNlLmV4cG9ydHMudW5zaGFycCB8fCBpbnN0YW5jZS5leHBvcnRzLl91bnNoYXJwO1xuICBmbihpbWdfb2Zmc2V0LCBpbWdfb2Zmc2V0LCBoc3Zfb2Zmc2V0LCBibHVyX29mZnNldCwgd2lkdGgsIGhlaWdodCwgYW1vdW50LCB0aHJlc2hvbGQpOyAvLyAzMi1iaXQgY29weSBpcyBtdWNoIGZhc3RlciBpbiBjaHJvbWVcblxuICBpbWczMi5zZXQobmV3IFVpbnQzMkFycmF5KHRoaXMuX19tZW1vcnkuYnVmZmVyLCAwLCBwaXhlbHMpKTtcbn07XG5cbn0se31dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSAnQUdGemJRRUFBQUFBREFaa2VXeHBibXNBQUFBQUFBRTBCMkFBQUdBRWYzOS9md0JnQm45L2YzOS9md0JnQ0g5L2YzOS9mMzkvQUdBSWYzOS9mMzkvZjMwQVlBSjlmd0JnQVh3QmZBSVpBZ05sYm5ZRFpYaHdBQVlEWlc1MkJtMWxiVzl5ZVFJQUFBTUhCZ0FGQWdRQkF3WUdBWDhBUVFBTEI0b0JDQkZmWDNkaGMyMWZZMkZzYkY5amRHOXljd0FCRmw5ZlluVnBiR1JmWjJGMWMzTnBZVzVmWTI5bFpuTUFBZzVmWDJkaGRYTnpNVFpmYkdsdVpRQURDbUpzZFhKTmIyNXZNVFlBQkFkb2MzWmZkakUyQUFVSGRXNXphR0Z5Y0FBR0RGOWZaSE52WDJoaGJtUnNaUU1BR0Y5ZmQyRnpiVjloY0hCc2VWOWtZWFJoWDNKbGJHOWpjd0FCQ3NVTUJnTUFBUXZXQVFFSGZDQUJSTnVHdWtPQ0d2cy9JQUM3b3lJQ1JBQUFBQUFBQUFEQW9oQUFJZ1cyakRnQ0ZDQUJJQUthRUFBaUF5QURvQ0lHdGpnQ0VDQUJSQUFBQUFBQUFQQS9JQU9oSWdRZ0JLSWdBeUFDSUFLZ29rUUFBQUFBQUFEd1A2QWdCYUdqSWdTMk9BSUFJQUVnQlNBRW1xSWlCN1k0QWd3Z0FTQURJQUpFQUFBQUFBQUE4RCtnSUFTaW9pSUl0amdDQ0NBQklBTWdBa1FBQUFBQUFBRHd2NkFnQktLaUlnSzJPQUlFSUFFZ0J5QUlvQ0FGUkFBQUFBQUFBUEEvSUFhaG9DSURvN1k0QWh3Z0FTQUVJQUtnSUFPanRqZ0NHQXVHQlFNR2Z3bDhBbjBnQXlvQ0RDRVZJQU1xQWdnaEZpQURLZ0lVdXlFUklBTXFBaEM3SVJBQ1FDQUVRUUZySWdoQkFFZ2lDUVJBSUFJaEJ5QUFJUVlNQVFzZ0FpQUFMd0VBdUNJUElBTXFBaGk3b2lJTUlCR2lJZzBnRENBUW9pQVBJQU1xQWdTN0loT2lJaFFnQXlvQ0FMc2lFaUFQb3FDZ29DSU90amdDQUNBQ1FRUnFJUWNnQUVFQ2FpRUdJQWhGRFFBZ0NFRUJJQWhCQVVnYklncEJmM01oQ3dKL0lBUWdDbXRCQVhGRkJFQWdEaUVOSUFnTUFRc2dBaUFOSUE0Z0VLSWdGQ0FTSUFBdkFRSzRJZytpb0tDZ0lnMjJPQUlFSUFKQkNHb2hCeUFBUVFScUlRWWdEaUVNSUFSQkFtc0xJUUlnQzBFQUlBUnJSZzBBQTBBZ0J5QU1JQkdpSUEwZ0VLSWdEeUFUb2lBU0lBWXZBUUM0SWc2aW9LQ2dJZ3kyT0FJQUlBY2dEU0FSb2lBTUlCQ2lJQTRnRTZJZ0VpQUdMd0VDdUNJUG9xQ2dvQ0lOdGpnQ0JDQUhRUWhxSVFjZ0JrRUVhaUVHSUFKQkFrb2hBQ0FDUVFKcklRSWdBQTBBQ3dzQ1FDQUpEUUFnQVNBRklBaHNRUUYwYWlJQUFuOGdCa0VDYXk4QkFDSUN1Q0lOSUJXN0loS2lJQTBnRnJzaUU2S2dJQTBnQXlvQ0hMdWlJZ3dnRUtLZ0lBd2dFYUtnSWc4Z0IwRUVheUlIS2dJQXU2QWlEa1FBQUFBQUFBRHdRV01nRGtRQUFBQUFBQUFBQUdaeEJFQWdEcXNNQVF0QkFBczdBUUFnQ0VVTkFDQUdRUVJySVFaQkFDQUZhMEVCZENFQkEwQUNmeUFOSUJLaUlBSkIvLzhEY2JnaURTQVRvcUFnRHlJT0lCQ2lvQ0FNSUJHaW9DSVBJQWRCQkdzaUJ5b0NBTHVnSWd4RUFBQUFBQUFBOEVGaklBeEVBQUFBQUFBQUFBQm1jUVJBSUF5ckRBRUxRUUFMSVFNZ0JpOEJBQ0VDSUFBZ0FXb2lBQ0FET3dFQUlBWkJBbXNoQmlBSVFRRktJUU1nRGlFTUlBaEJBV3NoQ0NBRERRQUxDd3ZSQWdJQmZ3ZDhBa0FnQjBNQUFBQUFXdzBBSUFSRTI0YTZRNElhK3o4Z0IwTUFBQUEvbDd1aklnbEVBQUFBQUFBQUFNQ2lFQUFpRExhTU9BSVVJQVFnQ1pvUUFDSUtJQXFnSWcyMk9BSVFJQVJFQUFBQUFBQUE4RDhnQ3FFaUN5QUxvaUFLSUFrZ0NhQ2lSQUFBQUFBQUFQQS9vQ0FNb2FNaUM3WTRBZ0FnQkNBTUlBdWFvaUlPdGpnQ0RDQUVJQW9nQ1VRQUFBQUFBQUR3UDZBZ0M2S2lJZysyT0FJSUlBUWdDaUFKUkFBQUFBQUFBUEMvb0NBTG9xSWlDYlk0QWdRZ0JDQU9JQStnSUF4RUFBQUFBQUFBOEQ4Z0RhR2dJZ3FqdGpnQ0hDQUVJQXNnQ2FBZ0NxTzJPQUlZSUFZRVFBTkFJQUFnQlNBSWJFRUJkR29nQWlBSVFRRjBhaUFESUFRZ0JTQUdFQU1nQ0VFQmFpSUlJQVpIRFFBTEN5QUZSUTBBUVFBaENBTkFJQUlnQmlBSWJFRUJkR29nQVNBSVFRRjBhaUFESUFRZ0JpQUZFQU1nQ0VFQmFpSUlJQVZIRFFBTEN3dHhBUU4vSUFJZ0Eyd2lCUVJBQTBBZ0FTQUFLQUlBSWdSQkVIWkIvd0Z4SWdJZ0FpQUVRUWgyUWY4QmNTSURJQU1nQkVIL0FYRWlCRWtiSUFJZ0Ewc2JJZ1lnQmlBRUlBSWdCRXNiSUFNZ0JFc2JRUWgwT3dFQUlBRkJBbW9oQVNBQVFRUnFJUUFnQlVFQmF5SUZEUUFMQ3d1WkFnSURmd0Y4SUFRZ0JXd2hCQUovSUFhelF3QUFnRVdVUXdBQXlFS1Z1MFFBQUFBQUFBRGdQNkFpQzVsRUFBQUFBQUFBNEVGakJFQWdDNm9NQVF0QmdJQ0FnSGdMSVFVZ0JBUkFJQWRCQ0hRaENVRUFJUVlEUUNBSklBSWdCa0VCZENJSGFpOEJBQ0lCSUFNZ0Iyb3ZBUUJySWdjZ0IwRWZkU0lJYWlBSWMwMEVRQ0FBSUFaQkFuUWlDR29pQ2lBRklBZHNRWUFRYWtFTWRTQUJhaUlIUVlEK0F5QUhRWUQrQTBnYklnZEJBQ0FIUVFCS0cwRU1kQ0FCUVFFZ0FSdHVJZ0VnQ2kwQUFHeEJnQkJxUVF4Mk9nQUFJQUFnQ0VFQmNtb2lCeUFCSUFjdEFBQnNRWUFRYWtFTWRqb0FBQ0FBSUFoQkFuSnFJZ2NnQVNBSExRQUFiRUdBRUdwQkRIWTZBQUFMSUFaQkFXb2lCaUFFUncwQUN3c0wnO1xuXG59LHt9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cbnZhciBHQ19JTlRFUlZBTCA9IDEwMDtcblxuZnVuY3Rpb24gUG9vbChjcmVhdGUsIGlkbGUpIHtcbiAgdGhpcy5jcmVhdGUgPSBjcmVhdGU7XG4gIHRoaXMuYXZhaWxhYmxlID0gW107XG4gIHRoaXMuYWNxdWlyZWQgPSB7fTtcbiAgdGhpcy5sYXN0SWQgPSAxO1xuICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gIHRoaXMuaWRsZSA9IGlkbGUgfHwgMjAwMDtcbn1cblxuUG9vbC5wcm90b3R5cGUuYWNxdWlyZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVzb3VyY2U7XG5cbiAgaWYgKHRoaXMuYXZhaWxhYmxlLmxlbmd0aCAhPT0gMCkge1xuICAgIHJlc291cmNlID0gdGhpcy5hdmFpbGFibGUucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb3VyY2UgPSB0aGlzLmNyZWF0ZSgpO1xuICAgIHJlc291cmNlLmlkID0gdGhpcy5sYXN0SWQrKztcblxuICAgIHJlc291cmNlLnJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucmVsZWFzZShyZXNvdXJjZSk7XG4gICAgfTtcbiAgfVxuXG4gIHRoaXMuYWNxdWlyZWRbcmVzb3VyY2UuaWRdID0gcmVzb3VyY2U7XG4gIHJldHVybiByZXNvdXJjZTtcbn07XG5cblBvb2wucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgZGVsZXRlIHRoaXMuYWNxdWlyZWRbcmVzb3VyY2UuaWRdO1xuICByZXNvdXJjZS5sYXN0VXNlZCA9IERhdGUubm93KCk7XG4gIHRoaXMuYXZhaWxhYmxlLnB1c2gocmVzb3VyY2UpO1xuXG4gIGlmICh0aGlzLnRpbWVvdXRJZCA9PT0gMCkge1xuICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLmdjKCk7XG4gICAgfSwgR0NfSU5URVJWQUwpO1xuICB9XG59O1xuXG5Qb29sLnByb3RvdHlwZS5nYyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gIHRoaXMuYXZhaWxhYmxlID0gdGhpcy5hdmFpbGFibGUuZmlsdGVyKGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgIGlmIChub3cgLSByZXNvdXJjZS5sYXN0VXNlZCA+IF90aGlzMy5pZGxlKSB7XG4gICAgICByZXNvdXJjZS5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIGlmICh0aGlzLmF2YWlsYWJsZS5sZW5ndGggIT09IDApIHtcbiAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzMy5nYygpO1xuICAgIH0sIEdDX0lOVEVSVkFMKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbDtcblxufSx7fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gbWluIHNpemUgPSAxIGNhbiBjb25zdW1lIGxhcmdlIGFtb3VudCBvZiBtZW1vcnlcblxudmFyIE1JTl9JTk5FUl9USUxFX1NJWkUgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZVN0YWdlcyhmcm9tV2lkdGgsIGZyb21IZWlnaHQsIHRvV2lkdGgsIHRvSGVpZ2h0LCBzcmNUaWxlU2l6ZSwgZGVzdFRpbGVCb3JkZXIpIHtcbiAgdmFyIHNjYWxlWCA9IHRvV2lkdGggLyBmcm9tV2lkdGg7XG4gIHZhciBzY2FsZVkgPSB0b0hlaWdodCAvIGZyb21IZWlnaHQ7IC8vIGRlcml2ZWQgZnJvbSBjcmVhdGVSZWdpb25zIGVxdWF0aW9uOlxuICAvLyBpbm5lclRpbGVXaWR0aCA9IHBpeGVsRmxvb3Ioc3JjVGlsZVNpemUgKiBzY2FsZVgpIC0gMiAqIGRlc3RUaWxlQm9yZGVyO1xuXG4gIHZhciBtaW5TY2FsZSA9ICgyICogZGVzdFRpbGVCb3JkZXIgKyBNSU5fSU5ORVJfVElMRV9TSVpFICsgMSkgLyBzcmNUaWxlU2l6ZTsgLy8gcmVmdXNlIHRvIHNjYWxlIGltYWdlIG11bHRpcGxlIHRpbWVzIGJ5IGxlc3MgdGhhbiB0d2ljZSBlYWNoIHRpbWUsXG4gIC8vIGl0IGNvdWxkIG9ubHkgaGFwcGVuIGJlY2F1c2Ugb2YgaW52YWxpZCBvcHRpb25zXG5cbiAgaWYgKG1pblNjYWxlID4gMC41KSByZXR1cm4gW1t0b1dpZHRoLCB0b0hlaWdodF1dO1xuICB2YXIgc3RhZ2VDb3VudCA9IE1hdGguY2VpbChNYXRoLmxvZyhNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSkpIC8gTWF0aC5sb2cobWluU2NhbGUpKTsgLy8gbm8gYWRkaXRpb25hbCByZXNpemVzIGFyZSBuZWNlc3NhcnksXG4gIC8vIHN0YWdlQ291bnQgY2FuIGJlIHplcm8gb3IgYmUgbmVnYXRpdmUgd2hlbiBlbmxhcmdpbmcgdGhlIGltYWdlXG5cbiAgaWYgKHN0YWdlQ291bnQgPD0gMSkgcmV0dXJuIFtbdG9XaWR0aCwgdG9IZWlnaHRdXTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhZ2VDb3VudDsgaSsrKSB7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5yb3VuZChNYXRoLnBvdyhNYXRoLnBvdyhmcm9tV2lkdGgsIHN0YWdlQ291bnQgLSBpIC0gMSkgKiBNYXRoLnBvdyh0b1dpZHRoLCBpICsgMSksIDEgLyBzdGFnZUNvdW50KSk7XG4gICAgdmFyIGhlaWdodCA9IE1hdGgucm91bmQoTWF0aC5wb3coTWF0aC5wb3coZnJvbUhlaWdodCwgc3RhZ2VDb3VudCAtIGkgLSAxKSAqIE1hdGgucG93KHRvSGVpZ2h0LCBpICsgMSksIDEgLyBzdGFnZUNvdW50KSk7XG4gICAgcmVzdWx0LnB1c2goW3dpZHRoLCBoZWlnaHRdKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG59LHt9XSwxNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogcGl4ZWxGbG9vciBhbmQgcGl4ZWxDZWlsIGFyZSBtb2RpZmllZCB2ZXJzaW9ucyBvZiBNYXRoLmZsb29yIGFuZCBNYXRoLmNlaWxcbiAqIGZ1bmN0aW9ucyB3aGljaCB0YWtlIGludG8gYWNjb3VudCBmbG9hdGluZyBwb2ludCBhcml0aG1ldGljIGVycm9ycy5cbiAqIFRob3NlIGVycm9ycyBjYW4gY2F1c2UgdW5kZXNpcmVkIGluY3JlbWVudHMvZGVjcmVtZW50cyBvZiBzaXplcyBhbmQgb2Zmc2V0czpcbiAqIE1hdGguY2VpbCgzNiAvICgzNiAvIDUwMCkpID0gNTAxXG4gKiBwaXhlbENlaWwoMzYgLyAoMzYgLyA1MDApKSA9IDUwMFxuICovXG5cbnZhciBQSVhFTF9FUFNJTE9OID0gMWUtNTtcblxuZnVuY3Rpb24gcGl4ZWxGbG9vcih4KSB7XG4gIHZhciBuZWFyZXN0ID0gTWF0aC5yb3VuZCh4KTtcblxuICBpZiAoTWF0aC5hYnMoeCAtIG5lYXJlc3QpIDwgUElYRUxfRVBTSUxPTikge1xuICAgIHJldHVybiBuZWFyZXN0O1xuICB9XG5cbiAgcmV0dXJuIE1hdGguZmxvb3IoeCk7XG59XG5cbmZ1bmN0aW9uIHBpeGVsQ2VpbCh4KSB7XG4gIHZhciBuZWFyZXN0ID0gTWF0aC5yb3VuZCh4KTtcblxuICBpZiAoTWF0aC5hYnMoeCAtIG5lYXJlc3QpIDwgUElYRUxfRVBTSUxPTikge1xuICAgIHJldHVybiBuZWFyZXN0O1xuICB9XG5cbiAgcmV0dXJuIE1hdGguY2VpbCh4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVSZWdpb25zKG9wdGlvbnMpIHtcbiAgdmFyIHNjYWxlWCA9IG9wdGlvbnMudG9XaWR0aCAvIG9wdGlvbnMud2lkdGg7XG4gIHZhciBzY2FsZVkgPSBvcHRpb25zLnRvSGVpZ2h0IC8gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBpbm5lclRpbGVXaWR0aCA9IHBpeGVsRmxvb3Iob3B0aW9ucy5zcmNUaWxlU2l6ZSAqIHNjYWxlWCkgLSAyICogb3B0aW9ucy5kZXN0VGlsZUJvcmRlcjtcbiAgdmFyIGlubmVyVGlsZUhlaWdodCA9IHBpeGVsRmxvb3Iob3B0aW9ucy5zcmNUaWxlU2l6ZSAqIHNjYWxlWSkgLSAyICogb3B0aW9ucy5kZXN0VGlsZUJvcmRlcjsgLy8gcHJldmVudCBpbmZpbml0ZSBsb29wLCB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW5cblxuICBpZiAoaW5uZXJUaWxlV2lkdGggPCAxIHx8IGlubmVyVGlsZUhlaWdodCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGVycm9yIGluIHBpY2E6IHRhcmdldCB0aWxlIHdpZHRoL2hlaWdodCBpcyB0b28gc21hbGwuJyk7XG4gIH1cblxuICB2YXIgeCwgeTtcbiAgdmFyIGlubmVyWCwgaW5uZXJZLCB0b1RpbGVXaWR0aCwgdG9UaWxlSGVpZ2h0O1xuICB2YXIgdGlsZXMgPSBbXTtcbiAgdmFyIHRpbGU7IC8vIHdlIGdvIHRvcC10by1kb3duIGluc3RlYWQgb2YgbGVmdC10by1yaWdodCB0byBtYWtlIGltYWdlIGRpc3BsYXllZCBmcm9tIHRvcCB0b1xuICAvLyBkb2VzbiBpbiB0aGUgYnJvd3NlclxuXG4gIGZvciAoaW5uZXJZID0gMDsgaW5uZXJZIDwgb3B0aW9ucy50b0hlaWdodDsgaW5uZXJZICs9IGlubmVyVGlsZUhlaWdodCkge1xuICAgIGZvciAoaW5uZXJYID0gMDsgaW5uZXJYIDwgb3B0aW9ucy50b1dpZHRoOyBpbm5lclggKz0gaW5uZXJUaWxlV2lkdGgpIHtcbiAgICAgIHggPSBpbm5lclggLSBvcHRpb25zLmRlc3RUaWxlQm9yZGVyO1xuXG4gICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgeCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRvVGlsZVdpZHRoID0gaW5uZXJYICsgaW5uZXJUaWxlV2lkdGggKyBvcHRpb25zLmRlc3RUaWxlQm9yZGVyIC0geDtcblxuICAgICAgaWYgKHggKyB0b1RpbGVXaWR0aCA+PSBvcHRpb25zLnRvV2lkdGgpIHtcbiAgICAgICAgdG9UaWxlV2lkdGggPSBvcHRpb25zLnRvV2lkdGggLSB4O1xuICAgICAgfVxuXG4gICAgICB5ID0gaW5uZXJZIC0gb3B0aW9ucy5kZXN0VGlsZUJvcmRlcjtcblxuICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgIHkgPSAwO1xuICAgICAgfVxuXG4gICAgICB0b1RpbGVIZWlnaHQgPSBpbm5lclkgKyBpbm5lclRpbGVIZWlnaHQgKyBvcHRpb25zLmRlc3RUaWxlQm9yZGVyIC0geTtcblxuICAgICAgaWYgKHkgKyB0b1RpbGVIZWlnaHQgPj0gb3B0aW9ucy50b0hlaWdodCkge1xuICAgICAgICB0b1RpbGVIZWlnaHQgPSBvcHRpb25zLnRvSGVpZ2h0IC0geTtcbiAgICAgIH1cblxuICAgICAgdGlsZSA9IHtcbiAgICAgICAgdG9YOiB4LFxuICAgICAgICB0b1k6IHksXG4gICAgICAgIHRvV2lkdGg6IHRvVGlsZVdpZHRoLFxuICAgICAgICB0b0hlaWdodDogdG9UaWxlSGVpZ2h0LFxuICAgICAgICB0b0lubmVyWDogaW5uZXJYLFxuICAgICAgICB0b0lubmVyWTogaW5uZXJZLFxuICAgICAgICB0b0lubmVyV2lkdGg6IGlubmVyVGlsZVdpZHRoLFxuICAgICAgICB0b0lubmVySGVpZ2h0OiBpbm5lclRpbGVIZWlnaHQsXG4gICAgICAgIG9mZnNldFg6IHggLyBzY2FsZVggLSBwaXhlbEZsb29yKHggLyBzY2FsZVgpLFxuICAgICAgICBvZmZzZXRZOiB5IC8gc2NhbGVZIC0gcGl4ZWxGbG9vcih5IC8gc2NhbGVZKSxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICB4OiBwaXhlbEZsb29yKHggLyBzY2FsZVgpLFxuICAgICAgICB5OiBwaXhlbEZsb29yKHkgLyBzY2FsZVkpLFxuICAgICAgICB3aWR0aDogcGl4ZWxDZWlsKHRvVGlsZVdpZHRoIC8gc2NhbGVYKSxcbiAgICAgICAgaGVpZ2h0OiBwaXhlbENlaWwodG9UaWxlSGVpZ2h0IC8gc2NhbGVZKVxuICAgICAgfTtcbiAgICAgIHRpbGVzLnB1c2godGlsZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRpbGVzO1xufTtcblxufSx7fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5mdW5jdGlvbiBvYmpDbGFzcyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5pc0NhbnZhcyA9IGZ1bmN0aW9uIGlzQ2FudmFzKGVsZW1lbnQpIHtcbiAgdmFyIGNuYW1lID0gb2JqQ2xhc3MoZWxlbWVudCk7XG4gIHJldHVybiBjbmFtZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJ1xuICAvKiBicm93c2VyICovXG4gIHx8IGNuYW1lID09PSAnW29iamVjdCBPZmZzY3JlZW5DYW52YXNdJyB8fCBjbmFtZSA9PT0gJ1tvYmplY3QgQ2FudmFzXSdcbiAgLyogbm9kZS1jYW52YXMgKi9cbiAgO1xufTtcblxubW9kdWxlLmV4cG9ydHMuaXNJbWFnZSA9IGZ1bmN0aW9uIGlzSW1hZ2UoZWxlbWVudCkge1xuICByZXR1cm4gb2JqQ2xhc3MoZWxlbWVudCkgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJztcbn07XG5cbm1vZHVsZS5leHBvcnRzLmlzSW1hZ2VCaXRtYXAgPSBmdW5jdGlvbiBpc0ltYWdlQml0bWFwKGVsZW1lbnQpIHtcbiAgcmV0dXJuIG9iakNsYXNzKGVsZW1lbnQpID09PSAnW29iamVjdCBJbWFnZUJpdG1hcF0nO1xufTtcblxubW9kdWxlLmV4cG9ydHMubGltaXRlciA9IGZ1bmN0aW9uIGxpbWl0ZXIoY29uY3VycmVuY3kpIHtcbiAgdmFyIGFjdGl2ZSA9IDAsXG4gICAgICBxdWV1ZSA9IFtdO1xuXG4gIGZ1bmN0aW9uIHJvbGwoKSB7XG4gICAgaWYgKGFjdGl2ZSA8IGNvbmN1cnJlbmN5ICYmIHF1ZXVlLmxlbmd0aCkge1xuICAgICAgYWN0aXZlKys7XG4gICAgICBxdWV1ZS5zaGlmdCgpKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbWl0KGZuKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICBmbigpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICBhY3RpdmUtLTtcbiAgICAgICAgICByb2xsKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICBhY3RpdmUtLTtcbiAgICAgICAgICByb2xsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByb2xsKCk7XG4gICAgfSk7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jaWJfcXVhbGl0eV9uYW1lID0gZnVuY3Rpb24gY2liX3F1YWxpdHlfbmFtZShudW0pIHtcbiAgc3dpdGNoIChudW0pIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gJ3BpeGVsYXRlZCc7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gJ2xvdyc7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gJ21lZGl1bSc7XG4gIH1cblxuICByZXR1cm4gJ2hpZ2gnO1xufTtcblxubW9kdWxlLmV4cG9ydHMuY2liX3N1cHBvcnQgPSBmdW5jdGlvbiBjaWJfc3VwcG9ydChjcmVhdGVDYW52YXMpIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGMgPSBjcmVhdGVDYW52YXMoMTAwLCAxMDApO1xuICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChjLCAwLCAwLCAxMDAsIDEwMCwge1xuICAgICAgcmVzaXplV2lkdGg6IDEwLFxuICAgICAgcmVzaXplSGVpZ2h0OiAxMCxcbiAgICAgIHJlc2l6ZVF1YWxpdHk6ICdoaWdoJ1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGJpdG1hcCkge1xuICAgICAgdmFyIHN0YXR1cyA9IGJpdG1hcC53aWR0aCA9PT0gMTA7IC8vIEJyYW5jaCBiZWxvdyBpcyBmaWx0ZXJlZCBvbiB1cHBlciBsZXZlbC4gV2UgZG8gbm90IGNhbGwgcmVzaXplXG4gICAgICAvLyBkZXRlY3Rpb24gZm9yIGJhc2ljIEltYWdlQml0bWFwLlxuICAgICAgLy9cbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JbWFnZUJpdG1hcFxuICAgICAgLy8gb2xkIENyb21lIDUxIGhhcyBJbWFnZUJpdG1hcCB3aXRob3V0IC5jbG9zZSgpLiBUaGVuIHRoaXMgY29kZVxuICAgICAgLy8gd2lsbCB0aHJvdyBhbmQgcmV0dXJuICdmYWxzZScgYXMgZXhwZWN0ZWQuXG4gICAgICAvL1xuXG4gICAgICBiaXRtYXAuY2xvc2UoKTtcbiAgICAgIGMgPSBudWxsO1xuICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9KTtcbiAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLndvcmtlcl9vZmZzY3JlZW5fY2FudmFzX3N1cHBvcnQgPSBmdW5jdGlvbiB3b3JrZXJfb2Zmc2NyZWVuX2NhbnZhc19zdXBwb3J0KCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gaWYgT2Zmc2NyZWVuQ2FudmFzIGlzIHByZXNlbnQsIHdlIGFzc3VtZSBicm93c2VyIHN1cHBvcnRzIFdvcmtlciBhbmQgYnVpbHQtaW4gUHJvbWlzZSBhcyB3ZWxsXG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3b3JrZXJQYXlsb2FkKHNlbGYpIHtcbiAgICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxMCwgMTApOyAvLyB0ZXN0IHRoYXQgMmQgY29udGV4dCBjYW4gYmUgdXNlZCBpbiB3b3JrZXJcblxuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5yZWN0KDAsIDAsIDEsIDEpOyAvLyB0ZXN0IHRoYXQgY2liIGNhbiBiZSB1c2VkIHRvIHJldHVybiBpbWFnZSBiaXRtYXAgZnJvbSB3b3JrZXJcblxuICAgICAgICByZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAoY2FudmFzLCAwLCAwLCAxLCAxKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5wb3N0TWVzc2FnZSh0cnVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucG9zdE1lc3NhZ2UoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNvZGUgPSBidG9hKFwiKFwiLmNvbmNhdCh3b3JrZXJQYXlsb2FkLnRvU3RyaW5nKCksIFwiKShzZWxmKTtcIikpO1xuICAgIHZhciB3ID0gbmV3IFdvcmtlcihcImRhdGE6dGV4dC9qYXZhc2NyaXB0O2Jhc2U2NCxcIi5jb25jYXQoY29kZSkpO1xuXG4gICAgdy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKGV2LmRhdGEpO1xuICAgIH07XG5cbiAgICB3Lm9uZXJyb3IgPSByZWplY3Q7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufTsgLy8gQ2hlY2sgaWYgY2FudmFzLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhIGNhbiBiZSB1c2VkLFxuLy8gRmlyZUZveCByYW5kb21pemVzIHRoZSBvdXRwdXQgb2YgdGhhdCBmdW5jdGlvbiBpbiBgcHJpdmFjeS5yZXNpc3RGaW5nZXJwcmludGluZ2AgbW9kZVxuXG5cbm1vZHVsZS5leHBvcnRzLmNhbl91c2VfY2FudmFzID0gZnVuY3Rpb24gY2FuX3VzZV9jYW52YXMoY3JlYXRlQ2FudmFzKSB7XG4gIHZhciB1c2FibGUgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBjYW52YXMgPSBjcmVhdGVDYW52YXMoMiwgMSk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBkID0gY3R4LmNyZWF0ZUltYWdlRGF0YSgyLCAxKTtcbiAgICBkLmRhdGFbMF0gPSAxMjtcbiAgICBkLmRhdGFbMV0gPSAyMztcbiAgICBkLmRhdGFbMl0gPSAzNDtcbiAgICBkLmRhdGFbM10gPSAyNTU7XG4gICAgZC5kYXRhWzRdID0gNDU7XG4gICAgZC5kYXRhWzVdID0gNTY7XG4gICAgZC5kYXRhWzZdID0gNjc7XG4gICAgZC5kYXRhWzddID0gMjU1O1xuICAgIGN0eC5wdXRJbWFnZURhdGEoZCwgMCwgMCk7XG4gICAgZCA9IG51bGw7XG4gICAgZCA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMiwgMSk7XG5cbiAgICBpZiAoZC5kYXRhWzBdID09PSAxMiAmJiBkLmRhdGFbMV0gPT09IDIzICYmIGQuZGF0YVsyXSA9PT0gMzQgJiYgZC5kYXRhWzNdID09PSAyNTUgJiYgZC5kYXRhWzRdID09PSA0NSAmJiBkLmRhdGFbNV0gPT09IDU2ICYmIGQuZGF0YVs2XSA9PT0gNjcgJiYgZC5kYXRhWzddID09PSAyNTUpIHtcbiAgICAgIHVzYWJsZSA9IHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgcmV0dXJuIHVzYWJsZTtcbn07IC8vIENoZWNrIGlmIGNyZWF0ZUltYWdlQml0bWFwKGltZywgc3gsIHN5LCBzdywgc2gpIHNpZ25hdHVyZSB3b3JrcyBjb3JyZWN0bHlcbi8vIHdpdGggSlBFRyBpbWFnZXMgb3JpZW50ZWQgd2l0aCBFeGlmO1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTIyMDY3MVxuLy8gVE9ETzogcmVtb3ZlIGFmdGVyIGl0J3MgZml4ZWQgaW4gY2hyb21lIGZvciBhdCBsZWFzdCAyIHJlbGVhc2VzXG5cblxubW9kdWxlLmV4cG9ydHMuY2liX2Nhbl91c2VfcmVnaW9uID0gZnVuY3Rpb24gY2liX2Nhbl91c2VfcmVnaW9uKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2Uuc3JjID0gJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJyArICcvOWovNFFCaVJYaHBaZ0FBVFUwQUtnQUFBQWdBQlFFU0FBTUFBQUFCQUFZQUFBRWFBQVVBQUFBQkFBQUFTZ0ViQUFVQUEnICsgJ0FBQkFBQUFVZ0VvQUFNQUFBQUJBQUlBQUFJVEFBTUFBQUFCQUFFQUFBQUFBQUFBQUFCSUFBQUFBUUFBQUVnQUFBQUIvOScgKyAnc0FRd0FFQXdNRUF3TUVCQU1FQlFRRUJRWUtCd1lHQmdZTkNRb0lDZzhORUJBUERROE9FUk1ZRkJFU0Z4SU9EeFVjRlJjJyArICdaR1JzYkd4QVVIUjhkR2g4WUdoc2EvOXNBUXdFRUJRVUdCUVlNQndjTUdoRVBFUm9hR2hvYUdob2FHaG9hR2hvYUdob2EnICsgJ0dob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hLzhJQUVRZ0FBUUFDQXdFUkFBSVJBUU1SQScgKyAnZi9FQUJRQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFmL3hBQVVBUUVBQUFBQUFBQUFBQUFBQUFBQUFBQUEvOW9BREFNQkFBJyArICdJUUF4QUFBQUYvUC8vRUFCUVFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBRC8yZ0FJQVFFQUFRVUNmLy9FQUJRUkFRQUFBQUEnICsgJ0FBQUFBQUFBQUFBQUFBQUQvMmdBSUFRTUJBVDhCZi8vRUFCUVJBUUFBQUFBQUFBQUFBQUFBQUFBQUFBRC8yZ0FJQVFJQicgKyAnQVQ4QmYvL0VBQlFRQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUQvMmdBSUFRRUFCajhDZi8vRUFCUVFBUUFBQUFBQUFBQUFBJyArICdBQUFBQUFBQUFELzJnQUlBUUVBQVQ4aGYvL2FBQXdEQVFBQ0FBTUFBQUFRSC8vRUFCUVJBUUFBQUFBQUFBQUFBQUFBQUEnICsgJ0FBQUFELzJnQUlBUU1CQVQ4UWYvL0VBQlFSQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUQvMmdBSUFRSUJBVDhRZi8vRUFCUScgKyAnUUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFELzJnQUlBUUVBQVQ4UWYvL1onO1xuXG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgY3JlYXRlSW1hZ2VCaXRtYXAoaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpLnRoZW4oZnVuY3Rpb24gKGJpdG1hcCkge1xuICAgICAgICBpZiAoYml0bWFwLndpZHRoID09PSBpbWFnZS53aWR0aCAmJiBiaXRtYXAuaGVpZ2h0ID09PSBpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc29sdmUoZmFsc2UpO1xuICAgIH07XG4gIH0pO1xufTtcblxufSx7fV0sMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIE1hdGhMaWIgPSBfZGVyZXFfKCcuL21hdGhsaWInKTtcblxuICB2YXIgbWF0aExpYjtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cblxuICBvbm1lc3NhZ2UgPSBmdW5jdGlvbiBvbm1lc3NhZ2UoZXYpIHtcbiAgICB2YXIgdGlsZU9wdHMgPSBldi5kYXRhLm9wdHM7XG4gICAgdmFyIHJldHVybkJpdG1hcCA9IGZhbHNlO1xuXG4gICAgaWYgKCF0aWxlT3B0cy5zcmMgJiYgdGlsZU9wdHMuc3JjQml0bWFwKSB7XG4gICAgICB2YXIgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh0aWxlT3B0cy53aWR0aCwgdGlsZU9wdHMuaGVpZ2h0KTtcbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgICAgIGFscGhhOiBCb29sZWFuKHRpbGVPcHRzLmFscGhhKVxuICAgICAgfSk7XG4gICAgICBjdHguZHJhd0ltYWdlKHRpbGVPcHRzLnNyY0JpdG1hcCwgMCwgMCk7XG4gICAgICB0aWxlT3B0cy5zcmMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRpbGVPcHRzLndpZHRoLCB0aWxlT3B0cy5oZWlnaHQpLmRhdGE7XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICB0aWxlT3B0cy5zcmNCaXRtYXAuY2xvc2UoKTtcbiAgICAgIHRpbGVPcHRzLnNyY0JpdG1hcCA9IG51bGw7XG4gICAgICByZXR1cm5CaXRtYXAgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghbWF0aExpYikgbWF0aExpYiA9IG5ldyBNYXRoTGliKGV2LmRhdGEuZmVhdHVyZXMpOyAvLyBVc2UgbXVsdGltYXRoJ3Mgc3luYyBhdXRvLWluaXQuIEF2b2lkIFByb21pc2UgdXNlIGluIG9sZCBicm93c2VycyxcbiAgICAvLyBiZWNhdXNlIHBvbHlmaWxscyBhcmUgbm90IHByb3BhZ2F0ZWQgdG8gd2Vid29ya2VyLlxuXG4gICAgdmFyIGRhdGEgPSBtYXRoTGliLnJlc2l6ZUFuZFVuc2hhcnAodGlsZU9wdHMpO1xuXG4gICAgaWYgKHJldHVybkJpdG1hcCkge1xuICAgICAgdmFyIHRvSW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkoZGF0YSksIHRpbGVPcHRzLnRvV2lkdGgsIHRpbGVPcHRzLnRvSGVpZ2h0KTtcblxuICAgICAgdmFyIF9jYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHRpbGVPcHRzLnRvV2lkdGgsIHRpbGVPcHRzLnRvSGVpZ2h0KTtcblxuICAgICAgdmFyIF9jdHggPSBfY2FudmFzLmdldENvbnRleHQoJzJkJywge1xuICAgICAgICBhbHBoYTogQm9vbGVhbih0aWxlT3B0cy5hbHBoYSlcbiAgICAgIH0pO1xuXG4gICAgICBfY3R4LnB1dEltYWdlRGF0YSh0b0ltYWdlRGF0YSwgMCwgMCk7XG5cbiAgICAgIGNyZWF0ZUltYWdlQml0bWFwKF9jYW52YXMpLnRoZW4oZnVuY3Rpb24gKGJpdG1hcCkge1xuICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgYml0bWFwOiBiaXRtYXBcbiAgICAgICAgfSwgW2JpdG1hcF0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSwgW2RhdGEuYnVmZmVyXSk7XG4gICAgfVxuICB9O1xufTtcblxufSx7XCIuL21hdGhsaWJcIjoxfV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ2FsY3VsYXRlIEdhdXNzaWFuIGJsdXIgb2YgYW4gaW1hZ2UgdXNpbmcgSUlSIGZpbHRlclxuLy8gVGhlIG1ldGhvZCBpcyB0YWtlbiBmcm9tIEludGVsJ3Mgd2hpdGUgcGFwZXIgYW5kIGNvZGUgZXhhbXBsZSBhdHRhY2hlZCB0byBpdDpcbi8vIGh0dHBzOi8vc29mdHdhcmUuaW50ZWwuY29tL2VuLXVzL2FydGljbGVzL2lpci1nYXVzc2lhbi1ibHVyLWZpbHRlclxuLy8gLWltcGxlbWVudGF0aW9uLXVzaW5nLWludGVsLWFkdmFuY2VkLXZlY3Rvci1leHRlbnNpb25zXG5cbnZhciBhMCwgYTEsIGEyLCBhMywgYjEsIGIyLCBsZWZ0X2Nvcm5lciwgcmlnaHRfY29ybmVyO1xuXG5mdW5jdGlvbiBnYXVzc0NvZWYoc2lnbWEpIHtcbiAgaWYgKHNpZ21hIDwgMC41KSB7XG4gICAgc2lnbWEgPSAwLjU7XG4gIH1cblxuICB2YXIgYSA9IE1hdGguZXhwKDAuNzI2ICogMC43MjYpIC8gc2lnbWEsXG4gICAgICBnMSA9IE1hdGguZXhwKC1hKSxcbiAgICAgIGcyID0gTWF0aC5leHAoLTIgKiBhKSxcbiAgICAgIGsgPSAoMSAtIGcxKSAqICgxIC0gZzEpIC8gKDEgKyAyICogYSAqIGcxIC0gZzIpO1xuXG4gIGEwID0gaztcbiAgYTEgPSBrICogKGEgLSAxKSAqIGcxO1xuICBhMiA9IGsgKiAoYSArIDEpICogZzE7XG4gIGEzID0gLWsgKiBnMjtcbiAgYjEgPSAyICogZzE7XG4gIGIyID0gLWcyO1xuICBsZWZ0X2Nvcm5lciA9IChhMCArIGExKSAvICgxIC0gYjEgLSBiMik7XG4gIHJpZ2h0X2Nvcm5lciA9IChhMiArIGEzKSAvICgxIC0gYjEgLSBiMik7XG5cbiAgLy8gQXR0ZW1wdCB0byBmb3JjZSB0eXBlIHRvIEZQMzIuXG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFsgYTAsIGExLCBhMiwgYTMsIGIxLCBiMiwgbGVmdF9jb3JuZXIsIHJpZ2h0X2Nvcm5lciBdKTtcbn1cblxuZnVuY3Rpb24gY29udm9sdmVNb25vMTYoc3JjLCBvdXQsIGxpbmUsIGNvZWZmLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIC8vIHRha2VzIHNyYyBpbWFnZSBhbmQgd3JpdGVzIHRoZSBibHVycmVkIGFuZCB0cmFuc3Bvc2VkIHJlc3VsdCBpbnRvIG91dFxuXG4gIHZhciBwcmV2X3NyYywgY3Vycl9zcmMsIGN1cnJfb3V0LCBwcmV2X291dCwgcHJldl9wcmV2X291dDtcbiAgdmFyIHNyY19pbmRleCwgb3V0X2luZGV4LCBsaW5lX2luZGV4O1xuICB2YXIgaSwgajtcbiAgdmFyIGNvZWZmX2EwLCBjb2VmZl9hMSwgY29lZmZfYjEsIGNvZWZmX2IyO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgIHNyY19pbmRleCA9IGkgKiB3aWR0aDtcbiAgICBvdXRfaW5kZXggPSBpO1xuICAgIGxpbmVfaW5kZXggPSAwO1xuXG4gICAgLy8gbGVmdCB0byByaWdodFxuICAgIHByZXZfc3JjID0gc3JjW3NyY19pbmRleF07XG4gICAgcHJldl9wcmV2X291dCA9IHByZXZfc3JjICogY29lZmZbNl07XG4gICAgcHJldl9vdXQgPSBwcmV2X3ByZXZfb3V0O1xuXG4gICAgY29lZmZfYTAgPSBjb2VmZlswXTtcbiAgICBjb2VmZl9hMSA9IGNvZWZmWzFdO1xuICAgIGNvZWZmX2IxID0gY29lZmZbNF07XG4gICAgY29lZmZfYjIgPSBjb2VmZls1XTtcblxuICAgIGZvciAoaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICBjdXJyX3NyYyA9IHNyY1tzcmNfaW5kZXhdO1xuXG4gICAgICBjdXJyX291dCA9IGN1cnJfc3JjICogY29lZmZfYTAgK1xuICAgICAgICAgICAgICAgICBwcmV2X3NyYyAqIGNvZWZmX2ExICtcbiAgICAgICAgICAgICAgICAgcHJldl9vdXQgKiBjb2VmZl9iMSArXG4gICAgICAgICAgICAgICAgIHByZXZfcHJldl9vdXQgKiBjb2VmZl9iMjtcblxuICAgICAgcHJldl9wcmV2X291dCA9IHByZXZfb3V0O1xuICAgICAgcHJldl9vdXQgPSBjdXJyX291dDtcbiAgICAgIHByZXZfc3JjID0gY3Vycl9zcmM7XG5cbiAgICAgIGxpbmVbbGluZV9pbmRleF0gPSBwcmV2X291dDtcbiAgICAgIGxpbmVfaW5kZXgrKztcbiAgICAgIHNyY19pbmRleCsrO1xuICAgIH1cblxuICAgIHNyY19pbmRleC0tO1xuICAgIGxpbmVfaW5kZXgtLTtcbiAgICBvdXRfaW5kZXggKz0gaGVpZ2h0ICogKHdpZHRoIC0gMSk7XG5cbiAgICAvLyByaWdodCB0byBsZWZ0XG4gICAgcHJldl9zcmMgPSBzcmNbc3JjX2luZGV4XTtcbiAgICBwcmV2X3ByZXZfb3V0ID0gcHJldl9zcmMgKiBjb2VmZls3XTtcbiAgICBwcmV2X291dCA9IHByZXZfcHJldl9vdXQ7XG4gICAgY3Vycl9zcmMgPSBwcmV2X3NyYztcblxuICAgIGNvZWZmX2EwID0gY29lZmZbMl07XG4gICAgY29lZmZfYTEgPSBjb2VmZlszXTtcblxuICAgIGZvciAoaiA9IHdpZHRoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGN1cnJfb3V0ID0gY3Vycl9zcmMgKiBjb2VmZl9hMCArXG4gICAgICAgICAgICAgICAgIHByZXZfc3JjICogY29lZmZfYTEgK1xuICAgICAgICAgICAgICAgICBwcmV2X291dCAqIGNvZWZmX2IxICtcbiAgICAgICAgICAgICAgICAgcHJldl9wcmV2X291dCAqIGNvZWZmX2IyO1xuXG4gICAgICBwcmV2X3ByZXZfb3V0ID0gcHJldl9vdXQ7XG4gICAgICBwcmV2X291dCA9IGN1cnJfb3V0O1xuXG4gICAgICBwcmV2X3NyYyA9IGN1cnJfc3JjO1xuICAgICAgY3Vycl9zcmMgPSBzcmNbc3JjX2luZGV4XTtcblxuICAgICAgb3V0W291dF9pbmRleF0gPSBsaW5lW2xpbmVfaW5kZXhdICsgcHJldl9vdXQ7XG5cbiAgICAgIHNyY19pbmRleC0tO1xuICAgICAgbGluZV9pbmRleC0tO1xuICAgICAgb3V0X2luZGV4IC09IGhlaWdodDtcbiAgICB9XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBibHVyTW9ubzE2KHNyYywgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIC8vIFF1aWNrIGV4aXQgb24gemVybyByYWRpdXNcbiAgaWYgKCFyYWRpdXMpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIG91dCAgICAgID0gbmV3IFVpbnQxNkFycmF5KHNyYy5sZW5ndGgpLFxuICAgICAgdG1wX2xpbmUgPSBuZXcgRmxvYXQzMkFycmF5KE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpKTtcblxuICB2YXIgY29lZmYgPSBnYXVzc0NvZWYocmFkaXVzKTtcblxuICBjb252b2x2ZU1vbm8xNihzcmMsIG91dCwgdG1wX2xpbmUsIGNvZWZmLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY29udm9sdmVNb25vMTYob3V0LCBzcmMsIHRtcF9saW5lLCBjb2VmZiwgaGVpZ2h0LCB3aWR0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmx1ck1vbm8xNjtcblxufSx7fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgICB9XG4gIH07XG59XG5cbn0se31dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuXG52YXIgYXNzaWduICAgICAgICAgPSBfZGVyZXFfKCdvYmplY3QtYXNzaWduJyk7XG52YXIgYmFzZTY0ZGVjb2RlICAgPSBfZGVyZXFfKCcuL2xpYi9iYXNlNjRkZWNvZGUnKTtcbnZhciBoYXNXZWJBc3NlbWJseSA9IF9kZXJlcV8oJy4vbGliL3dhX2RldGVjdCcpO1xuXG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIGpzOiB0cnVlLFxuICB3YXNtOiB0cnVlXG59O1xuXG5cbmZ1bmN0aW9uIE11bHRpTWF0aChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNdWx0aU1hdGgpKSByZXR1cm4gbmV3IE11bHRpTWF0aChvcHRpb25zKTtcblxuICB2YXIgb3B0cyA9IGFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zIHx8IHt9KTtcblxuICB0aGlzLm9wdGlvbnMgICAgICAgICA9IG9wdHM7XG5cbiAgdGhpcy5fX2NhY2hlICAgICAgICAgPSB7fTtcblxuICB0aGlzLl9faW5pdF9wcm9taXNlICA9IG51bGw7XG4gIHRoaXMuX19tb2R1bGVzICAgICAgID0gb3B0cy5tb2R1bGVzIHx8IHt9O1xuICB0aGlzLl9fbWVtb3J5ICAgICAgICA9IG51bGw7XG4gIHRoaXMuX193YXNtICAgICAgICAgID0ge307XG5cbiAgdGhpcy5fX2lzTEUgPSAoKG5ldyBVaW50MzJBcnJheSgobmV3IFVpbnQ4QXJyYXkoWyAxLCAwLCAwLCAwIF0pKS5idWZmZXIpKVswXSA9PT0gMSk7XG5cbiAgaWYgKCF0aGlzLm9wdGlvbnMuanMgJiYgIXRoaXMub3B0aW9ucy53YXNtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXRobGliOiBhdCBsZWFzdCBcImpzXCIgb3IgXCJ3YXNtXCIgc2hvdWxkIGJlIGVuYWJsZWQnKTtcbiAgfVxufVxuXG5cbk11bHRpTWF0aC5wcm90b3R5cGUuaGFzX3dhc20gPSBoYXNXZWJBc3NlbWJseTtcblxuXG5NdWx0aU1hdGgucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgdGhpcy5fX21vZHVsZXNbbW9kdWxlLm5hbWVdID0gbW9kdWxlO1xuXG4gIC8vIFBpbiB0aGUgYmVzdCBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvblxuICBpZiAodGhpcy5vcHRpb25zLndhc20gJiYgdGhpcy5oYXNfd2FzbSgpICYmIG1vZHVsZS53YXNtX2ZuKSB7XG4gICAgdGhpc1ttb2R1bGUubmFtZV0gPSBtb2R1bGUud2FzbV9mbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzW21vZHVsZS5uYW1lXSA9IG1vZHVsZS5mbjtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5NdWx0aU1hdGgucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9faW5pdF9wcm9taXNlKSByZXR1cm4gdGhpcy5fX2luaXRfcHJvbWlzZTtcblxuICBpZiAoIXRoaXMub3B0aW9ucy5qcyAmJiB0aGlzLm9wdGlvbnMud2FzbSAmJiAhdGhpcy5oYXNfd2FzbSgpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignbWF0aGxpYjogb25seSBcIndhc21cIiB3YXMgZW5hYmxlZCwgYnV0IGl0XFwncyBub3Qgc3VwcG9ydGVkJykpO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuX19pbml0X3Byb21pc2UgPSBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhzZWxmLl9fbW9kdWxlcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIG1vZHVsZSA9IHNlbGYuX19tb2R1bGVzW25hbWVdO1xuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMud2FzbSB8fCAhc2VsZi5oYXNfd2FzbSgpIHx8ICFtb2R1bGUud2FzbV9mbikgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBJZiBhbHJlYWR5IGNvbXBpbGVkIC0gZXhpdFxuICAgIGlmIChzZWxmLl9fd2FzbVtuYW1lXSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBDb21waWxlIHdhc20gc291cmNlXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LmNvbXBpbGUoc2VsZi5fX2Jhc2U2NGRlY29kZShtb2R1bGUud2FzbV9zcmMpKVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKG0pIHsgc2VsZi5fX3dhc21bbmFtZV0gPSBtOyB9KTtcbiAgfSkpXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZjsgfSk7XG5cbiAgcmV0dXJuIHRoaXMuX19pbml0X3Byb21pc2U7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBNZXRob2RzIGJlbG93IGFyZSBmb3IgaW50ZXJuYWwgdXNlIGZyb20gcGx1Z2luc1xuXG5cbi8vIFNpbXBsZSBkZWNvZGUgYmFzZTY0IHRvIHR5cGVkIGFycmF5LiBVc2VmdWwgdG8gbG9hZCBlbWJlZGRlZCB3ZWJhc3NlbWJseVxuLy8gY29kZS4gWW91IHByb2JhYmx5IGRvbid0IG5lZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBkaXJlY3RseS5cbi8vXG5NdWx0aU1hdGgucHJvdG90eXBlLl9fYmFzZTY0ZGVjb2RlID0gYmFzZTY0ZGVjb2RlO1xuXG5cbi8vIEluY3JlYXNlIGN1cnJlbnQgbWVtb3J5IHRvIGluY2x1ZGUgc3BlY2lmaWVkIG51bWJlciBvZiBieXRlcy4gRG8gbm90aGluZyBpZlxuLy8gc2l6ZSBpcyBhbHJlYWR5IG9rLiBZb3UgcHJvYmFibHkgZG9uJ3QgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIGRpcmVjdGx5LFxuLy8gYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgZnJvbSBgLl9faW5zdGFuY2UoKWAuXG4vL1xuTXVsdGlNYXRoLnByb3RvdHlwZS5fX3JlYWxsb2NhdGUgPSBmdW5jdGlvbiBtZW1fZ3Jvd190byhieXRlcykge1xuICBpZiAoIXRoaXMuX19tZW1vcnkpIHtcbiAgICB0aGlzLl9fbWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gICAgICBpbml0aWFsOiBNYXRoLmNlaWwoYnl0ZXMgLyAoNjQgKiAxMDI0KSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fX21lbW9yeTtcbiAgfVxuXG4gIHZhciBtZW1fc2l6ZSA9IHRoaXMuX19tZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGg7XG5cbiAgaWYgKG1lbV9zaXplIDwgYnl0ZXMpIHtcbiAgICB0aGlzLl9fbWVtb3J5Lmdyb3coTWF0aC5jZWlsKChieXRlcyAtIG1lbV9zaXplKSAvICg2NCAqIDEwMjQpKSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fX21lbW9yeTtcbn07XG5cblxuLy8gUmV0dXJucyBpbnN0YW50aW5hdGVkIHdlYmFzc2VtYmx5IGl0ZW0gYnkgbmFtZSwgd2l0aCBzcGVjaWZpZWQgbWVtb3J5IHNpemVcbi8vIGFuZCBlbnZpcm9ubWVudC5cbi8vIC0gdXNlIGNhY2hlIGlmIGF2YWlsYWJsZVxuLy8gLSBkbyBzeW5jIG1vZHVsZSBpbml0LCBpZiBhc3luYyBpbml0IHdhcyBub3QgY2FsbGVkIGVhcmxpZXJcbi8vIC0gYWxsb2NhdGUgbWVtb3J5IGlmIG5vdCBlbm91Z3RoXG4vLyAtIGNhbiBleHBvcnQgZnVuY3Rpb25zIHRvIHdlYmFzc2VtYmx5IHZpYSBcImVudl9leHRyYVwiLFxuLy8gICBmb3IgZXhhbXBsZSwgeyBleHA6IE1hdGguZXhwIH1cbi8vXG5NdWx0aU1hdGgucHJvdG90eXBlLl9faW5zdGFuY2UgPSBmdW5jdGlvbiBpbnN0YW5jZShuYW1lLCBtZW1zaXplLCBlbnZfZXh0cmEpIHtcbiAgaWYgKG1lbXNpemUpIHRoaXMuX19yZWFsbG9jYXRlKG1lbXNpemUpO1xuXG4gIC8vIElmIC5pbml0KCkgd2FzIG5vdCBjYWxsZWQsIGRvIHN5bmMgY29tcGlsZVxuICBpZiAoIXRoaXMuX193YXNtW25hbWVdKSB7XG4gICAgdmFyIG1vZHVsZSA9IHRoaXMuX19tb2R1bGVzW25hbWVdO1xuICAgIHRoaXMuX193YXNtW25hbWVdID0gbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZSh0aGlzLl9fYmFzZTY0ZGVjb2RlKG1vZHVsZS53YXNtX3NyYykpO1xuICB9XG5cbiAgaWYgKCF0aGlzLl9fY2FjaGVbbmFtZV0pIHtcbiAgICB2YXIgZW52X2Jhc2UgPSB7XG4gICAgICBtZW1vcnlCYXNlOiAwLFxuICAgICAgbWVtb3J5OiB0aGlzLl9fbWVtb3J5LFxuICAgICAgdGFibGVCYXNlOiAwLFxuICAgICAgdGFibGU6IG5ldyBXZWJBc3NlbWJseS5UYWJsZSh7IGluaXRpYWw6IDAsIGVsZW1lbnQ6ICdhbnlmdW5jJyB9KVxuICAgIH07XG5cbiAgICB0aGlzLl9fY2FjaGVbbmFtZV0gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UodGhpcy5fX3dhc21bbmFtZV0sIHtcbiAgICAgIGVudjogYXNzaWduKGVudl9iYXNlLCBlbnZfZXh0cmEgfHwge30pXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fX2NhY2hlW25hbWVdO1xufTtcblxuXG4vLyBIZWxwZXIgdG8gY2FsY3VsYXRlIG1lbW9yeSBhbGlnaCBmb3IgcG9pbnRlcnMuIFdlYmFzc2VtYmx5IGRvZXMgbm90IHJlcXVpcmVcbi8vIHRoaXMsIGJ1dCB5b3UgbWF5IHdpc2ggdG8gZXhwZXJpbWVudC4gRGVmYXVsdCBiYXNlID0gODtcbi8vXG5NdWx0aU1hdGgucHJvdG90eXBlLl9fYWxpZ24gPSBmdW5jdGlvbiBhbGlnbihudW1iZXIsIGJhc2UpIHtcbiAgYmFzZSA9IGJhc2UgfHwgODtcbiAgdmFyIHJlbWluZGVyID0gbnVtYmVyICUgYmFzZTtcbiAgcmV0dXJuIG51bWJlciArIChyZW1pbmRlciA/IGJhc2UgLSByZW1pbmRlciA6IDApO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE11bHRpTWF0aDtcblxufSx7XCIuL2xpYi9iYXNlNjRkZWNvZGVcIjoyMSxcIi4vbGliL3dhX2RldGVjdFwiOjIyLFwib2JqZWN0LWFzc2lnblwiOjIzfV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5cbnZhciBCQVNFNjRfTUFQID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFzZTY0ZGVjb2RlKHN0cikge1xuICB2YXIgaW5wdXQgPSBzdHIucmVwbGFjZSgvW1xcclxcbj1dL2csICcnKSwgLy8gcmVtb3ZlIENSL0xGICYgcGFkZGluZyB0byBzaW1wbGlmeSBzY2FuXG4gICAgICBtYXggICA9IGlucHV0Lmxlbmd0aDtcblxuICB2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoKG1heCAqIDMpID4+IDIpO1xuXG4gIC8vIENvbGxlY3QgYnkgNio0IGJpdHMgKDMgYnl0ZXMpXG5cbiAgdmFyIGJpdHMgPSAwO1xuICB2YXIgcHRyICA9IDA7XG5cbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgNCA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICBvdXRbcHRyKytdID0gKGJpdHMgPj4gMTYpICYgMHhGRjtcbiAgICAgIG91dFtwdHIrK10gPSAoYml0cyA+PiA4KSAmIDB4RkY7XG4gICAgICBvdXRbcHRyKytdID0gYml0cyAmIDB4RkY7XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDYpIHwgQkFTRTY0X01BUC5pbmRleE9mKGlucHV0LmNoYXJBdChpZHgpKTtcbiAgfVxuXG4gIC8vIER1bXAgdGFpbFxuXG4gIHZhciB0YWlsYml0cyA9IChtYXggJSA0KSAqIDY7XG5cbiAgaWYgKHRhaWxiaXRzID09PSAwKSB7XG4gICAgb3V0W3B0cisrXSA9IChiaXRzID4+IDE2KSAmIDB4RkY7XG4gICAgb3V0W3B0cisrXSA9IChiaXRzID4+IDgpICYgMHhGRjtcbiAgICBvdXRbcHRyKytdID0gYml0cyAmIDB4RkY7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDE4KSB7XG4gICAgb3V0W3B0cisrXSA9IChiaXRzID4+IDEwKSAmIDB4RkY7XG4gICAgb3V0W3B0cisrXSA9IChiaXRzID4+IDIpICYgMHhGRjtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTIpIHtcbiAgICBvdXRbcHRyKytdID0gKGJpdHMgPj4gNCkgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbn0se31dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuXG52YXIgd2E7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNXZWJBc3NlbWJseSgpIHtcbiAgLy8gdXNlIGNhY2hlIGlmIGNhbGxlZCBiZWZvcmU7XG4gIGlmICh0eXBlb2Ygd2EgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2E7XG5cbiAgd2EgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHdhO1xuXG4gIC8vIElmIFdlYkFzc2VuYmx5IGlzIGRpc2FibGVkLCBjb2RlIGNhbiB0aHJvdyBvbiBjb21waWxlXG4gIHRyeSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JyaW9uL21pbi13YXNtLWZhaWwvYmxvYi9tYXN0ZXIvbWluLXdhc20tZmFpbC5pbi5qc1xuICAgIC8vIEFkZGl0aW9uYWwgY2hlY2sgdGhhdCBXQSBpbnRlcm5hbHMgYXJlIGNvcnJlY3RcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsIG1heC1sZW4gKi9cbiAgICB2YXIgYmluICAgICAgPSBuZXcgVWludDhBcnJheShbIDAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNiwxLDk2LDEsMTI3LDEsMTI3LDMsMiwxLDAsNSwzLDEsMCwxLDcsOCwxLDQsMTE2LDEwMSwxMTUsMTE2LDAsMCwxMCwxNiwxLDE0LDAsMzIsMCw2NSwxLDU0LDIsMCwzMiwwLDQwLDIsMCwxMSBdKTtcbiAgICB2YXIgbW9kdWxlICAgPSBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKGJpbik7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG1vZHVsZSwge30pO1xuXG4gICAgLy8gdGVzdCBzdG9yaW5nIHRvIGFuZCBsb2FkaW5nIGZyb20gYSBub24temVybyBsb2NhdGlvbiB2aWEgYSBwYXJhbWV0ZXIuXG4gICAgLy8gU2FmYXJpIG9uIGlPUyAxMS4yLjUgcmV0dXJucyAwIHVuZXhwZWN0ZWRseSBhdCBub24temVybyBsb2NhdGlvbnNcbiAgICBpZiAoaW5zdGFuY2UuZXhwb3J0cy50ZXN0KDQpICE9PSAwKSB3YSA9IHRydWU7XG5cbiAgICByZXR1cm4gd2E7XG4gIH0gY2F0Y2ggKF9fKSB7fVxuXG4gIHJldHVybiB3YTtcbn07XG5cbn0se31dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxufSx7fV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGJ1bmRsZUZuID0gYXJndW1lbnRzWzNdO1xudmFyIHNvdXJjZXMgPSBhcmd1bWVudHNbNF07XG52YXIgY2FjaGUgPSBhcmd1bWVudHNbNV07XG5cbnZhciBzdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICB2YXIgd2tleTtcbiAgICB2YXIgY2FjaGVLZXlzID0gT2JqZWN0LmtleXMoY2FjaGUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgIHZhciBleHAgPSBjYWNoZVtrZXldLmV4cG9ydHM7XG4gICAgICAgIC8vIFVzaW5nIGJhYmVsIGFzIGEgdHJhbnNwaWxlciB0byB1c2UgZXNtb2R1bGUsIHRoZSBleHBvcnQgd2lsbCBhbHdheXNcbiAgICAgICAgLy8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGRlZmF1bHQgZXhwb3J0IGFzIGEgcHJvcGVydHkgb2YgaXQuIFRvIGVuc3VyZVxuICAgICAgICAvLyB0aGUgZXhpc3RpbmcgYXBpIGFuZCBiYWJlbCBlc21vZHVsZSBleHBvcnRzIGFyZSBib3RoIHN1cHBvcnRlZCB3ZVxuICAgICAgICAvLyBjaGVjayBmb3IgYm90aFxuICAgICAgICBpZiAoZXhwID09PSBmbiB8fCBleHAgJiYgZXhwLmRlZmF1bHQgPT09IGZuKSB7XG4gICAgICAgICAgICB3a2V5ID0ga2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXdrZXkpIHtcbiAgICAgICAgd2tleSA9IE1hdGguZmxvb3IoTWF0aC5wb3coMTYsIDgpICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMTYpO1xuICAgICAgICB2YXIgd2NhY2hlID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGNhY2hlS2V5c1tpXTtcbiAgICAgICAgICAgIHdjYWNoZVtrZXldID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZXNbd2tleV0gPSBbXG4gICAgICAgICAgICAnZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7JyArIGZuICsgJyhzZWxmKTsgfScsXG4gICAgICAgICAgICB3Y2FjaGVcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHNrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcblxuICAgIHZhciBzY2FjaGUgPSB7fTsgc2NhY2hlW3drZXldID0gd2tleTtcbiAgICBzb3VyY2VzW3NrZXldID0gW1xuICAgICAgICAnZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7JyArXG4gICAgICAgICAgICAvLyB0cnkgdG8gY2FsbCBkZWZhdWx0IGlmIGRlZmluZWQgdG8gYWxzbyBzdXBwb3J0IGJhYmVsIGVzbW9kdWxlIGV4cG9ydHNcbiAgICAgICAgICAgICd2YXIgZiA9IHJlcXVpcmUoJyArIHN0cmluZ2lmeSh3a2V5KSArICcpOycgK1xuICAgICAgICAgICAgJyhmLmRlZmF1bHQgPyBmLmRlZmF1bHQgOiBmKShzZWxmKTsnICtcbiAgICAgICAgJ30nLFxuICAgICAgICBzY2FjaGVcbiAgICBdO1xuXG4gICAgdmFyIHdvcmtlclNvdXJjZXMgPSB7fTtcbiAgICByZXNvbHZlU291cmNlcyhza2V5KTtcblxuICAgIGZ1bmN0aW9uIHJlc29sdmVTb3VyY2VzKGtleSkge1xuICAgICAgICB3b3JrZXJTb3VyY2VzW2tleV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGRlcFBhdGggaW4gc291cmNlc1trZXldWzFdKSB7XG4gICAgICAgICAgICB2YXIgZGVwS2V5ID0gc291cmNlc1trZXldWzFdW2RlcFBhdGhdO1xuICAgICAgICAgICAgaWYgKCF3b3JrZXJTb3VyY2VzW2RlcEtleV0pIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlU291cmNlcyhkZXBLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNyYyA9ICcoJyArIGJ1bmRsZUZuICsgJykoeydcbiAgICAgICAgKyBPYmplY3Qua2V5cyh3b3JrZXJTb3VyY2VzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShrZXkpICsgJzpbJ1xuICAgICAgICAgICAgICAgICsgc291cmNlc1trZXldWzBdXG4gICAgICAgICAgICAgICAgKyAnLCcgKyBzdHJpbmdpZnkoc291cmNlc1trZXldWzFdKSArICddJ1xuICAgICAgICAgICAgO1xuICAgICAgICB9KS5qb2luKCcsJylcbiAgICAgICAgKyAnfSx7fSxbJyArIHN0cmluZ2lmeShza2V5KSArICddKSdcbiAgICA7XG5cbiAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xuXG4gICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmJhcmUpIHsgcmV0dXJuIGJsb2I7IH1cbiAgICB2YXIgd29ya2VyVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVcmwpO1xuICAgIHdvcmtlci5vYmplY3RVUkwgPSB3b3JrZXJVcmw7XG4gICAgcmV0dXJuIHdvcmtlcjtcbn07XG5cbn0se31dLFwiL2luZGV4LmpzXCI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbnZhciBhc3NpZ24gPSBfZGVyZXFfKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciB3ZWJ3b3JraWZ5ID0gX2RlcmVxXygnd2Vid29ya2lmeScpO1xuXG52YXIgTWF0aExpYiA9IF9kZXJlcV8oJy4vbGliL21hdGhsaWInKTtcblxudmFyIFBvb2wgPSBfZGVyZXFfKCcuL2xpYi9wb29sJyk7XG5cbnZhciB1dGlscyA9IF9kZXJlcV8oJy4vbGliL3V0aWxzJyk7XG5cbnZhciB3b3JrZXIgPSBfZGVyZXFfKCcuL2xpYi93b3JrZXInKTtcblxudmFyIGNyZWF0ZVN0YWdlcyA9IF9kZXJlcV8oJy4vbGliL3N0ZXBwZXInKTtcblxudmFyIGNyZWF0ZVJlZ2lvbnMgPSBfZGVyZXFfKCcuL2xpYi90aWxlcicpOyAvLyBEZWR1cGxpY2F0ZSBwb29scyAmIGxpbWl0ZXJzIHdpdGggdGhlIHNhbWUgY29uZmlnc1xuLy8gd2hlbiB1c2VyIGNyZWF0ZXMgbXVsdGlwbGUgcGljYSBpbnN0YW5jZXMuXG5cblxudmFyIHNpbmdsZXRvbmVzID0ge307XG52YXIgTkVFRF9TQUZBUklfRklYID0gZmFsc2U7XG5cbnRyeSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgTkVFRF9TQUZBUklfRklYID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdTYWZhcmknKSA+PSAwO1xuICB9XG59IGNhdGNoIChlKSB7fVxuXG52YXIgY29uY3VycmVuY3kgPSAxO1xuXG5pZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgY29uY3VycmVuY3kgPSBNYXRoLm1pbihuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSB8fCAxLCA0KTtcbn1cblxudmFyIERFRkFVTFRfUElDQV9PUFRTID0ge1xuICB0aWxlOiAxMDI0LFxuICBjb25jdXJyZW5jeTogY29uY3VycmVuY3ksXG4gIGZlYXR1cmVzOiBbJ2pzJywgJ3dhc20nLCAnd3cnXSxcbiAgaWRsZTogMjAwMCxcbiAgY3JlYXRlQ2FudmFzOiBmdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0bXBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICB0bXBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiB0bXBDYW52YXM7XG4gIH1cbn07XG52YXIgREVGQVVMVF9SRVNJWkVfT1BUUyA9IHtcbiAgcXVhbGl0eTogMyxcbiAgYWxwaGE6IGZhbHNlLFxuICB1bnNoYXJwQW1vdW50OiAwLFxuICB1bnNoYXJwUmFkaXVzOiAwLjAsXG4gIHVuc2hhcnBUaHJlc2hvbGQ6IDBcbn07XG52YXIgQ0FOX05FV19JTUFHRV9EQVRBID0gZmFsc2U7XG52YXIgQ0FOX0NSRUFURV9JTUFHRV9CSVRNQVAgPSBmYWxzZTtcbnZhciBDQU5fVVNFX0NBTlZBU19HRVRfSU1BR0VfREFUQSA9IGZhbHNlO1xudmFyIENBTl9VU0VfT0ZGU0NSRUVOX0NBTlZBUyA9IGZhbHNlO1xudmFyIENBTl9VU0VfQ0lCX1JFR0lPTl9GT1JfSU1BR0UgPSBmYWxzZTtcblxuZnVuY3Rpb24gd29ya2VyRmFicmljKCkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB3ZWJ3b3JraWZ5KHdvcmtlciksXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMudmFsdWUudGVybWluYXRlKCk7XG5cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgdXJsID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xuXG4gICAgICAgIGlmICh1cmwgJiYgdXJsLnJldm9rZU9iamVjdFVSTCAmJiB0aGlzLnZhbHVlLm9iamVjdFVSTCkge1xuICAgICAgICAgIHVybC5yZXZva2VPYmplY3RVUkwodGhpcy52YWx1ZS5vYmplY3RVUkwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQVBJIG1ldGhvZHNcblxuXG5mdW5jdGlvbiBQaWNhKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBpY2EpKSByZXR1cm4gbmV3IFBpY2Eob3B0aW9ucyk7XG4gIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgREVGQVVMVF9QSUNBX09QVFMsIG9wdGlvbnMgfHwge30pO1xuICB2YXIgbGltaXRlcl9rZXkgPSBcImxrX1wiLmNvbmNhdCh0aGlzLm9wdGlvbnMuY29uY3VycmVuY3kpOyAvLyBTaGFyZSBsaW1pdGVycyB0byBhdm9pZCBtdWx0aXBsZSBwYXJhbGxlbCB3b3JrZXJzIHdoZW4gdXNlciBjcmVhdGVzXG4gIC8vIG11bHRpcGxlIHBpY2EgaW5zdGFuY2VzLlxuXG4gIHRoaXMuX19saW1pdCA9IHNpbmdsZXRvbmVzW2xpbWl0ZXJfa2V5XSB8fCB1dGlscy5saW1pdGVyKHRoaXMub3B0aW9ucy5jb25jdXJyZW5jeSk7XG4gIGlmICghc2luZ2xldG9uZXNbbGltaXRlcl9rZXldKSBzaW5nbGV0b25lc1tsaW1pdGVyX2tleV0gPSB0aGlzLl9fbGltaXQ7IC8vIExpc3Qgb2Ygc3VwcG9ydGVkIGZlYXR1cmVzLCBhY2NvcmRpbmcgdG8gb3B0aW9ucyAmIGJyb3dzZXIvbm9kZS5qc1xuXG4gIHRoaXMuZmVhdHVyZXMgPSB7XG4gICAganM6IGZhbHNlLFxuICAgIC8vIHB1cmUgSlMgaW1wbGVtZW50YXRpb24sIGNhbiBiZSBkaXNhYmxlZCBmb3IgdGVzdGluZ1xuICAgIHdhc206IGZhbHNlLFxuICAgIC8vIHdlYmFzc2VtYmx5IGltcGxlbWVudGF0aW9uIGZvciBoZWF2eSBmdW5jdGlvbnNcbiAgICBjaWI6IGZhbHNlLFxuICAgIC8vIHJlc2l6ZSB2aWEgY3JlYXRlSW1hZ2VCaXRtYXAgKG9ubHkgRkYgYXQgdGhpcyBtb21lbnQpXG4gICAgd3c6IGZhbHNlIC8vIHdlYndvcmtlcnNcblxuICB9O1xuICB0aGlzLl9fd29ya2Vyc1Bvb2wgPSBudWxsOyAvLyBTdG9yZSByZXF1ZXN0ZWQgZmVhdHVyZXMgZm9yIHdlYndvcmtlcnNcblxuICB0aGlzLl9fcmVxdWVzdGVkX2ZlYXR1cmVzID0gW107XG4gIHRoaXMuX19tYXRobGliID0gbnVsbDtcbn1cblxuUGljYS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodGhpcy5fX2luaXRQcm9taXNlKSByZXR1cm4gdGhpcy5fX2luaXRQcm9taXNlOyAvLyBUZXN0IGlmIHdlIGNhbiBjcmVhdGUgSW1hZ2VEYXRhIHdpdGhvdXQgY2FudmFzIGFuZCBtZW1vcnkgY29weVxuXG4gIGlmICh0eXBlb2YgSW1hZ2VEYXRhICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuICAgICAgbmV3IEltYWdlRGF0YShuZXcgVWludDhDbGFtcGVkQXJyYXkoNDAwKSwgMTAsIDEwKTtcbiAgICAgIENBTl9ORVdfSU1BR0VfREFUQSA9IHRydWU7XG4gICAgfSBjYXRjaCAoX18pIHt9XG4gIH0gLy8gSW1hZ2VCaXRtYXAgY2FuIGJlIGVmZmVjdGl2ZSBpbiAyIHBsYWNlczpcbiAgLy9cbiAgLy8gMS4gVGhyZWFkZWQganBlZyB1bnBhY2sgKGJhc2ljKVxuICAvLyAyLiBCdWlsdC1pbiByZXNpemUgKGJsb2NrZWQgZHVlIHByb2JsZW0gaW4gY2hyb21lLCBzZWUgaXNzdWUgIzg5KVxuICAvL1xuICAvLyBGb3IgYmFzaWMgdXNlIHdlIGFsc28gbmVlZCBJbWFnZUJpdG1hcCB3byBzdXBwb3J0IC5jbG9zZSgpIG1ldGhvZCxcbiAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL3J1L2RvY3MvV2ViL0FQSS9JbWFnZUJpdG1hcFxuXG5cbiAgaWYgKHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoSW1hZ2VCaXRtYXAucHJvdG90eXBlICYmIEltYWdlQml0bWFwLnByb3RvdHlwZS5jbG9zZSkge1xuICAgICAgQ0FOX0NSRUFURV9JTUFHRV9CSVRNQVAgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYnVnKCdJbWFnZUJpdG1hcCBkb2VzIG5vdCBzdXBwb3J0IC5jbG9zZSgpLCBkaXNhYmxlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmZWF0dXJlcyA9IHRoaXMub3B0aW9ucy5mZWF0dXJlcy5zbGljZSgpO1xuXG4gIGlmIChmZWF0dXJlcy5pbmRleE9mKCdhbGwnKSA+PSAwKSB7XG4gICAgZmVhdHVyZXMgPSBbJ2NpYicsICd3YXNtJywgJ2pzJywgJ3d3J107XG4gIH1cblxuICB0aGlzLl9fcmVxdWVzdGVkX2ZlYXR1cmVzID0gZmVhdHVyZXM7XG4gIHRoaXMuX19tYXRobGliID0gbmV3IE1hdGhMaWIoZmVhdHVyZXMpOyAvLyBDaGVjayBXZWJXb3JrZXIgc3VwcG9ydCBpZiByZXF1ZXN0ZWRcblxuICBpZiAoZmVhdHVyZXMuaW5kZXhPZignd3cnKSA+PSAwKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdXb3JrZXInIGluIHdpbmRvdykge1xuICAgICAgLy8gSUUgPD0gMTEgZG9uJ3QgYWxsb3cgdG8gY3JlYXRlIHdlYndvcmtlcnMgZnJvbSBzdHJpbmcuIFdlIHNob3VsZCBjaGVjayBpdC5cbiAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvODAxODEwL3dlYi13b3JrZXJzLWZyb20tYmxvYi11cmxzLWluLWllLTEwLWFuZC0xMVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHdrciA9IF9kZXJlcV8oJ3dlYndvcmtpZnknKShmdW5jdGlvbiAoKSB7fSk7XG5cbiAgICAgICAgd2tyLnRlcm1pbmF0ZSgpO1xuICAgICAgICB0aGlzLmZlYXR1cmVzLnd3ID0gdHJ1ZTsgLy8gcG9vbCB1bmlxdWVuZXNzIGRlcGVuZHMgb24gcG9vbCBjb25maWcgKyB3ZWJ3b3JrZXIgY29uZmlnXG5cbiAgICAgICAgdmFyIHdwb29sX2tleSA9IFwid3BfXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucykpO1xuXG4gICAgICAgIGlmIChzaW5nbGV0b25lc1t3cG9vbF9rZXldKSB7XG4gICAgICAgICAgdGhpcy5fX3dvcmtlcnNQb29sID0gc2luZ2xldG9uZXNbd3Bvb2xfa2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fd29ya2Vyc1Bvb2wgPSBuZXcgUG9vbCh3b3JrZXJGYWJyaWMsIHRoaXMub3B0aW9ucy5pZGxlKTtcbiAgICAgICAgICBzaW5nbGV0b25lc1t3cG9vbF9rZXldID0gdGhpcy5fX3dvcmtlcnNQb29sO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChfXykge31cbiAgICB9XG4gIH1cblxuICB2YXIgaW5pdE1hdGggPSB0aGlzLl9fbWF0aGxpYi5pbml0KCkudGhlbihmdW5jdGlvbiAobWF0aGxpYikge1xuICAgIC8vIENvcHkgZGV0ZWN0ZWQgZmVhdHVyZXNcbiAgICBhc3NpZ24oX3RoaXMuZmVhdHVyZXMsIG1hdGhsaWIuZmVhdHVyZXMpO1xuICB9KTtcblxuICB2YXIgY2hlY2tDaWJSZXNpemU7XG5cbiAgaWYgKCFDQU5fQ1JFQVRFX0lNQUdFX0JJVE1BUCkge1xuICAgIGNoZWNrQ2liUmVzaXplID0gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBjaGVja0NpYlJlc2l6ZSA9IHV0aWxzLmNpYl9zdXBwb3J0KHRoaXMub3B0aW9ucy5jcmVhdGVDYW52YXMpLnRoZW4oZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgaWYgKF90aGlzLmZlYXR1cmVzLmNpYiAmJiBmZWF0dXJlcy5pbmRleE9mKCdjaWInKSA8IDApIHtcbiAgICAgICAgX3RoaXMuZGVidWcoJ2NyZWF0ZUltYWdlQml0bWFwKCkgcmVzaXplIHN1cHBvcnRlZCwgYnV0IGRpc2FibGVkIGJ5IGNvbmZpZycpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGZlYXR1cmVzLmluZGV4T2YoJ2NpYicpID49IDApIF90aGlzLmZlYXR1cmVzLmNpYiA9IHN0YXR1cztcbiAgICB9KTtcbiAgfVxuXG4gIENBTl9VU0VfQ0FOVkFTX0dFVF9JTUFHRV9EQVRBID0gdXRpbHMuY2FuX3VzZV9jYW52YXModGhpcy5vcHRpb25zLmNyZWF0ZUNhbnZhcyk7XG4gIHZhciBjaGVja09mZnNjcmVlbkNhbnZhcztcblxuICBpZiAoQ0FOX0NSRUFURV9JTUFHRV9CSVRNQVAgJiYgQ0FOX05FV19JTUFHRV9EQVRBICYmIGZlYXR1cmVzLmluZGV4T2YoJ3d3JykgIT09IC0xKSB7XG4gICAgY2hlY2tPZmZzY3JlZW5DYW52YXMgPSB1dGlscy53b3JrZXJfb2Zmc2NyZWVuX2NhbnZhc19zdXBwb3J0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tPZmZzY3JlZW5DYW52YXMgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICB9XG5cbiAgY2hlY2tPZmZzY3JlZW5DYW52YXMgPSBjaGVja09mZnNjcmVlbkNhbnZhcy50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBDQU5fVVNFX09GRlNDUkVFTl9DQU5WQVMgPSByZXN1bHQ7XG4gIH0pOyAvLyB3ZSB1c2UgY3JlYXRlSW1hZ2VCaXRtYXAgdG8gY3JvcCBpbWFnZSBkYXRhIGFuZCBwYXNzIGl0IHRvIHdvcmtlcnMsXG4gIC8vIHNvIG5lZWQgdG8gY2hlY2sgd2hldGhlciBmdW5jdGlvbiB3b3JrcyBjb3JyZWN0bHk7XG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyMjA2NzFcblxuICB2YXIgY2hlY2tDaWJSZWdpb24gPSB1dGlscy5jaWJfY2FuX3VzZV9yZWdpb24oKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBDQU5fVVNFX0NJQl9SRUdJT05fRk9SX0lNQUdFID0gcmVzdWx0O1xuICB9KTsgLy8gSW5pdCBtYXRoIGxpYi4gVGhhdCdzIGFzeW5jIGJlY2F1c2UgY2FuIGxvYWQgc29tZVxuXG4gIHRoaXMuX19pbml0UHJvbWlzZSA9IFByb21pc2UuYWxsKFtpbml0TWF0aCwgY2hlY2tDaWJSZXNpemUsIGNoZWNrT2Zmc2NyZWVuQ2FudmFzLCBjaGVja0NpYlJlZ2lvbl0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpcztcbiAgfSk7XG4gIHJldHVybiB0aGlzLl9faW5pdFByb21pc2U7XG59OyAvLyBDYWxsIHJlc2l6ZXIgaW4gd2Vid29ya2VyIG9yIGxvY2FsbHksIGRlcGVuZGluZyBvbiBjb25maWdcblxuXG5QaWNhLnByb3RvdHlwZS5fX2ludm9rZVJlc2l6ZSA9IGZ1bmN0aW9uICh0aWxlT3B0cywgb3B0cykge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAvLyBTaGFyZSBjYWNoZSBiZXR3ZWVuIGNhbGxzOlxuICAvL1xuICAvLyAtIHdhc20gaW5zdGFuY2VcbiAgLy8gLSB3YXNtIG1lbW9yeSBvYmplY3RcbiAgLy9cbiAgb3B0cy5fX21hdGhDYWNoZSA9IG9wdHMuX19tYXRoQ2FjaGUgfHwge307XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIV90aGlzMi5mZWF0dXJlcy53dykge1xuICAgICAgLy8gbm90IHBvc3NpYmxlIHRvIGhhdmUgSW1hZ2VCaXRtYXAgaGVyZSBpZiB1c2VyIGRpc2FibGVkIFdXXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBfdGhpczIuX19tYXRobGliLnJlc2l6ZUFuZFVuc2hhcnAodGlsZU9wdHMsIG9wdHMuX19tYXRoQ2FjaGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgdyA9IF90aGlzMi5fX3dvcmtlcnNQb29sLmFjcXVpcmUoKTtcblxuICAgICAgaWYgKG9wdHMuY2FuY2VsVG9rZW4pIG9wdHMuY2FuY2VsVG9rZW5bXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH0pO1xuXG4gICAgICB3LnZhbHVlLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB3LnJlbGVhc2UoKTtcbiAgICAgICAgaWYgKGV2LmRhdGEuZXJyKSByZWplY3QoZXYuZGF0YS5lcnIpO2Vsc2UgcmVzb2x2ZShldi5kYXRhKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciB0cmFuc2ZlciA9IFtdO1xuICAgICAgaWYgKHRpbGVPcHRzLnNyYykgdHJhbnNmZXIucHVzaCh0aWxlT3B0cy5zcmMuYnVmZmVyKTtcbiAgICAgIGlmICh0aWxlT3B0cy5zcmNCaXRtYXApIHRyYW5zZmVyLnB1c2godGlsZU9wdHMuc3JjQml0bWFwKTtcbiAgICAgIHcudmFsdWUucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBvcHRzOiB0aWxlT3B0cyxcbiAgICAgICAgZmVhdHVyZXM6IF90aGlzMi5fX3JlcXVlc3RlZF9mZWF0dXJlcyxcbiAgICAgICAgcHJlbG9hZDoge1xuICAgICAgICAgIHdhc21fbm9kdWxlOiBfdGhpczIuX19tYXRobGliLl9fXG4gICAgICAgIH1cbiAgICAgIH0sIHRyYW5zZmVyKTtcbiAgICB9KTtcbiAgfSk7XG59OyAvLyB0aGlzIGZ1bmN0aW9uIGNhbiByZXR1cm4gcHJvbWlzZSBpZiBjcmVhdGVJbWFnZUJpdG1hcCBpcyB1c2VkXG5cblxuUGljYS5wcm90b3R5cGUuX19leHRyYWN0VGlsZURhdGEgPSBmdW5jdGlvbiAodGlsZSwgZnJvbSwgb3B0cywgc3RhZ2VFbnYsIGV4dHJhY3RUbykge1xuICBpZiAodGhpcy5mZWF0dXJlcy53dyAmJiBDQU5fVVNFX09GRlNDUkVFTl9DQU5WQVMgJiYgKCAvLyBjcmVhdGVJbWFnZUJpdG1hcCBkb2Vzbid0IHdvcmsgZm9yIGltYWdlcyAoSW1hZ2UsIEltYWdlQml0bWFwKSB3aXRoIEV4aWYgb3JpZW50YXRpb24gaW4gQ2hyb21lLFxuICAvLyBjYW4gdXNlIGNhbnZhcyBiZWNhdXNlIGNhbnZhcyBkb2Vzbid0IGhhdmUgb3JpZW50YXRpb247XG4gIC8vIHNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjIwNjcxXG4gIHV0aWxzLmlzQ2FudmFzKGZyb20pIHx8IENBTl9VU0VfQ0lCX1JFR0lPTl9GT1JfSU1BR0UpKSB7XG4gICAgdGhpcy5kZWJ1ZygnQ3JlYXRlIHRpbGUgZm9yIE9mZnNjcmVlbkNhbnZhcycpO1xuICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChzdGFnZUVudi5zcmNJbWFnZUJpdG1hcCB8fCBmcm9tLCB0aWxlLngsIHRpbGUueSwgdGlsZS53aWR0aCwgdGlsZS5oZWlnaHQpLnRoZW4oZnVuY3Rpb24gKGJpdG1hcCkge1xuICAgICAgZXh0cmFjdFRvLnNyY0JpdG1hcCA9IGJpdG1hcDtcbiAgICAgIHJldHVybiBleHRyYWN0VG87XG4gICAgfSk7XG4gIH0gLy8gRXh0cmFjdCB0aWxlIFJHQkEgYnVmZmVyLCBkZXBlbmRpbmcgb24gaW5wdXQgdHlwZVxuXG5cbiAgaWYgKHV0aWxzLmlzQ2FudmFzKGZyb20pKSB7XG4gICAgaWYgKCFzdGFnZUVudi5zcmNDdHgpIHN0YWdlRW52LnNyY0N0eCA9IGZyb20uZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgICBhbHBoYTogQm9vbGVhbihvcHRzLmFscGhhKVxuICAgIH0pOyAvLyBJZiBpbnB1dCBpcyBDYW52YXMgLSBleHRyYWN0IHJlZ2lvbiBkYXRhIGRpcmVjdGx5XG5cbiAgICB0aGlzLmRlYnVnKCdHZXQgdGlsZSBwaXhlbCBkYXRhJyk7XG4gICAgZXh0cmFjdFRvLnNyYyA9IHN0YWdlRW52LnNyY0N0eC5nZXRJbWFnZURhdGEodGlsZS54LCB0aWxlLnksIHRpbGUud2lkdGgsIHRpbGUuaGVpZ2h0KS5kYXRhO1xuICAgIHJldHVybiBleHRyYWN0VG87XG4gIH0gLy8gSWYgaW5wdXQgaXMgSW1hZ2Ugb3IgZGVjb2RlZCB0byBJbWFnZUJpdG1hcCxcbiAgLy8gZHJhdyByZWdpb24gdG8gdGVtcG9yYXJ5IGNhbnZhcyBhbmQgZXh0cmFjdCBkYXRhIGZyb20gaXRcbiAgLy9cbiAgLy8gTm90ZSEgQXR0ZW1wdCB0byByZXVzZSB0aGlzIGNhbnZhcyBjYXVzZXMgc2lnbmlmaWNhbnQgc2xvd2Rvd24gaW4gY2hyb21lXG4gIC8vXG5cblxuICB0aGlzLmRlYnVnKCdEcmF3IHRpbGUgaW1hZ2VCaXRtYXAvaW1hZ2UgdG8gdGVtcG9yYXJ5IGNhbnZhcycpO1xuICB2YXIgdG1wQ2FudmFzID0gdGhpcy5vcHRpb25zLmNyZWF0ZUNhbnZhcyh0aWxlLndpZHRoLCB0aWxlLmhlaWdodCk7XG4gIHZhciB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgYWxwaGE6IEJvb2xlYW4ob3B0cy5hbHBoYSlcbiAgfSk7XG4gIHRtcEN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gIHRtcEN0eC5kcmF3SW1hZ2Uoc3RhZ2VFbnYuc3JjSW1hZ2VCaXRtYXAgfHwgZnJvbSwgdGlsZS54LCB0aWxlLnksIHRpbGUud2lkdGgsIHRpbGUuaGVpZ2h0LCAwLCAwLCB0aWxlLndpZHRoLCB0aWxlLmhlaWdodCk7XG4gIHRoaXMuZGVidWcoJ0dldCB0aWxlIHBpeGVsIGRhdGEnKTtcbiAgZXh0cmFjdFRvLnNyYyA9IHRtcEN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGlsZS53aWR0aCwgdGlsZS5oZWlnaHQpLmRhdGE7IC8vIFNhZmFyaSAxMiB3b3JrYXJvdW5kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYS9pc3N1ZXMvMTk5XG5cbiAgdG1wQ2FudmFzLndpZHRoID0gdG1wQ2FudmFzLmhlaWdodCA9IDA7XG4gIHJldHVybiBleHRyYWN0VG87XG59O1xuXG5QaWNhLnByb3RvdHlwZS5fX2xhbmRUaWxlRGF0YSA9IGZ1bmN0aW9uICh0aWxlLCByZXN1bHQsIHN0YWdlRW52KSB7XG4gIHZhciB0b0ltYWdlRGF0YTtcbiAgdGhpcy5kZWJ1ZygnQ29udmVydCByYXcgcmdiYSB0aWxlIHJlc3VsdCB0byBJbWFnZURhdGEnKTtcblxuICBpZiAocmVzdWx0LmJpdG1hcCkge1xuICAgIHN0YWdlRW52LnRvQ3R4LmRyYXdJbWFnZShyZXN1bHQuYml0bWFwLCB0aWxlLnRvWCwgdGlsZS50b1kpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKENBTl9ORVdfSU1BR0VfREFUQSkge1xuICAgIC8vIHRoaXMgYnJhbmNoIGlzIGZvciBtb2Rlcm4gYnJvd3NlcnNcbiAgICAvLyBJZiBgbmV3IEltYWdlRGF0YSgpYCAmIFVpbnQ4Q2xhbXBlZEFycmF5IHN1cG9ydGVkXG4gICAgdG9JbWFnZURhdGEgPSBuZXcgSW1hZ2VEYXRhKG5ldyBVaW50OENsYW1wZWRBcnJheShyZXN1bHQuZGF0YSksIHRpbGUudG9XaWR0aCwgdGlsZS50b0hlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2sgZm9yIGBub2RlLWNhbnZhc2AgYW5kIG9sZCBicm93c2Vyc1xuICAgIC8vIChJRTExIGhhcyBJbWFnZURhdGEgYnV0IGRvZXMgbm90IHN1cHBvcnQgYG5ldyBJbWFnZURhdGEoKWApXG4gICAgdG9JbWFnZURhdGEgPSBzdGFnZUVudi50b0N0eC5jcmVhdGVJbWFnZURhdGEodGlsZS50b1dpZHRoLCB0aWxlLnRvSGVpZ2h0KTtcblxuICAgIGlmICh0b0ltYWdlRGF0YS5kYXRhLnNldCkge1xuICAgICAgdG9JbWFnZURhdGEuZGF0YS5zZXQocmVzdWx0LmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRTkgZG9uJ3QgaGF2ZSBgLnNldCgpYFxuICAgICAgZm9yICh2YXIgaSA9IHRvSW1hZ2VEYXRhLmRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdG9JbWFnZURhdGEuZGF0YVtpXSA9IHJlc3VsdC5kYXRhW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuZGVidWcoJ0RyYXcgdGlsZScpO1xuXG4gIGlmIChORUVEX1NBRkFSSV9GSVgpIHtcbiAgICAvLyBTYWZhcmkgZHJhd3MgdGhpbiB3aGl0ZSBzdHJpcGVzIGJldHdlZW4gdGlsZXMgd2l0aG91dCB0aGlzIGZpeFxuICAgIHN0YWdlRW52LnRvQ3R4LnB1dEltYWdlRGF0YSh0b0ltYWdlRGF0YSwgdGlsZS50b1gsIHRpbGUudG9ZLCB0aWxlLnRvSW5uZXJYIC0gdGlsZS50b1gsIHRpbGUudG9Jbm5lclkgLSB0aWxlLnRvWSwgdGlsZS50b0lubmVyV2lkdGggKyAxZS01LCB0aWxlLnRvSW5uZXJIZWlnaHQgKyAxZS01KTtcbiAgfSBlbHNlIHtcbiAgICBzdGFnZUVudi50b0N0eC5wdXRJbWFnZURhdGEodG9JbWFnZURhdGEsIHRpbGUudG9YLCB0aWxlLnRvWSwgdGlsZS50b0lubmVyWCAtIHRpbGUudG9YLCB0aWxlLnRvSW5uZXJZIC0gdGlsZS50b1ksIHRpbGUudG9Jbm5lcldpZHRoLCB0aWxlLnRvSW5uZXJIZWlnaHQpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5QaWNhLnByb3RvdHlwZS5fX3RpbGVBbmRSZXNpemUgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIG9wdHMpIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgdmFyIHN0YWdlRW52ID0ge1xuICAgIHNyY0N0eDogbnVsbCxcbiAgICBzcmNJbWFnZUJpdG1hcDogbnVsbCxcbiAgICBpc0ltYWdlQml0bWFwUmV1c2VkOiBmYWxzZSxcbiAgICB0b0N0eDogbnVsbFxuICB9O1xuXG4gIHZhciBwcm9jZXNzVGlsZSA9IGZ1bmN0aW9uIHByb2Nlc3NUaWxlKHRpbGUpIHtcbiAgICByZXR1cm4gX3RoaXMzLl9fbGltaXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG9wdHMuY2FuY2VsZWQpIHJldHVybiBvcHRzLmNhbmNlbFRva2VuO1xuICAgICAgdmFyIHRpbGVPcHRzID0ge1xuICAgICAgICB3aWR0aDogdGlsZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aWxlLmhlaWdodCxcbiAgICAgICAgdG9XaWR0aDogdGlsZS50b1dpZHRoLFxuICAgICAgICB0b0hlaWdodDogdGlsZS50b0hlaWdodCxcbiAgICAgICAgc2NhbGVYOiB0aWxlLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0aWxlLnNjYWxlWSxcbiAgICAgICAgb2Zmc2V0WDogdGlsZS5vZmZzZXRYLFxuICAgICAgICBvZmZzZXRZOiB0aWxlLm9mZnNldFksXG4gICAgICAgIHF1YWxpdHk6IG9wdHMucXVhbGl0eSxcbiAgICAgICAgYWxwaGE6IG9wdHMuYWxwaGEsXG4gICAgICAgIHVuc2hhcnBBbW91bnQ6IG9wdHMudW5zaGFycEFtb3VudCxcbiAgICAgICAgdW5zaGFycFJhZGl1czogb3B0cy51bnNoYXJwUmFkaXVzLFxuICAgICAgICB1bnNoYXJwVGhyZXNob2xkOiBvcHRzLnVuc2hhcnBUaHJlc2hvbGRcbiAgICAgIH07XG5cbiAgICAgIF90aGlzMy5kZWJ1ZygnSW52b2tlIHJlc2l6ZSBtYXRoJyk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGlsZU9wdHMpLnRoZW4oZnVuY3Rpb24gKHRpbGVPcHRzKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMuX19leHRyYWN0VGlsZURhdGEodGlsZSwgZnJvbSwgb3B0cywgc3RhZ2VFbnYsIHRpbGVPcHRzKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHRpbGVPcHRzKSB7XG4gICAgICAgIF90aGlzMy5kZWJ1ZygnSW52b2tlIHJlc2l6ZSBtYXRoJyk7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzMy5fX2ludm9rZVJlc2l6ZSh0aWxlT3B0cywgb3B0cyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKG9wdHMuY2FuY2VsZWQpIHJldHVybiBvcHRzLmNhbmNlbFRva2VuO1xuICAgICAgICBzdGFnZUVudi5zcmNJbWFnZURhdGEgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXMzLl9fbGFuZFRpbGVEYXRhKHRpbGUsIHJlc3VsdCwgc3RhZ2VFbnYpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07IC8vIE5lZWQgdG8gbm9ybWFsaXplIGRhdGEgc291cmNlIGZpcnN0LiBJdCBjYW4gYmUgY2FudmFzIG9yIGltYWdlLlxuICAvLyBJZiBpbWFnZSAtIHRyeSB0byBkZWNvZGUgaW4gYmFja2dyb3VuZCBpZiBwb3NzaWJsZVxuXG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHN0YWdlRW52LnRvQ3R4ID0gdG8uZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgICBhbHBoYTogQm9vbGVhbihvcHRzLmFscGhhKVxuICAgIH0pO1xuICAgIGlmICh1dGlscy5pc0NhbnZhcyhmcm9tKSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAodXRpbHMuaXNJbWFnZUJpdG1hcChmcm9tKSkge1xuICAgICAgc3RhZ2VFbnYuc3JjSW1hZ2VCaXRtYXAgPSBmcm9tO1xuICAgICAgc3RhZ2VFbnYuaXNJbWFnZUJpdG1hcFJldXNlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNJbWFnZShmcm9tKSkge1xuICAgICAgLy8gdHJ5IGRvIGRlY29kZSBpbWFnZSBpbiBiYWNrZ3JvdW5kIGZvciBmYXN0ZXIgbmV4dCBvcGVyYXRpb25zO1xuICAgICAgLy8gaWYgd2UncmUgdXNpbmcgb2Zmc2NyZWVuIGNhbnZhcywgY2liIGlzIGNhbGxlZCBwZXIgdGlsZSwgc28gbm90IG5lZWRlZCBoZXJlXG4gICAgICBpZiAoIUNBTl9DUkVBVEVfSU1BR0VfQklUTUFQKSByZXR1cm4gbnVsbDtcblxuICAgICAgX3RoaXMzLmRlYnVnKCdEZWNvZGUgaW1hZ2UgdmlhIGNyZWF0ZUltYWdlQml0bWFwJyk7XG5cbiAgICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChmcm9tKS50aGVuKGZ1bmN0aW9uIChpbWFnZUJpdG1hcCkge1xuICAgICAgICBzdGFnZUVudi5zcmNJbWFnZUJpdG1hcCA9IGltYWdlQml0bWFwO1xuICAgICAgfSkgLy8gU3VwcHJlc3MgZXJyb3IgdG8gdXNlIGZhbGxiYWNrLCBpZiBtZXRob2QgZmFpbHNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYS9pc3N1ZXMvMTkwXG5cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICBbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignUGljYTogXCIuZnJvbVwiIHNob3VsZCBiZSBJbWFnZSwgQ2FudmFzIG9yIEltYWdlQml0bWFwJyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcHRzLmNhbmNlbGVkKSByZXR1cm4gb3B0cy5jYW5jZWxUb2tlbjtcblxuICAgIF90aGlzMy5kZWJ1ZygnQ2FsY3VsYXRlIHRpbGVzJyk7IC8vXG4gICAgLy8gSGVyZSB3ZSBhcmUgd2l0aCBcIm5vcm1hbGl6ZWRcIiBzb3VyY2UsXG4gICAgLy8gZm9sbG93IHRvIHRpbGluZ1xuICAgIC8vXG5cblxuICAgIHZhciByZWdpb25zID0gY3JlYXRlUmVnaW9ucyh7XG4gICAgICB3aWR0aDogb3B0cy53aWR0aCxcbiAgICAgIGhlaWdodDogb3B0cy5oZWlnaHQsXG4gICAgICBzcmNUaWxlU2l6ZTogX3RoaXMzLm9wdGlvbnMudGlsZSxcbiAgICAgIHRvV2lkdGg6IG9wdHMudG9XaWR0aCxcbiAgICAgIHRvSGVpZ2h0OiBvcHRzLnRvSGVpZ2h0LFxuICAgICAgZGVzdFRpbGVCb3JkZXI6IG9wdHMuX19kZXN0VGlsZUJvcmRlclxuICAgIH0pO1xuICAgIHZhciBqb2JzID0gcmVnaW9ucy5tYXAoZnVuY3Rpb24gKHRpbGUpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzVGlsZSh0aWxlKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNsZWFudXAoc3RhZ2VFbnYpIHtcbiAgICAgIGlmIChzdGFnZUVudi5zcmNJbWFnZUJpdG1hcCkge1xuICAgICAgICBpZiAoIXN0YWdlRW52LmlzSW1hZ2VCaXRtYXBSZXVzZWQpIHN0YWdlRW52LnNyY0ltYWdlQml0bWFwLmNsb3NlKCk7XG4gICAgICAgIHN0YWdlRW52LnNyY0ltYWdlQml0bWFwID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpczMuZGVidWcoJ1Byb2Nlc3MgdGlsZXMnKTtcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChqb2JzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMy5kZWJ1ZygnRmluaXNoZWQhJyk7XG5cbiAgICAgIGNsZWFudXAoc3RhZ2VFbnYpO1xuICAgICAgcmV0dXJuIHRvO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGNsZWFudXAoc3RhZ2VFbnYpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblBpY2EucHJvdG90eXBlLl9fcHJvY2Vzc1N0YWdlcyA9IGZ1bmN0aW9uIChzdGFnZXMsIGZyb20sIHRvLCBvcHRzKSB7XG4gIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gIGlmIChvcHRzLmNhbmNlbGVkKSByZXR1cm4gb3B0cy5jYW5jZWxUb2tlbjtcblxuICB2YXIgX3N0YWdlcyRzaGlmdCA9IHN0YWdlcy5zaGlmdCgpLFxuICAgICAgX3N0YWdlcyRzaGlmdDIgPSBfc2xpY2VkVG9BcnJheShfc3RhZ2VzJHNoaWZ0LCAyKSxcbiAgICAgIHRvV2lkdGggPSBfc3RhZ2VzJHNoaWZ0MlswXSxcbiAgICAgIHRvSGVpZ2h0ID0gX3N0YWdlcyRzaGlmdDJbMV07XG5cbiAgdmFyIGlzTGFzdFN0YWdlID0gc3RhZ2VzLmxlbmd0aCA9PT0gMDtcbiAgb3B0cyA9IGFzc2lnbih7fSwgb3B0cywge1xuICAgIHRvV2lkdGg6IHRvV2lkdGgsXG4gICAgdG9IZWlnaHQ6IHRvSGVpZ2h0LFxuICAgIC8vIG9ubHkgdXNlIHVzZXItZGVmaW5lZCBxdWFsaXR5IGZvciB0aGUgbGFzdCBzdGFnZSxcbiAgICAvLyB1c2Ugc2ltcGxlciAoSGFtbWluZykgZmlsdGVyIGZvciB0aGUgZmlyc3Qgc3RhZ2VzIHdoZXJlXG4gICAgLy8gc2NhbGUgZmFjdG9yIGlzIGxhcmdlIGVub3VnaCAobW9yZSB0aGFuIDItMylcbiAgICBxdWFsaXR5OiBpc0xhc3RTdGFnZSA/IG9wdHMucXVhbGl0eSA6IE1hdGgubWluKDEsIG9wdHMucXVhbGl0eSlcbiAgfSk7XG4gIHZhciB0bXBDYW52YXM7XG5cbiAgaWYgKCFpc0xhc3RTdGFnZSkge1xuICAgIC8vIGNyZWF0ZSB0ZW1wb3JhcnkgY2FudmFzXG4gICAgdG1wQ2FudmFzID0gdGhpcy5vcHRpb25zLmNyZWF0ZUNhbnZhcyh0b1dpZHRoLCB0b0hlaWdodCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fX3RpbGVBbmRSZXNpemUoZnJvbSwgaXNMYXN0U3RhZ2UgPyB0byA6IHRtcENhbnZhcywgb3B0cykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzTGFzdFN0YWdlKSByZXR1cm4gdG87XG4gICAgb3B0cy53aWR0aCA9IHRvV2lkdGg7XG4gICAgb3B0cy5oZWlnaHQgPSB0b0hlaWdodDtcbiAgICByZXR1cm4gX3RoaXM0Ll9fcHJvY2Vzc1N0YWdlcyhzdGFnZXMsIHRtcENhbnZhcywgdG8sIG9wdHMpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICBpZiAodG1wQ2FudmFzKSB7XG4gICAgICAvLyBTYWZhcmkgMTIgd29ya2Fyb3VuZFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9waWNhL2lzc3Vlcy8xOTlcbiAgICAgIHRtcENhbnZhcy53aWR0aCA9IHRtcENhbnZhcy5oZWlnaHQgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH0pO1xufTtcblxuUGljYS5wcm90b3R5cGUuX19yZXNpemVWaWFDcmVhdGVJbWFnZUJpdG1hcCA9IGZ1bmN0aW9uIChmcm9tLCB0bywgb3B0cykge1xuICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICB2YXIgdG9DdHggPSB0by5nZXRDb250ZXh0KCcyZCcsIHtcbiAgICBhbHBoYTogQm9vbGVhbihvcHRzLmFscGhhKVxuICB9KTtcbiAgdGhpcy5kZWJ1ZygnUmVzaXplIHZpYSBjcmVhdGVJbWFnZUJpdG1hcCgpJyk7XG4gIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChmcm9tLCB7XG4gICAgcmVzaXplV2lkdGg6IG9wdHMudG9XaWR0aCxcbiAgICByZXNpemVIZWlnaHQ6IG9wdHMudG9IZWlnaHQsXG4gICAgcmVzaXplUXVhbGl0eTogdXRpbHMuY2liX3F1YWxpdHlfbmFtZShvcHRzLnF1YWxpdHkpXG4gIH0pLnRoZW4oZnVuY3Rpb24gKGltYWdlQml0bWFwKSB7XG4gICAgaWYgKG9wdHMuY2FuY2VsZWQpIHJldHVybiBvcHRzLmNhbmNlbFRva2VuOyAvLyBpZiBubyB1bnNoYXJwIC0gZHJhdyBkaXJlY3RseSB0byBvdXRwdXQgY2FudmFzXG5cbiAgICBpZiAoIW9wdHMudW5zaGFycEFtb3VudCkge1xuICAgICAgdG9DdHguZHJhd0ltYWdlKGltYWdlQml0bWFwLCAwLCAwKTtcbiAgICAgIGltYWdlQml0bWFwLmNsb3NlKCk7XG4gICAgICB0b0N0eCA9IG51bGw7XG5cbiAgICAgIF90aGlzNS5kZWJ1ZygnRmluaXNoZWQhJyk7XG5cbiAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICBfdGhpczUuZGVidWcoJ1Vuc2hhcnAgcmVzdWx0Jyk7XG5cbiAgICB2YXIgdG1wQ2FudmFzID0gX3RoaXM1Lm9wdGlvbnMuY3JlYXRlQ2FudmFzKG9wdHMudG9XaWR0aCwgb3B0cy50b0hlaWdodCk7XG5cbiAgICB2YXIgdG1wQ3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJywge1xuICAgICAgYWxwaGE6IEJvb2xlYW4ob3B0cy5hbHBoYSlcbiAgICB9KTtcbiAgICB0bXBDdHguZHJhd0ltYWdlKGltYWdlQml0bWFwLCAwLCAwKTtcbiAgICBpbWFnZUJpdG1hcC5jbG9zZSgpO1xuICAgIHZhciBpRGF0YSA9IHRtcEN0eC5nZXRJbWFnZURhdGEoMCwgMCwgb3B0cy50b1dpZHRoLCBvcHRzLnRvSGVpZ2h0KTtcblxuICAgIF90aGlzNS5fX21hdGhsaWIudW5zaGFycF9tYXNrKGlEYXRhLmRhdGEsIG9wdHMudG9XaWR0aCwgb3B0cy50b0hlaWdodCwgb3B0cy51bnNoYXJwQW1vdW50LCBvcHRzLnVuc2hhcnBSYWRpdXMsIG9wdHMudW5zaGFycFRocmVzaG9sZCk7XG5cbiAgICB0b0N0eC5wdXRJbWFnZURhdGEoaURhdGEsIDAsIDApOyAvLyBTYWZhcmkgMTIgd29ya2Fyb3VuZFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYS9pc3N1ZXMvMTk5XG5cbiAgICB0bXBDYW52YXMud2lkdGggPSB0bXBDYW52YXMuaGVpZ2h0ID0gMDtcbiAgICBpRGF0YSA9IHRtcEN0eCA9IHRtcENhbnZhcyA9IHRvQ3R4ID0gbnVsbDtcblxuICAgIF90aGlzNS5kZWJ1ZygnRmluaXNoZWQhJyk7XG5cbiAgICByZXR1cm4gdG87XG4gIH0pO1xufTtcblxuUGljYS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gIHRoaXMuZGVidWcoJ1N0YXJ0IHJlc2l6ZS4uLicpO1xuICB2YXIgb3B0cyA9IGFzc2lnbih7fSwgREVGQVVMVF9SRVNJWkVfT1BUUyk7XG5cbiAgaWYgKCFpc05hTihvcHRpb25zKSkge1xuICAgIG9wdHMgPSBhc3NpZ24ob3B0cywge1xuICAgICAgcXVhbGl0eTogb3B0aW9uc1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcbiAgICBvcHRzID0gYXNzaWduKG9wdHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgb3B0cy50b1dpZHRoID0gdG8ud2lkdGg7XG4gIG9wdHMudG9IZWlnaHQgPSB0by5oZWlnaHQ7XG4gIG9wdHMud2lkdGggPSBmcm9tLm5hdHVyYWxXaWR0aCB8fCBmcm9tLndpZHRoO1xuICBvcHRzLmhlaWdodCA9IGZyb20ubmF0dXJhbEhlaWdodCB8fCBmcm9tLmhlaWdodDsgLy8gUHJldmVudCBzdGVwcGVyIGZyb20gaW5maW5pdGUgbG9vcFxuXG4gIGlmICh0by53aWR0aCA9PT0gMCB8fCB0by5oZWlnaHQgPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBvdXRwdXQgc2l6ZTogXCIuY29uY2F0KHRvLndpZHRoLCBcInhcIikuY29uY2F0KHRvLmhlaWdodCkpKTtcbiAgfVxuXG4gIGlmIChvcHRzLnVuc2hhcnBSYWRpdXMgPiAyKSBvcHRzLnVuc2hhcnBSYWRpdXMgPSAyO1xuICBvcHRzLmNhbmNlbGVkID0gZmFsc2U7XG5cbiAgaWYgKG9wdHMuY2FuY2VsVG9rZW4pIHtcbiAgICAvLyBXcmFwIGNhbmNlbFRva2VuIHRvIGF2b2lkIHN1Y2Nlc3NpdmUgcmVzb2x2ZSAmIHNldCBmbGFnXG4gICAgb3B0cy5jYW5jZWxUb2tlbiA9IG9wdHMuY2FuY2VsVG9rZW4udGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgb3B0cy5jYW5jZWxlZCA9IHRydWU7XG4gICAgICB0aHJvdyBkYXRhO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIG9wdHMuY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIERFU1RfVElMRV9CT1JERVIgPSAzOyAvLyBNYXggcG9zc2libGUgZmlsdGVyIHdpbmRvdyBzaXplXG5cbiAgb3B0cy5fX2Rlc3RUaWxlQm9yZGVyID0gTWF0aC5jZWlsKE1hdGgubWF4KERFU1RfVElMRV9CT1JERVIsIDIuNSAqIG9wdHMudW5zaGFycFJhZGl1cyB8IDApKTtcbiAgcmV0dXJuIHRoaXMuaW5pdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcHRzLmNhbmNlbGVkKSByZXR1cm4gb3B0cy5jYW5jZWxUb2tlbjsgLy8gaWYgY3JlYXRlSW1hZ2VCaXRtYXAgc3VwcG9ydHMgcmVzaXplLCBqdXN0IGRvIGl0IGFuZCByZXR1cm5cblxuICAgIGlmIChfdGhpczYuZmVhdHVyZXMuY2liKSB7XG4gICAgICByZXR1cm4gX3RoaXM2Ll9fcmVzaXplVmlhQ3JlYXRlSW1hZ2VCaXRtYXAoZnJvbSwgdG8sIG9wdHMpO1xuICAgIH1cblxuICAgIGlmICghQ0FOX1VTRV9DQU5WQVNfR0VUX0lNQUdFX0RBVEEpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1BpY2E6IGNhbm5vdCB1c2UgZ2V0SW1hZ2VEYXRhIG9uIGNhbnZhcywgJyArIFwibWFrZSBzdXJlIGZpbmdlcnByaW50aW5nIHByb3RlY3Rpb24gaXNuJ3QgZW5hYmxlZFwiKTtcbiAgICAgIGVyci5jb2RlID0gJ0VSUl9HRVRfSU1BR0VfREFUQSc7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSAvL1xuICAgIC8vIE5vIGVhc3kgd2F5LCBsZXQncyByZXNpemUgbWFudWFsbHkgdmlhIGFycmF5c1xuICAgIC8vXG5cblxuICAgIHZhciBzdGFnZXMgPSBjcmVhdGVTdGFnZXMob3B0cy53aWR0aCwgb3B0cy5oZWlnaHQsIG9wdHMudG9XaWR0aCwgb3B0cy50b0hlaWdodCwgX3RoaXM2Lm9wdGlvbnMudGlsZSwgb3B0cy5fX2Rlc3RUaWxlQm9yZGVyKTtcbiAgICByZXR1cm4gX3RoaXM2Ll9fcHJvY2Vzc1N0YWdlcyhzdGFnZXMsIGZyb20sIHRvLCBvcHRzKTtcbiAgfSk7XG59OyAvLyBSR0JBIGJ1ZmZlciByZXNpemVcbi8vXG5cblxuUGljYS5wcm90b3R5cGUucmVzaXplQnVmZmVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgdmFyIG9wdHMgPSBhc3NpZ24oe30sIERFRkFVTFRfUkVTSVpFX09QVFMsIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcy5pbml0KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90aGlzNy5fX21hdGhsaWIucmVzaXplQW5kVW5zaGFycChvcHRzKTtcbiAgfSk7XG59O1xuXG5QaWNhLnByb3RvdHlwZS50b0Jsb2IgPSBmdW5jdGlvbiAoY2FudmFzLCBtaW1lVHlwZSwgcXVhbGl0eSkge1xuICBtaW1lVHlwZSA9IG1pbWVUeXBlIHx8ICdpbWFnZS9wbmcnO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICBpZiAoY2FudmFzLnRvQmxvYikge1xuICAgICAgY2FudmFzLnRvQmxvYihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShibG9iKTtcbiAgICAgIH0sIG1pbWVUeXBlLCBxdWFsaXR5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2FudmFzLmNvbnZlcnRUb0Jsb2IpIHtcbiAgICAgIHJlc29sdmUoY2FudmFzLmNvbnZlcnRUb0Jsb2Ioe1xuICAgICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICAgICAgcXVhbGl0eTogcXVhbGl0eVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmFsbGJhY2sgZm9yIG9sZCBicm93c2Vyc1xuXG5cbiAgICB2YXIgYXNTdHJpbmcgPSBhdG9iKGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIHF1YWxpdHkpLnNwbGl0KCcsJylbMV0pO1xuICAgIHZhciBsZW4gPSBhc1N0cmluZy5sZW5ndGg7XG4gICAgdmFyIGFzQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFzQnVmZmVyW2ldID0gYXNTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXNvbHZlKG5ldyBCbG9iKFthc0J1ZmZlcl0sIHtcbiAgICAgIHR5cGU6IG1pbWVUeXBlXG4gICAgfSkpO1xuICB9KTtcbn07XG5cblBpY2EucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKCkge307XG5cbm1vZHVsZS5leHBvcnRzID0gUGljYTtcblxufSx7XCIuL2xpYi9tYXRobGliXCI6MSxcIi4vbGliL3Bvb2xcIjoxMyxcIi4vbGliL3N0ZXBwZXJcIjoxNCxcIi4vbGliL3RpbGVyXCI6MTUsXCIuL2xpYi91dGlsc1wiOjE2LFwiLi9saWIvd29ya2VyXCI6MTcsXCJvYmplY3QtYXNzaWduXCI6MjMsXCJ3ZWJ3b3JraWZ5XCI6MjR9XX0se30sW10pKFwiL2luZGV4LmpzXCIpXG59KTtcbn0pO1xuXG52YXIgaW1hZ2VfdHJhdmVyc2UgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXJzXG4vL1xuZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgY29kZSkge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnIuY29kZSA9IGNvZGU7XG4gIHJldHVybiBlcnI7XG59XG5cblxuLy8gQ29udmVydCBudW1iZXIgdG8gMHhISCBzdHJpbmdcbi8vXG5mdW5jdGlvbiB0b19oZXgobnVtYmVyKSB7XG4gIHZhciBuID0gbnVtYmVyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICBmb3IgKHZhciBpID0gMiAtIG4ubGVuZ3RoOyBpID4gMDsgaS0tKSBuID0gJzAnICsgbjtcbiAgcmV0dXJuICcweCcgKyBuO1xufVxuXG5cbmZ1bmN0aW9uIHV0ZjhfZW5jb2RlKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gdXRmOF9kZWNvZGUoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuLy8gQ2hlY2sgaWYgaW5wdXQgaXMgYSBVaW50OEFycmF5XG4vL1xuZnVuY3Rpb24gaXNfdWludDhhcnJheShiaW4pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiaW4pID09PSAnW29iamVjdCBVaW50OEFycmF5XSc7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEV4aWYgcGFyc2VyXG4vL1xuLy8gSW5wdXQ6XG4vLyAgLSBqcGVnX2JpbjogICBVaW50OEFycmF5IC0ganBlZyBmaWxlXG4vLyAgLSBleGlmX3N0YXJ0OiBOdW1iZXIgICAgIC0gc3RhcnQgb2YgVElGRiBoZWFkZXIgKGFmdGVyIEV4aWZcXDBcXDApXG4vLyAgLSBleGlmX2VuZDogICBOdW1iZXIgICAgIC0gZW5kIG9mIEV4aWYgc2VnbWVudFxuLy8gIC0gb25fZW50cnk6ICAgTnVtYmVyICAgICAtIGNhbGxiYWNrXG4vL1xuZnVuY3Rpb24gRXhpZlBhcnNlcihqcGVnX2JpbiwgZXhpZl9zdGFydCwgZXhpZl9lbmQpIHtcbiAgLy8gVWludDhBcnJheSwgZXhpZiB3aXRob3V0IHNpZ25hdHVyZSAod2hpY2ggaXNuJ3QgaW5jbHVkZWQgaW4gb2Zmc2V0cylcbiAgdGhpcy5pbnB1dCAgICAgID0ganBlZ19iaW4uc3ViYXJyYXkoZXhpZl9zdGFydCwgZXhpZl9lbmQpO1xuXG4gIC8vIG9mZnNldCBjb3JyZWN0aW9uIGZvciBgb25fZW50cnlgIGNhbGxiYWNrXG4gIHRoaXMuc3RhcnQgICAgICA9IGV4aWZfc3RhcnQ7XG5cbiAgLy8gQ2hlY2sgVElGRiBoZWFkZXIgKGluY2x1ZGVzIGJ5dGUgYWxpZ25tZW50IGFuZCBmaXJzdCBJRkQgb2Zmc2V0KVxuICB2YXIgc2lnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB0aGlzLmlucHV0LnN1YmFycmF5KDAsIDQpKTtcblxuICBpZiAoc2lnICE9PSAnSUlcXHgyQVxcMCcgJiYgc2lnICE9PSAnTU1cXDBcXHgyQScpIHtcbiAgICB0aHJvdyBlcnJvcignaW52YWxpZCBUSUZGIHNpZ25hdHVyZScsICdFQkFEREFUQScpO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBtb3Rvcm9sYSAoYmlnIGVuZGlhbikgYnl0ZSBhbGlnbm1lbnQsIGZhbHNlIGlmIGludGVsXG4gIHRoaXMuYmlnX2VuZGlhbiA9IHNpZ1swXSA9PT0gJ00nO1xufVxuXG5cbkV4aWZQYXJzZXIucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAob25fZW50cnkpIHtcbiAgLy8gYWxsb3cgcHJlbWF0dXJlIGV4aXRcbiAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XG5cbiAgdmFyIG9mZnNldCA9IHRoaXMucmVhZF91aW50MzIoNCk7XG5cbiAgdGhpcy5pZmRzX3RvX3JlYWQgPSBbIHtcbiAgICBpZDogICAgIDAsXG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgfSBdO1xuXG4gIHdoaWxlICh0aGlzLmlmZHNfdG9fcmVhZC5sZW5ndGggPiAwICYmICF0aGlzLmFib3J0ZWQpIHtcbiAgICB2YXIgaSA9IHRoaXMuaWZkc190b19yZWFkLnNoaWZ0KCk7XG4gICAgaWYgKCFpLm9mZnNldCkgY29udGludWU7XG4gICAgdGhpcy5zY2FuX2lmZChpLmlkLCBpLm9mZnNldCwgb25fZW50cnkpO1xuICB9XG59O1xuXG5cbkV4aWZQYXJzZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChvbl9lbnRyeSkge1xuICB2YXIgaWZkcyA9IHt9O1xuXG4gIC8vIG1ha2Ugc3VyZSBJRkQwIGFsd2F5cyBleGlzdHNcbiAgaWZkcy5pZmQwID0geyBpZDogMCwgZW50cmllczogW10gfTtcblxuICB0aGlzLmVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgaWYgKG9uX2VudHJ5KGVudHJ5KSA9PT0gZmFsc2UgJiYgIWVudHJ5LmlzX3N1YmlmZF9saW5rKSByZXR1cm47XG4gICAgaWYgKGVudHJ5LmlzX3N1YmlmZF9saW5rICYmIGVudHJ5LmNvdW50ICE9PSAxICYmIGVudHJ5LmZvcm1hdCAhPT0gNCkgcmV0dXJuOyAvLyBmaWx0ZXIgb3V0IGJvZ3VzIGxpbmtzXG5cbiAgICBpZiAoIWlmZHNbJ2lmZCcgKyBlbnRyeS5pZmRdKSB7XG4gICAgICBpZmRzWydpZmQnICsgZW50cnkuaWZkXSA9IHsgaWQ6IGVudHJ5LmlmZCwgZW50cmllczogW10gfTtcbiAgICB9XG5cbiAgICBpZmRzWydpZmQnICsgZW50cnkuaWZkXS5lbnRyaWVzLnB1c2goZW50cnkpO1xuICB9KTtcblxuICAvLyB0aHVtYm5haWxzIGFyZSBub3Qgc3VwcG9ydGVkIGp1c3QgeWV0LCBzbyBkZWxldGUgYWxsIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gaXRcbiAgZGVsZXRlIGlmZHMuaWZkMTtcblxuICAvLyBDYWxjdWxhdGUgb3V0cHV0IHNpemVcbiAgdmFyIGxlbmd0aCA9IDg7XG4gIE9iamVjdC5rZXlzKGlmZHMpLmZvckVhY2goZnVuY3Rpb24gKGlmZF9ubykge1xuICAgIGxlbmd0aCArPSAyO1xuXG4gICAgaWZkc1tpZmRfbm9dLmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgIGxlbmd0aCArPSAxMiArIChlbnRyeS5kYXRhX2xlbmd0aCA+IDQgPyBNYXRoLmNlaWwoZW50cnkuZGF0YV9sZW5ndGggLyAyKSAqIDIgOiAwKTtcbiAgICB9KTtcblxuICAgIGxlbmd0aCArPSA0O1xuICB9KTtcblxuICB0aGlzLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIHRoaXMub3V0cHV0WzBdID0gdGhpcy5vdXRwdXRbMV0gPSAodGhpcy5iaWdfZW5kaWFuID8gJ00nIDogJ0knKS5jaGFyQ29kZUF0KDApO1xuICB0aGlzLndyaXRlX3VpbnQxNigyLCAweDJBKTtcblxuICB2YXIgb2Zmc2V0ID0gODtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRlX3VpbnQzMig0LCBvZmZzZXQpO1xuXG4gIE9iamVjdC5rZXlzKGlmZHMpLmZvckVhY2goZnVuY3Rpb24gKGlmZF9ubykge1xuICAgIGlmZHNbaWZkX25vXS53cml0dGVuX29mZnNldCA9IG9mZnNldDtcblxuICAgIHZhciBpZmRfc3RhcnQgPSBvZmZzZXQ7XG4gICAgdmFyIGlmZF9lbmQgICA9IGlmZF9zdGFydCArIDIgKyBpZmRzW2lmZF9ub10uZW50cmllcy5sZW5ndGggKiAxMiArIDQ7XG4gICAgb2Zmc2V0ID0gaWZkX2VuZDtcblxuICAgIHNlbGYud3JpdGVfdWludDE2KGlmZF9zdGFydCwgaWZkc1tpZmRfbm9dLmVudHJpZXMubGVuZ3RoKTtcblxuICAgIGlmZHNbaWZkX25vXS5lbnRyaWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIElGRCBlbnRyaWVzIG11c3QgYmUgaW4gb3JkZXIgb2YgaW5jcmVhc2luZyB0YWcgSURzXG4gICAgICByZXR1cm4gYS50YWcgLSBiLnRhZztcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSwgaWR4KSB7XG4gICAgICB2YXIgZW50cnlfb2Zmc2V0ID0gaWZkX3N0YXJ0ICsgMiArIGlkeCAqIDEyO1xuXG4gICAgICBzZWxmLndyaXRlX3VpbnQxNihlbnRyeV9vZmZzZXQsIGVudHJ5LnRhZyk7XG4gICAgICBzZWxmLndyaXRlX3VpbnQxNihlbnRyeV9vZmZzZXQgKyAyLCBlbnRyeS5mb3JtYXQpO1xuICAgICAgc2VsZi53cml0ZV91aW50MzIoZW50cnlfb2Zmc2V0ICsgNCwgZW50cnkuY291bnQpO1xuXG4gICAgICBpZiAoZW50cnkuaXNfc3ViaWZkX2xpbmspIHtcbiAgICAgICAgLy8gZmlsbGVkIGluIGxhdGVyXG4gICAgICAgIGlmIChpZmRzWydpZmQnICsgZW50cnkudGFnXSkgaWZkc1snaWZkJyArIGVudHJ5LnRhZ10ubGlua19vZmZzZXQgPSBlbnRyeV9vZmZzZXQgKyA4O1xuICAgICAgfSBlbHNlIGlmIChlbnRyeS5kYXRhX2xlbmd0aCA8PSA0KSB7XG4gICAgICAgIHNlbGYub3V0cHV0LnNldChcbiAgICAgICAgICBzZWxmLmlucHV0LnN1YmFycmF5KGVudHJ5LmRhdGFfb2Zmc2V0IC0gc2VsZi5zdGFydCwgZW50cnkuZGF0YV9vZmZzZXQgLSBzZWxmLnN0YXJ0ICsgNCksXG4gICAgICAgICAgZW50cnlfb2Zmc2V0ICsgOFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi53cml0ZV91aW50MzIoZW50cnlfb2Zmc2V0ICsgOCwgb2Zmc2V0KTtcbiAgICAgICAgc2VsZi5vdXRwdXQuc2V0KFxuICAgICAgICAgIHNlbGYuaW5wdXQuc3ViYXJyYXkoZW50cnkuZGF0YV9vZmZzZXQgLSBzZWxmLnN0YXJ0LCBlbnRyeS5kYXRhX29mZnNldCAtIHNlbGYuc3RhcnQgKyBlbnRyeS5kYXRhX2xlbmd0aCksXG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgICk7XG4gICAgICAgIG9mZnNldCArPSBNYXRoLmNlaWwoZW50cnkuZGF0YV9sZW5ndGggLyAyKSAqIDI7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgbmV4dF9pZmQgPSBpZmRzWydpZmQnICsgKGlmZHNbaWZkX25vXS5pZCArIDEpXTtcbiAgICBpZiAobmV4dF9pZmQpIG5leHRfaWZkLmxpbmtfb2Zmc2V0ID0gaWZkX2VuZCAtIDQ7XG4gIH0pO1xuXG4gIE9iamVjdC5rZXlzKGlmZHMpLmZvckVhY2goZnVuY3Rpb24gKGlmZF9ubykge1xuICAgIGlmIChpZmRzW2lmZF9ub10ud3JpdHRlbl9vZmZzZXQgJiYgaWZkc1tpZmRfbm9dLmxpbmtfb2Zmc2V0KSB7XG4gICAgICBzZWxmLndyaXRlX3VpbnQzMihpZmRzW2lmZF9ub10ubGlua19vZmZzZXQsIGlmZHNbaWZkX25vXS53cml0dGVuX29mZnNldCk7XG4gICAgfVxuICB9KTtcblxuICBpZiAodGhpcy5vdXRwdXQubGVuZ3RoICE9PSBvZmZzZXQpIHRocm93IGVycm9yKCdpbnRlcm5hbCBlcnJvcjogaW5jb3JyZWN0IGJ1ZmZlciBzaXplIGFsbG9jYXRlZCcpO1xuXG4gIHJldHVybiB0aGlzLm91dHB1dDtcbn07XG5cblxuRXhpZlBhcnNlci5wcm90b3R5cGUucmVhZF91aW50MTYgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIHZhciBkID0gdGhpcy5pbnB1dDtcbiAgaWYgKG9mZnNldCArIDIgPiBkLmxlbmd0aCkgdGhyb3cgZXJyb3IoJ3VuZXhwZWN0ZWQgRU9GJywgJ0VCQUREQVRBJyk7XG5cbiAgcmV0dXJuIHRoaXMuYmlnX2VuZGlhbiA/XG4gICAgZFtvZmZzZXRdICogMHgxMDAgKyBkW29mZnNldCArIDFdIDpcbiAgICBkW29mZnNldF0gKyBkW29mZnNldCArIDFdICogMHgxMDA7XG59O1xuXG5cbkV4aWZQYXJzZXIucHJvdG90eXBlLnJlYWRfdWludDMyID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICB2YXIgZCA9IHRoaXMuaW5wdXQ7XG4gIGlmIChvZmZzZXQgKyA0ID4gZC5sZW5ndGgpIHRocm93IGVycm9yKCd1bmV4cGVjdGVkIEVPRicsICdFQkFEREFUQScpO1xuXG4gIHJldHVybiB0aGlzLmJpZ19lbmRpYW4gP1xuICAgIGRbb2Zmc2V0XSAqIDB4MTAwMDAwMCArIGRbb2Zmc2V0ICsgMV0gKiAweDEwMDAwICsgZFtvZmZzZXQgKyAyXSAqIDB4MTAwICsgZFtvZmZzZXQgKyAzXSA6XG4gICAgZFtvZmZzZXRdICsgZFtvZmZzZXQgKyAxXSAqIDB4MTAwICsgZFtvZmZzZXQgKyAyXSAqIDB4MTAwMDAgKyBkW29mZnNldCArIDNdICogMHgxMDAwMDAwO1xufTtcblxuXG5FeGlmUGFyc2VyLnByb3RvdHlwZS53cml0ZV91aW50MTYgPSBmdW5jdGlvbiAob2Zmc2V0LCB2YWx1ZSkge1xuICB2YXIgZCA9IHRoaXMub3V0cHV0O1xuXG4gIGlmICh0aGlzLmJpZ19lbmRpYW4pIHtcbiAgICBkW29mZnNldF0gICAgID0gKHZhbHVlID4+PiA4KSAmIDB4RkY7XG4gICAgZFtvZmZzZXQgKyAxXSA9IHZhbHVlICYgMHhGRjtcbiAgfSBlbHNlIHtcbiAgICBkW29mZnNldF0gICAgID0gdmFsdWUgJiAweEZGO1xuICAgIGRbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpICYgMHhGRjtcbiAgfVxufTtcblxuXG5FeGlmUGFyc2VyLnByb3RvdHlwZS53cml0ZV91aW50MzIgPSBmdW5jdGlvbiAob2Zmc2V0LCB2YWx1ZSkge1xuICB2YXIgZCA9IHRoaXMub3V0cHV0O1xuXG4gIGlmICh0aGlzLmJpZ19lbmRpYW4pIHtcbiAgICBkW29mZnNldF0gICAgID0gKHZhbHVlID4+PiAyNCkgJiAweEZGO1xuICAgIGRbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KSAmIDB4RkY7XG4gICAgZFtvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweEZGO1xuICAgIGRbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDB4RkY7XG4gIH0gZWxzZSB7XG4gICAgZFtvZmZzZXRdICAgICA9IHZhbHVlICYgMHhGRjtcbiAgICBkW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KSAmIDB4RkY7XG4gICAgZFtvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhGRjtcbiAgICBkW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCkgJiAweEZGO1xuICB9XG59O1xuXG5cbkV4aWZQYXJzZXIucHJvdG90eXBlLmlzX3N1YmlmZF9saW5rID0gZnVuY3Rpb24gKGlmZCwgdGFnKSB7XG4gIHJldHVybiAoaWZkID09PSAwICYmIHRhZyA9PT0gMHg4NzY5KSB8fCAvLyBTdWJJRkRcbiAgICAgICAgIChpZmQgPT09IDAgJiYgdGFnID09PSAweDg4MjUpIHx8IC8vIEdQUyBJbmZvXG4gICAgICAgICAoaWZkID09PSAweDg3NjkgJiYgdGFnID09PSAweEEwMDUpOyAvLyBJbnRlcm9wIElGRFxufTtcblxuXG4vLyBSZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGEgc2luZ2xlIGNvbXBvbmVudCBvZiBhIGdpdmVuIGZvcm1hdFxuLy9cbkV4aWZQYXJzZXIucHJvdG90eXBlLmV4aWZfZm9ybWF0X2xlbmd0aCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIDE6IC8vIGJ5dGVcbiAgICBjYXNlIDI6IC8vIGFzY2lpXG4gICAgY2FzZSA2OiAvLyBzYnl0ZVxuICAgIGNhc2UgNzogLy8gdW5kZWZpbmVkXG4gICAgICByZXR1cm4gMTtcblxuICAgIGNhc2UgMzogLy8gc2hvcnRcbiAgICBjYXNlIDg6IC8vIHNzaG9ydFxuICAgICAgcmV0dXJuIDI7XG5cbiAgICBjYXNlIDQ6ICAvLyBsb25nXG4gICAgY2FzZSA5OiAgLy8gc2xvbmdcbiAgICBjYXNlIDExOiAvLyBmbG9hdFxuICAgICAgcmV0dXJuIDQ7XG5cbiAgICBjYXNlIDU6ICAvLyByYXRpb25hbFxuICAgIGNhc2UgMTA6IC8vIHNyYXRpb25hbFxuICAgIGNhc2UgMTI6IC8vIGRvdWJsZVxuICAgICAgcmV0dXJuIDg7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gdW5rbm93biB0eXBlXG4gICAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuXG4vLyBSZWFkcyBFeGlmIGRhdGFcbi8vXG5FeGlmUGFyc2VyLnByb3RvdHlwZS5leGlmX2Zvcm1hdF9yZWFkID0gZnVuY3Rpb24gKGZvcm1hdCwgb2Zmc2V0KSB7XG4gIHZhciB2O1xuXG4gIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgY2FzZSAxOiAvLyBieXRlXG4gICAgY2FzZSAyOiAvLyBhc2NpaVxuICAgICAgdiA9IHRoaXMuaW5wdXRbb2Zmc2V0XTtcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSA2OiAvLyBzYnl0ZVxuICAgICAgdiA9IHRoaXMuaW5wdXRbb2Zmc2V0XTtcbiAgICAgIHJldHVybiB2IHwgKHYgJiAweDgwKSAqIDB4MWZmZmZmZTtcblxuICAgIGNhc2UgMzogLy8gc2hvcnRcbiAgICAgIHYgPSB0aGlzLnJlYWRfdWludDE2KG9mZnNldCk7XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgODogLy8gc3Nob3J0XG4gICAgICB2ID0gdGhpcy5yZWFkX3VpbnQxNihvZmZzZXQpO1xuICAgICAgcmV0dXJuIHYgfCAodiAmIDB4ODAwMCkgKiAweDFmZmZlO1xuXG4gICAgY2FzZSA0OiAvLyBsb25nXG4gICAgICB2ID0gdGhpcy5yZWFkX3VpbnQzMihvZmZzZXQpO1xuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlIDk6IC8vIHNsb25nXG4gICAgICB2ID0gdGhpcy5yZWFkX3VpbnQzMihvZmZzZXQpO1xuICAgICAgcmV0dXJuIHYgfCAwO1xuXG4gICAgY2FzZSA1OiAgLy8gcmF0aW9uYWxcbiAgICBjYXNlIDEwOiAvLyBzcmF0aW9uYWxcbiAgICBjYXNlIDExOiAvLyBmbG9hdFxuICAgIGNhc2UgMTI6IC8vIGRvdWJsZVxuICAgICAgcmV0dXJuIG51bGw7IC8vIG5vdCBpbXBsZW1lbnRlZFxuXG4gICAgY2FzZSA3OiAvLyB1bmRlZmluZWRcbiAgICAgIHJldHVybiBudWxsOyAvLyBibG9iXG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gdW5rbm93biB0eXBlXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuXG5FeGlmUGFyc2VyLnByb3RvdHlwZS5zY2FuX2lmZCA9IGZ1bmN0aW9uIChpZmRfbm8sIG9mZnNldCwgb25fZW50cnkpIHtcbiAgdmFyIGVudHJ5X2NvdW50ID0gdGhpcy5yZWFkX3VpbnQxNihvZmZzZXQpO1xuXG4gIG9mZnNldCArPSAyO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cnlfY291bnQ7IGkrKykge1xuICAgIHZhciB0YWcgICAgPSB0aGlzLnJlYWRfdWludDE2KG9mZnNldCk7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMucmVhZF91aW50MTYob2Zmc2V0ICsgMik7XG4gICAgdmFyIGNvdW50ICA9IHRoaXMucmVhZF91aW50MzIob2Zmc2V0ICsgNCk7XG5cbiAgICB2YXIgY29tcF9sZW5ndGggICAgPSB0aGlzLmV4aWZfZm9ybWF0X2xlbmd0aChmb3JtYXQpO1xuICAgIHZhciBkYXRhX2xlbmd0aCAgICA9IGNvdW50ICogY29tcF9sZW5ndGg7XG4gICAgdmFyIGRhdGFfb2Zmc2V0ICAgID0gZGF0YV9sZW5ndGggPD0gNCA/IG9mZnNldCArIDggOiB0aGlzLnJlYWRfdWludDMyKG9mZnNldCArIDgpO1xuICAgIHZhciBpc19zdWJpZmRfbGluayA9IGZhbHNlO1xuXG4gICAgaWYgKGRhdGFfb2Zmc2V0ICsgZGF0YV9sZW5ndGggPiB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgZXJyb3IoJ3VuZXhwZWN0ZWQgRU9GJywgJ0VCQUREQVRBJyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gW107XG4gICAgdmFyIGNvbXBfb2Zmc2V0ID0gZGF0YV9vZmZzZXQ7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyssIGNvbXBfb2Zmc2V0ICs9IGNvbXBfbGVuZ3RoKSB7XG4gICAgICB2YXIgaXRlbSA9IHRoaXMuZXhpZl9mb3JtYXRfcmVhZChmb3JtYXQsIGNvbXBfb2Zmc2V0KTtcbiAgICAgIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YWx1ZS5wdXNoKGl0ZW0pO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBmb3JtYXQgPT09IDIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlID0gdXRmOF9kZWNvZGUoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1xcMCcpIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgLTEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzX3N1YmlmZF9saW5rKGlmZF9ubywgdGFnKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIE51bWJlci5pc0ludGVnZXIodmFsdWVbMF0pICYmIHZhbHVlWzBdID4gMCkge1xuICAgICAgICB0aGlzLmlmZHNfdG9fcmVhZC5wdXNoKHtcbiAgICAgICAgICBpZDogICAgIHRhZyxcbiAgICAgICAgICBvZmZzZXQ6IHZhbHVlWzBdXG4gICAgICAgIH0pO1xuICAgICAgICBpc19zdWJpZmRfbGluayA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgaXNfYmlnX2VuZGlhbjogIHRoaXMuYmlnX2VuZGlhbixcbiAgICAgIGlmZDogICAgICAgICAgICBpZmRfbm8sXG4gICAgICB0YWc6ICAgICAgICAgICAgdGFnLFxuICAgICAgZm9ybWF0OiAgICAgICAgIGZvcm1hdCxcbiAgICAgIGNvdW50OiAgICAgICAgICBjb3VudCxcbiAgICAgIGVudHJ5X29mZnNldDogICBvZmZzZXQgKyB0aGlzLnN0YXJ0LFxuICAgICAgZGF0YV9sZW5ndGg6ICAgIGRhdGFfbGVuZ3RoLFxuICAgICAgZGF0YV9vZmZzZXQ6ICAgIGRhdGFfb2Zmc2V0ICsgdGhpcy5zdGFydCxcbiAgICAgIHZhbHVlOiAgICAgICAgICB2YWx1ZSxcbiAgICAgIGlzX3N1YmlmZF9saW5rOiBpc19zdWJpZmRfbGlua1xuICAgIH07XG5cbiAgICBpZiAob25fZW50cnkoZW50cnkpID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gMTI7XG4gIH1cblxuICBpZiAoaWZkX25vID09PSAwKSB7XG4gICAgdGhpcy5pZmRzX3RvX3JlYWQucHVzaCh7XG4gICAgICBpZDogICAgIDEsXG4gICAgICBvZmZzZXQ6IHRoaXMucmVhZF91aW50MzIob2Zmc2V0KVxuICAgIH0pO1xuICB9XG59O1xuXG5cbi8vIENoZWNrIHdoZXRoZXIgaW5wdXQgaXMgYSBKUEVHIGltYWdlXG4vL1xuLy8gSW5wdXQ6XG4vLyAgLSBqcGVnX2JpbjogVWludDhBcnJheSAtIGpwZWcgZmlsZVxuLy9cbi8vIFJldHVybnMgdHJ1ZSBpZiBpdCBpcyBhbmQgZmFsc2Ugb3RoZXJ3aXNlXG4vL1xubW9kdWxlLmV4cG9ydHMuaXNfanBlZyA9IGZ1bmN0aW9uIChqcGVnX2Jpbikge1xuICByZXR1cm4ganBlZ19iaW4ubGVuZ3RoID49IDQgJiYganBlZ19iaW5bMF0gPT09IDB4RkYgJiYganBlZ19iaW5bMV0gPT09IDB4RDggJiYganBlZ19iaW5bMl0gPT09IDB4RkY7XG59O1xuXG5cbi8vIENhbGwgYW4gaXRlcmF0b3Igb24gZWFjaCBzZWdtZW50IGluIHRoZSBnaXZlbiBKUEVHIGltYWdlXG4vL1xuLy8gSW5wdXQ6XG4vLyAgLSBqcGVnX2JpbjogICBVaW50OEFycmF5IC0ganBlZyBmaWxlXG4vLyAgLSBvbl9zZWdtZW50OiBGdW5jdGlvbiAtIGNhbGxiYWNrIGV4ZWN1dGVkIG9uIGVhY2ggSlBFRyBtYXJrZXIgc2VnbWVudFxuLy8gICAgLSBzZWdtZW50OiAgT2JqZWN0XG4vLyAgICAgIC0gY29kZTogICBOdW1iZXIgLSBtYXJrZXIgdHlwZSAoMm5kIGJ5dGUsIGUuZy4gMHhFMCBmb3IgQVBQMClcbi8vICAgICAgLSBvZmZzZXQ6IE51bWJlciAtIG9mZnNldCBvZiB0aGUgZmlyc3QgYnl0ZSAoMHhGRikgcmVsYXRpdmUgdG8gYGpwZWdfYmluYCBzdGFydFxuLy8gICAgICAtIGxlbmd0aDogTnVtYmVyIC0gbGVuZ3RoIG9mIHRoZSBlbnRpcmUgbWFya2VyIHNlZ21lbnQgaW5jbHVkaW5nIGZpcnN0IHR3byBieXRlcyBhbmQgbGVuZ3RoXG4vLyAgICAgICAgLSAyIGZvciBzdGFuZGFsb25lIG1hcmtlcnNcbi8vICAgICAgICAtIDQrbGVuZ3RoIGZvciBtYXJrZXJzIHdpdGggZGF0YVxuLy9cbi8vIEl0ZXJhdGlvbiBzdG9wcyB3aGVuIGBFT0lgICgweEZGRDkpIG1hcmtlciBpcyByZWFjaGVkIG9yIGlmIGBvbl9zZWdtZW50YFxuLy8gZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLlxuLy9cbm1vZHVsZS5leHBvcnRzLmpwZWdfc2VnbWVudHNfZWFjaCA9IGZ1bmN0aW9uIChqcGVnX2Jpbiwgb25fc2VnbWVudCkge1xuICBpZiAoIWlzX3VpbnQ4YXJyYXkoanBlZ19iaW4pKSB7XG4gICAgdGhyb3cgZXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgKGpwZWdfYmluKSwgVWludDhBcnJheSBleHBlY3RlZCcsICdFSU5WQUwnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb25fc2VnbWVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IGVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IChvbl9zZWdtZW50KSwgRnVuY3Rpb24gZXhwZWN0ZWQnLCAnRUlOVkFMJyk7XG4gIH1cblxuICBpZiAoIW1vZHVsZS5leHBvcnRzLmlzX2pwZWcoanBlZ19iaW4pKSB7XG4gICAgdGhyb3cgZXJyb3IoJ1Vua25vd24gZmlsZSBmb3JtYXQnLCAnRU5PVEpQRUcnKTtcbiAgfVxuXG4gIHZhciBvZmZzZXQgPSAwLCBsZW5ndGggPSBqcGVnX2Jpbi5sZW5ndGgsIGluc2lkZV9zY2FuID0gZmFsc2U7XG5cbiAgZm9yICg7Oykge1xuICAgIHZhciBzZWdtZW50X2NvZGUsIHNlZ21lbnRfbGVuZ3RoO1xuXG4gICAgaWYgKG9mZnNldCArIDEgPj0gbGVuZ3RoKSB0aHJvdyBlcnJvcignVW5leHBlY3RlZCBFT0YnLCAnRUJBRERBVEEnKTtcbiAgICB2YXIgYnl0ZTEgPSBqcGVnX2JpbltvZmZzZXRdO1xuICAgIHZhciBieXRlMiA9IGpwZWdfYmluW29mZnNldCArIDFdO1xuXG4gICAgaWYgKGJ5dGUxID09PSAweEZGICYmIGJ5dGUyID09PSAweEZGKSB7XG4gICAgICAvLyBwYWRkaW5nXG4gICAgICBzZWdtZW50X2NvZGUgPSAweEZGO1xuICAgICAgc2VnbWVudF9sZW5ndGggPSAxO1xuXG4gICAgfSBlbHNlIGlmIChieXRlMSA9PT0gMHhGRiAmJiBieXRlMiAhPT0gMCkge1xuICAgICAgLy8gbWFya2VyXG4gICAgICBzZWdtZW50X2NvZGUgPSBieXRlMjtcbiAgICAgIHNlZ21lbnRfbGVuZ3RoID0gMjtcblxuICAgICAgaWYgKCgweEQwIDw9IHNlZ21lbnRfY29kZSAmJiBzZWdtZW50X2NvZGUgPD0gMHhEOSkgfHwgc2VnbWVudF9jb2RlID09PSAweDAxKSA7IGVsc2Uge1xuICAgICAgICBpZiAob2Zmc2V0ICsgMyA+PSBsZW5ndGgpIHRocm93IGVycm9yKCdVbmV4cGVjdGVkIEVPRicsICdFQkFEREFUQScpO1xuICAgICAgICBzZWdtZW50X2xlbmd0aCArPSBqcGVnX2JpbltvZmZzZXQgKyAyXSAqIDB4MTAwICsganBlZ19iaW5bb2Zmc2V0ICsgM107XG4gICAgICAgIGlmIChzZWdtZW50X2xlbmd0aCA8IDIpIHRocm93IGVycm9yKCdJbnZhbGlkIHNlZ21lbnQgbGVuZ3RoJywgJ0VCQUREQVRBJyk7XG4gICAgICAgIGlmIChvZmZzZXQgKyBzZWdtZW50X2xlbmd0aCAtIDEgPj0gbGVuZ3RoKSB0aHJvdyBlcnJvcignVW5leHBlY3RlZCBFT0YnLCAnRUJBRERBVEEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluc2lkZV9zY2FuKSB7XG4gICAgICAgIGlmIChzZWdtZW50X2NvZGUgPj0gMHhEMCAmJiBzZWdtZW50X2NvZGUgPD0gMHhENykgOyBlbHNlIHtcbiAgICAgICAgICBpbnNpZGVfc2NhbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWdtZW50X2NvZGUgPT09IDB4REEgLyogU09TICovKSBpbnNpZGVfc2NhbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChpbnNpZGVfc2Nhbikge1xuICAgICAgLy8gZW50cm9weS1lbmNvZGVkIHNlZ21lbnRcbiAgICAgIGZvciAodmFyIHBvcyA9IG9mZnNldCArIDE7IDsgcG9zKyspIHtcbiAgICAgICAgLy8gc2NhbiB1bnRpbCB3ZSBmaW5kIEZGXG4gICAgICAgIGlmIChwb3MgPj0gbGVuZ3RoKSB0aHJvdyBlcnJvcignVW5leHBlY3RlZCBFT0YnLCAnRUJBRERBVEEnKTtcbiAgICAgICAgaWYgKGpwZWdfYmluW3Bvc10gPT09IDB4RkYpIHtcbiAgICAgICAgICBpZiAocG9zICsgMSA+PSBsZW5ndGgpIHRocm93IGVycm9yKCdVbmV4cGVjdGVkIEVPRicsICdFQkFEREFUQScpO1xuICAgICAgICAgIGlmIChqcGVnX2Jpbltwb3MgKyAxXSAhPT0gMCkge1xuICAgICAgICAgICAgc2VnbWVudF9jb2RlID0gMDtcbiAgICAgICAgICAgIHNlZ21lbnRfbGVuZ3RoID0gcG9zIC0gb2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yKCdVbmV4cGVjdGVkIGJ5dGUgYXQgc2VnbWVudCBzdGFydDogJyArIHRvX2hleChieXRlMSkgK1xuICAgICAgICAnIChvZmZzZXQgJyArIHRvX2hleChvZmZzZXQpICsgJyknLCAnRUJBRERBVEEnKTtcbiAgICB9XG5cbiAgICBpZiAob25fc2VnbWVudCh7IGNvZGU6IHNlZ21lbnRfY29kZSwgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogc2VnbWVudF9sZW5ndGggfSkgPT09IGZhbHNlKSBicmVhaztcbiAgICBpZiAoc2VnbWVudF9jb2RlID09PSAweEQ5IC8qIEVPSSAqLykgYnJlYWs7XG4gICAgb2Zmc2V0ICs9IHNlZ21lbnRfbGVuZ3RoO1xuICB9XG59O1xuXG5cbi8vIFJlcGxhY2Ugb3IgcmVtb3ZlIHNlZ21lbnRzIGluIHRoZSBnaXZlbiBKUEVHIGltYWdlXG4vL1xuLy8gSW5wdXQ6XG4vLyAgLSBqcGVnX2JpbjogICBVaW50OEFycmF5IC0ganBlZyBmaWxlXG4vLyAgLSBvbl9zZWdtZW50OiBGdW5jdGlvbiAtIGNhbGxiYWNrIGV4ZWN1dGVkIG9uIGVhY2ggSlBFRyBtYXJrZXIgc2VnbWVudFxuLy8gICAgLSBzZWdtZW50OiAgT2JqZWN0XG4vLyAgICAgIC0gY29kZTogICBOdW1iZXIgLSBtYXJrZXIgdHlwZSAoMm5kIGJ5dGUsIGUuZy4gMHhFMCBmb3IgQVBQMClcbi8vICAgICAgLSBvZmZzZXQ6IE51bWJlciAtIG9mZnNldCBvZiB0aGUgZmlyc3QgYnl0ZSAoMHhGRikgcmVsYXRpdmUgdG8gYGpwZWdfYmluYCBzdGFydFxuLy8gICAgICAtIGxlbmd0aDogTnVtYmVyIC0gbGVuZ3RoIG9mIHRoZSBlbnRpcmUgbWFya2VyIHNlZ21lbnQgaW5jbHVkaW5nIGZpcnN0IHR3byBieXRlcyBhbmQgbGVuZ3RoXG4vLyAgICAgICAgLSAyIGZvciBzdGFuZGFsb25lIG1hcmtlcnNcbi8vICAgICAgICAtIDQrbGVuZ3RoIGZvciBtYXJrZXJzIHdpdGggZGF0YVxuLy9cbi8vIGBvbl9zZWdtZW50YCBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuLy8gIC0gYGZhbHNlYCAgICAgICAgLSBzZWdtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgb3V0cHV0XG4vLyAgLSBVaW50OEFycmF5ICAgICAtIHNlZ21lbnQgaXMgcmVwbGFjZWQgd2l0aCB0aGUgbmV3IGRhdGFcbi8vICAtIFsgVWludDhBcnJheSBdIC0gc2VnbWVudCBpcyByZXBsYWNlZCB3aXRoIHRoZSBuZXcgZGF0YVxuLy8gIC0gYW55dGhpbmcgZWxzZSAgLSBzZWdtZW50IGlzIGNvcGllZCB0byB0aGUgb3V0cHV0IGFzIGlzXG4vL1xuLy8gQW55IGRhdGEgYWZ0ZXIgYEVPSWAgKDB4RkZEOSkgbWFya2VyIGlzIHJlbW92ZWQuXG4vL1xubW9kdWxlLmV4cG9ydHMuanBlZ19zZWdtZW50c19maWx0ZXIgPSBmdW5jdGlvbiAoanBlZ19iaW4sIG9uX3NlZ21lbnQpIHtcbiAgaWYgKCFpc191aW50OGFycmF5KGpwZWdfYmluKSkge1xuICAgIHRocm93IGVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IChqcGVnX2JpbiksIFVpbnQ4QXJyYXkgZXhwZWN0ZWQnLCAnRUlOVkFMJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9uX3NlZ21lbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBlcnJvcignSW52YWxpZCBhcmd1bWVudCAob25fc2VnbWVudCksIEZ1bmN0aW9uIGV4cGVjdGVkJywgJ0VJTlZBTCcpO1xuICB9XG5cbiAgdmFyIHJhbmdlcyA9IFtdO1xuICB2YXIgb3V0X2xlbmd0aCA9IDA7XG5cbiAgbW9kdWxlLmV4cG9ydHMuanBlZ19zZWdtZW50c19lYWNoKGpwZWdfYmluLCBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgIHZhciBuZXdfc2VnbWVudCA9IG9uX3NlZ21lbnQoc2VnbWVudCk7XG5cbiAgICBpZiAoaXNfdWludDhhcnJheShuZXdfc2VnbWVudCkpIHtcbiAgICAgIHJhbmdlcy5wdXNoKHsgZGF0YTogbmV3X3NlZ21lbnQgfSk7XG4gICAgICBvdXRfbGVuZ3RoICs9IG5ld19zZWdtZW50Lmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobmV3X3NlZ21lbnQpKSB7XG4gICAgICBuZXdfc2VnbWVudC5maWx0ZXIoaXNfdWludDhhcnJheSkuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICByYW5nZXMucHVzaCh7IGRhdGE6IHMgfSk7XG4gICAgICAgIG91dF9sZW5ndGggKz0gcy5sZW5ndGg7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5ld19zZWdtZW50ICE9PSBmYWxzZSkge1xuICAgICAgdmFyIG5ld19yYW5nZSA9IHsgc3RhcnQ6IHNlZ21lbnQub2Zmc2V0LCBlbmQ6IHNlZ21lbnQub2Zmc2V0ICsgc2VnbWVudC5sZW5ndGggfTtcblxuICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPiAwICYmIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0uZW5kID09PSBuZXdfcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS5lbmQgPSBuZXdfcmFuZ2UuZW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2VzLnB1c2gobmV3X3JhbmdlKTtcbiAgICAgIH1cblxuICAgICAgb3V0X2xlbmd0aCArPSBzZWdtZW50Lmxlbmd0aDtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShvdXRfbGVuZ3RoKTtcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgcmFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgdmFyIGRhdGEgPSByYW5nZS5kYXRhIHx8IGpwZWdfYmluLnN1YmFycmF5KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xuICAgIHJlc3VsdC5zZXQoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gZGF0YS5sZW5ndGg7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIENhbGwgYW4gaXRlcmF0b3Igb24gZWFjaCBFeGlmIGVudHJ5IGluIHRoZSBnaXZlbiBKUEVHIGltYWdlXG4vL1xuLy8gSW5wdXQ6XG4vLyAgLSBqcGVnX2JpbjogVWludDhBcnJheSAtIGpwZWcgZmlsZVxuLy8gIC0gb25fZW50cnk6IEZ1bmN0aW9uIC0gY2FsbGJhY2sgZXhlY3V0ZWQgb24gZWFjaCBFeGlmIGVudHJ5XG4vLyAgICAtIGVudHJ5OiAgT2JqZWN0XG4vLyAgICAgIC0gaXNfYmlnX2VuZGlhbjogIEJvb2xlYW4gLSB3aGV0aGVyIEV4aWYgdXNlcyBiaWcgb3IgbGl0dGxlIGVuZGlhbiBieXRlIGFsaWdubWVudFxuLy8gICAgICAtIGlmZDogICAgICAgICAgICBOdW1iZXIgIC0gSUZEIGlkZW50aWZpZXIgKDAgZm9yIElGRDAsIDEgZm9yIElGRDEsIDB4ODc2OSBmb3IgU3ViSUZELFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDg4MjUgZm9yIEdQUyBJbmZvLCAweEEwMDUgZm9yIEludGVyb3AgSUZEKVxuLy8gICAgICAtIHRhZzogICAgICAgICAgICBOdW1iZXIgIC0gZXhpZiBlbnRyeSB0YWcgKDB4MDExMCAtIGNhbWVyYSBuYW1lLCAweDAxMTIgLSBvcmllbnRhdGlvbiwgZXRjLiAtIHNlZSBFeGlmIHNwZWMpXG4vLyAgICAgIC0gZm9ybWF0OiAgICAgICAgIE51bWJlciAgLSBleGlmIGVudHJ5IGZvcm1hdCAoMSAtIGJ5dGUsIDIgLSBhc2NpaSwgMyAtIHNob3J0LCBldGMuIC0gc2VlIEV4aWYgc3BlYylcbi8vICAgICAgLSBjb3VudDogICAgICAgICAgTnVtYmVyICAtIG51bWJlciBvZiBjb21wb25lbnRzIG9mIHRoZSBnaXZlbiBmb3JtYXQgaW5zaWRlIGRhdGFcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHVzdWFsbHkgMSwgb3Igc3RyaW5nIGxlbmd0aCBmb3IgYXNjaWkgZm9ybWF0KVxuLy8gICAgICAtIGVudHJ5X29mZnNldDogICBOdW1iZXIgIC0gc3RhcnQgb2YgRXhpZiBlbnRyeSAoZW50cnkgbGVuZ3RoIGlzIGFsd2F5cyAxMiwgc28gbm90IGluY2x1ZGVkKVxuLy8gICAgICAtIGRhdGFfb2Zmc2V0OiAgICBOdW1iZXIgIC0gc3RhcnQgb2YgZGF0YSBhdHRhY2hlZCB0byBFeGlmIGVudHJ5ICh3aWxsIG92ZXJsYXAgd2l0aCBlbnRyeSBpZiBsZW5ndGggPD0gNClcbi8vICAgICAgLSBkYXRhX2xlbmd0aDogICAgTnVtYmVyICAtIGxlbmd0aCBvZiBkYXRhIGF0dGFjaGVkIHRvIEV4aWYgZW50cnlcbi8vICAgICAgLSB2YWx1ZTogICAgICAgICAgQXJyYXl8U3RyaW5nfE51bGwgLSBvdXIgYmVzdCBhdHRlbXB0IGF0IHBhcnNpbmcgZGF0YSAobm90IGFsbCBmb3JtYXRzIHN1cHBvcnRlZCByaWdodCBub3cpXG4vLyAgICAgIC0gaXNfc3ViaWZkX2xpbms6IEJvb2xlYW4gLSB3aGV0aGVyIHRoaXMgZW50cnkgaXMgcmVjb2duaXplZCB0byBiZSBhIGxpbmsgdG8gc3ViaWZkIChjYW4ndCBmaWx0ZXIgdGhlc2Ugb3V0KVxuLy9cbi8vIEl0ZXJhdGlvbiBzdG9wcyBlYXJseSBpZiBpdGVyYXRvciByZXR1cm5zIGBmYWxzZWAuXG4vL1xuLy8gSWYgRXhpZiB3YXNuJ3QgZm91bmQgYW55d2hlcmUgKGJlZm9yZSBzdGFydCBvZiB0aGUgaW1hZ2UgZGF0YSwgU09TKSxcbi8vIGl0ZXJhdG9yIGlzIG5ldmVyIGV4ZWN1dGVkLlxuLy9cbm1vZHVsZS5leHBvcnRzLmpwZWdfZXhpZl90YWdzX2VhY2ggPSBmdW5jdGlvbiAoanBlZ19iaW4sIG9uX2V4aWZfZW50cnkpIHtcbiAgaWYgKCFpc191aW50OGFycmF5KGpwZWdfYmluKSkge1xuICAgIHRocm93IGVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IChqcGVnX2JpbiksIFVpbnQ4QXJyYXkgZXhwZWN0ZWQnLCAnRUlOVkFMJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9uX2V4aWZfZW50cnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBlcnJvcignSW52YWxpZCBhcmd1bWVudCAob25fZXhpZl9lbnRyeSksIEZ1bmN0aW9uIGV4cGVjdGVkJywgJ0VJTlZBTCcpO1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbiAgbW9kdWxlLmV4cG9ydHMuanBlZ19zZWdtZW50c19lYWNoKGpwZWdfYmluLCBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgIGlmIChzZWdtZW50LmNvZGUgPT09IDB4REEgLyogU09TICovKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBsb29rIGZvciBBUFAxIHNlZ21lbnQgYW5kIGNvbXBhcmUgaGVhZGVyIHdpdGggJ0V4aWZcXDBcXDAnXG4gICAgaWYgKHNlZ21lbnQuY29kZSA9PT0gMHhFMSAmJiBzZWdtZW50Lmxlbmd0aCA+PSAxMCAmJlxuICAgICAgICBqcGVnX2JpbltzZWdtZW50Lm9mZnNldCArIDRdID09PSAweDQ1ICYmIGpwZWdfYmluW3NlZ21lbnQub2Zmc2V0ICsgNV0gPT09IDB4NzggJiZcbiAgICAgICAganBlZ19iaW5bc2VnbWVudC5vZmZzZXQgKyA2XSA9PT0gMHg2OSAmJiBqcGVnX2JpbltzZWdtZW50Lm9mZnNldCArIDddID09PSAweDY2ICYmXG4gICAgICAgIGpwZWdfYmluW3NlZ21lbnQub2Zmc2V0ICsgOF0gPT09IDB4MDAgJiYganBlZ19iaW5bc2VnbWVudC5vZmZzZXQgKyA5XSA9PT0gMHgwMCkge1xuXG4gICAgICBuZXcgRXhpZlBhcnNlcihqcGVnX2Jpbiwgc2VnbWVudC5vZmZzZXQgKyAxMCwgc2VnbWVudC5vZmZzZXQgKyBzZWdtZW50Lmxlbmd0aCkuZWFjaChvbl9leGlmX2VudHJ5KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG4vLyBSZW1vdmUgRXhpZiBlbnRyaWVzIGluIHRoZSBnaXZlbiBKUEVHIGltYWdlXG4vL1xuLy8gSW5wdXQ6XG4vLyAgLSBqcGVnX2JpbjogVWludDhBcnJheSAtIGpwZWcgZmlsZVxuLy8gIC0gb25fZW50cnk6IEZ1bmN0aW9uIC0gY2FsbGJhY2sgZXhlY3V0ZWQgb24gZWFjaCBFeGlmIGVudHJ5XG4vLyAgICAtIGVudHJ5OiAgT2JqZWN0XG4vLyAgICAgIC0gaXNfYmlnX2VuZGlhbjogIEJvb2xlYW4gLSB3aGV0aGVyIEV4aWYgdXNlcyBiaWcgb3IgbGl0dGxlIGVuZGlhbiBieXRlIGFsaWdubWVudFxuLy8gICAgICAtIGlmZDogICAgICAgICAgICBOdW1iZXIgIC0gSUZEIGlkZW50aWZpZXIgKDAgZm9yIElGRDAsIDEgZm9yIElGRDEsIDB4ODc2OSBmb3IgU3ViSUZELFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4ODI1IGZvciBHUFMgSW5mbywgMHhBMDA1IGZvciBJbnRlcm9wIElGRClcbi8vICAgICAgLSB0YWc6ICAgICAgICAgICAgTnVtYmVyICAtIGV4aWYgZW50cnkgdGFnICgweDAxMTAgLSBjYW1lcmEgbmFtZSwgMHgwMTEyIC0gb3JpZW50YXRpb24sIGV0Yy4gLSBzZWUgRXhpZiBzcGVjKVxuLy8gICAgICAtIGZvcm1hdDogICAgICAgICBOdW1iZXIgIC0gZXhpZiBlbnRyeSBmb3JtYXQgKDEgLSBieXRlLCAyIC0gYXNjaWksIDMgLSBzaG9ydCwgZXRjLiAtIHNlZSBFeGlmIHNwZWMpXG4vLyAgICAgIC0gY291bnQ6ICAgICAgICAgIE51bWJlciAgLSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiB0aGUgZ2l2ZW4gZm9ybWF0IGluc2lkZSBkYXRhXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodXN1YWxseSAxLCBvciBzdHJpbmcgbGVuZ3RoIGZvciBhc2NpaSBmb3JtYXQpXG4vLyAgICAgIC0gZW50cnlfb2Zmc2V0OiAgIE51bWJlciAgLSBzdGFydCBvZiBFeGlmIGVudHJ5IChlbnRyeSBsZW5ndGggaXMgYWx3YXlzIDEyLCBzbyBub3QgaW5jbHVkZWQpXG4vLyAgICAgIC0gZGF0YV9vZmZzZXQ6ICAgIE51bWJlciAgLSBzdGFydCBvZiBkYXRhIGF0dGFjaGVkIHRvIEV4aWYgZW50cnkgKHdpbGwgb3ZlcmxhcCB3aXRoIGVudHJ5IGlmIGxlbmd0aCA8PSA0KVxuLy8gICAgICAtIGRhdGFfbGVuZ3RoOiAgICBOdW1iZXIgIC0gbGVuZ3RoIG9mIGRhdGEgYXR0YWNoZWQgdG8gRXhpZiBlbnRyeVxuLy8gICAgICAtIHZhbHVlOiAgICAgICAgICBBcnJheXxTdHJpbmd8TnVsbCAtIG91ciBiZXN0IGF0dGVtcHQgYXQgcGFyc2luZyBkYXRhIChub3QgYWxsIGZvcm1hdHMgc3VwcG9ydGVkIHJpZ2h0IG5vdylcbi8vICAgICAgLSBpc19zdWJpZmRfbGluazogQm9vbGVhbiAtIHdoZXRoZXIgdGhpcyBlbnRyeSBpcyByZWNvZ25pemVkIHRvIGJlIGEgbGluayB0byBzdWJpZmQgKGNhbid0IGZpbHRlciB0aGVzZSBvdXQpXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiByZW1vdmVzIGZvbGxvd2luZyBmcm9tIEV4aWY6XG4vLyAgLSBhbGwgZW50cmllcyB3aGVyZSBpdGVyYXRvciByZXR1cm5lZCBmYWxzZSAoZXhjZXB0IHN1YmlmZCBsaW5rcyB3aGljaCBhcmUgbWFuZGF0b3J5KVxuLy8gIC0gSUZEMSBhbmQgdGh1bWJuYWlsIGltYWdlICh0aGUgcHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIHJlZHVjZSBmaWxlIHNpemUsXG4vLyAgICBzbyB0aHVtYm5haWwgaXMgdXN1YWxseSB0aGUgZmlyc3QgdGhpbmcgdG8gZ28pXG4vLyAgLSBhbGwgb3RoZXIgZGF0YSB0aGF0IGlzbid0IGluIElGRDAsIFN1YklGRCwgR1BTSUZELCBJbnRlcm9wSUZEXG4vLyAgICAodGhlb3JldGljYWxseSBwb3NzaWJsZSBwcm9wcmlldGFyeSBleHRlbnNpb25zLCBJIGhhdmVuJ3Qgc2VlbiBhbnkgb2YgdGhlc2UgeWV0KVxuLy9cbi8vIENoYW5naW5nIGRhdGEgaW5zaWRlIEV4aWYgZW50cmllcyBpcyBOT1Qgc3VwcG9ydGVkIHlldCAobW9kaWZ5aW5nIGBlbnRyeWAgb2JqZWN0IGluc2lkZSBjYWxsYmFjayBtYXkgYnJlYWsgc3R1ZmYpLlxuLy9cbi8vIElmIEV4aWYgd2Fzbid0IGZvdW5kIGFueXdoZXJlIChiZWZvcmUgc3RhcnQgb2YgdGhlIGltYWdlIGRhdGEsIFNPUyksXG4vLyBpdGVyYXRvciBpcyBuZXZlciBleGVjdXRlZCwgYW5kIG9yaWdpbmFsIEpQRUcgaXMgcmV0dXJuZWQgYXMgaXMuXG4vL1xubW9kdWxlLmV4cG9ydHMuanBlZ19leGlmX3RhZ3NfZmlsdGVyID0gZnVuY3Rpb24gKGpwZWdfYmluLCBvbl9leGlmX2VudHJ5KSB7XG4gIGlmICghaXNfdWludDhhcnJheShqcGVnX2JpbikpIHtcbiAgICB0aHJvdyBlcnJvcignSW52YWxpZCBhcmd1bWVudCAoanBlZ19iaW4pLCBVaW50OEFycmF5IGV4cGVjdGVkJywgJ0VJTlZBTCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvbl9leGlmX2VudHJ5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgZXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgKG9uX2V4aWZfZW50cnkpLCBGdW5jdGlvbiBleHBlY3RlZCcsICdFSU5WQUwnKTtcbiAgfVxuXG4gIHZhciBzdG9wX3NlYXJjaCA9IGZhbHNlO1xuXG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cy5qcGVnX3NlZ21lbnRzX2ZpbHRlcihqcGVnX2JpbiwgZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICBpZiAoc3RvcF9zZWFyY2gpIHJldHVybjtcbiAgICBpZiAoc2VnbWVudC5jb2RlID09PSAweERBIC8qIFNPUyAqLykgc3RvcF9zZWFyY2ggPSB0cnVlO1xuXG4gICAgLy8gbG9vayBmb3IgQVBQMSBzZWdtZW50IGFuZCBjb21wYXJlIGhlYWRlciB3aXRoICdFeGlmXFwwXFwwJ1xuICAgIGlmIChzZWdtZW50LmNvZGUgPT09IDB4RTEgJiYgc2VnbWVudC5sZW5ndGggPj0gMTAgJiZcbiAgICAgICAganBlZ19iaW5bc2VnbWVudC5vZmZzZXQgKyA0XSA9PT0gMHg0NSAmJiBqcGVnX2JpbltzZWdtZW50Lm9mZnNldCArIDVdID09PSAweDc4ICYmXG4gICAgICAgIGpwZWdfYmluW3NlZ21lbnQub2Zmc2V0ICsgNl0gPT09IDB4NjkgJiYganBlZ19iaW5bc2VnbWVudC5vZmZzZXQgKyA3XSA9PT0gMHg2NiAmJlxuICAgICAgICBqcGVnX2JpbltzZWdtZW50Lm9mZnNldCArIDhdID09PSAweDAwICYmIGpwZWdfYmluW3NlZ21lbnQub2Zmc2V0ICsgOV0gPT09IDB4MDApIHtcblxuICAgICAgdmFyIG5ld19leGlmID0gbmV3IEV4aWZQYXJzZXIoanBlZ19iaW4sIHNlZ21lbnQub2Zmc2V0ICsgMTAsIHNlZ21lbnQub2Zmc2V0ICsgc2VnbWVudC5sZW5ndGgpXG4gICAgICAgIC5maWx0ZXIob25fZXhpZl9lbnRyeSk7XG4gICAgICBpZiAoIW5ld19leGlmKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHZhciBoZWFkZXIgPSBuZXcgVWludDhBcnJheSgxMCk7XG5cbiAgICAgIGhlYWRlci5zZXQoanBlZ19iaW4uc2xpY2Uoc2VnbWVudC5vZmZzZXQsIHNlZ21lbnQub2Zmc2V0ICsgMTApKTtcbiAgICAgIGhlYWRlclsyXSA9ICgobmV3X2V4aWYubGVuZ3RoICsgOCkgPj4+IDgpICYgMHhGRjtcbiAgICAgIGhlYWRlclszXSA9IChuZXdfZXhpZi5sZW5ndGggKyA4KSAmIDB4RkY7XG5cbiAgICAgIHN0b3Bfc2VhcmNoID0gdHJ1ZTtcbiAgICAgIHJldHVybiBbIGhlYWRlciwgbmV3X2V4aWYgXTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG4vLyBJbnNlcnRzIGEgY3VzdG9tIGNvbW1lbnQgbWFya2VyIHNlZ21lbnQgaW50byBKUEVHIGZpbGUuXG4vL1xuLy8gSW5wdXQ6XG4vLyAgLSBqcGVnX2JpbjogVWludDhBcnJheSAtIGpwZWcgZmlsZVxuLy8gIC0gY29tbWVudDogIFN0cmluZ1xuLy9cbi8vIENvbW1lbnQgaXMgaW5zZXJ0ZWQgYWZ0ZXIgZmlyc3QgdHdvIGJ5dGVzIChGRkQ4LCBTT0kpLlxuLy9cbi8vIElmIEpGSUYgKEFQUDApIG1hcmtlciBleGlzdHMgaW1tZWRpYXRlbHkgYWZ0ZXIgU09JIChhcyBtYW5kYXRlZCBieSB0aGUgSkZJRlxuLy8gc3BlYyksIHdlIGluc2VydCBjb21tZW50IGFmdGVyIGl0IGluc3RlYWQuXG4vL1xubW9kdWxlLmV4cG9ydHMuanBlZ19hZGRfY29tbWVudCA9IGZ1bmN0aW9uIChqcGVnX2JpbiwgY29tbWVudCkge1xuICB2YXIgY29tbWVudF9pbnNlcnRlZCA9IGZhbHNlLCBzZWdtZW50X2NvdW50ID0gMDtcblxuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMuanBlZ19zZWdtZW50c19maWx0ZXIoanBlZ19iaW4sIGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgc2VnbWVudF9jb3VudCsrO1xuICAgIGlmIChzZWdtZW50X2NvdW50ID09PSAxICYmIHNlZ21lbnQuY29kZSA9PT0gMHhEOCAvKiBTT0kgICovKSByZXR1cm47XG4gICAgaWYgKHNlZ21lbnRfY291bnQgPT09IDIgJiYgc2VnbWVudC5jb2RlID09PSAweEUwIC8qIEFQUDAgKi8pIHJldHVybjtcblxuICAgIGlmIChjb21tZW50X2luc2VydGVkKSByZXR1cm47XG4gICAgY29tbWVudCA9IHV0ZjhfZW5jb2RlKGNvbW1lbnQpO1xuXG4gICAgLy8gY29tbWVudCBzZWdtZW50XG4gICAgdmFyIGNzZWdtZW50ID0gbmV3IFVpbnQ4QXJyYXkoNSArIGNvbW1lbnQubGVuZ3RoKTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGNzZWdtZW50W29mZnNldCsrXSA9IDB4RkY7XG4gICAgY3NlZ21lbnRbb2Zmc2V0KytdID0gMHhGRTtcbiAgICBjc2VnbWVudFtvZmZzZXQrK10gPSAoKGNvbW1lbnQubGVuZ3RoICsgMykgPj4+IDgpICYgMHhGRjtcbiAgICBjc2VnbWVudFtvZmZzZXQrK10gPSAoY29tbWVudC5sZW5ndGggKyAzKSAmIDB4RkY7XG5cbiAgICBjb21tZW50LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBjc2VnbWVudFtvZmZzZXQrK10gPSBjLmNoYXJDb2RlQXQoMCkgJiAweEZGO1xuICAgIH0pO1xuXG4gICAgY3NlZ21lbnRbb2Zmc2V0KytdID0gMDtcbiAgICBjb21tZW50X2luc2VydGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBbIGNzZWdtZW50LCBqcGVnX2Jpbi5zdWJhcnJheShzZWdtZW50Lm9mZnNldCwgc2VnbWVudC5vZmZzZXQgKyBzZWdtZW50Lmxlbmd0aCkgXTtcbiAgfSk7XG59O1xufSk7XG5cbmZ1bmN0aW9uIGpwZWdfcGF0Y2hfZXhpZihlbnYpIHtcbiAgcmV0dXJuIHRoaXMuX2dldFVpbnQ4QXJyYXkoZW52LmJsb2IpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBlbnYuaXNfanBlZyA9IGltYWdlX3RyYXZlcnNlLmlzX2pwZWcoZGF0YSk7XG5cbiAgICBpZiAoIWVudi5pc19qcGVnKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVudik7XG5cbiAgICBlbnYub3JpZ19ibG9iID0gZW52LmJsb2I7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGV4aWZfaXNfYmlnX2VuZGlhbiwgb3JpZW50YXRpb25fb2Zmc2V0O1xuXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBjb25zaXN0ZW50LXJldHVybiAqL1xuICAgICAgaW1hZ2VfdHJhdmVyc2UuanBlZ19leGlmX3RhZ3NfZWFjaChkYXRhLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5LmlmZCA9PT0gMCAmJiBlbnRyeS50YWcgPT09IDB4MTEyICYmIEFycmF5LmlzQXJyYXkoZW50cnkudmFsdWUpKSB7XG4gICAgICAgICAgZW52Lm9yaWVudGF0aW9uICAgID0gZW50cnkudmFsdWVbMF0gfHwgMTtcbiAgICAgICAgICBleGlmX2lzX2JpZ19lbmRpYW4gPSBlbnRyeS5pc19iaWdfZW5kaWFuO1xuICAgICAgICAgIG9yaWVudGF0aW9uX29mZnNldCA9IGVudHJ5LmRhdGFfb2Zmc2V0O1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChvcmllbnRhdGlvbl9vZmZzZXQpIHtcbiAgICAgICAgdmFyIG9yaWVudGF0aW9uX3BhdGNoID0gZXhpZl9pc19iaWdfZW5kaWFuID9cbiAgICAgICAgICBuZXcgVWludDhBcnJheShbIDAsIDEgXSkgOlxuICAgICAgICAgIG5ldyBVaW50OEFycmF5KFsgMSwgMCBdKTtcblxuICAgICAgICBlbnYuYmxvYiA9IG5ldyBCbG9iKFtcbiAgICAgICAgICBkYXRhLnNsaWNlKDAsIG9yaWVudGF0aW9uX29mZnNldCksXG4gICAgICAgICAgb3JpZW50YXRpb25fcGF0Y2gsXG4gICAgICAgICAgZGF0YS5zbGljZShvcmllbnRhdGlvbl9vZmZzZXQgKyAyKVxuICAgICAgICBdLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfKSB7fVxuXG4gICAgcmV0dXJuIGVudjtcbiAgfSk7XG59XG5cblxuZnVuY3Rpb24ganBlZ19yb3RhdGVfY2FudmFzKGVudikge1xuICBpZiAoIWVudi5pc19qcGVnKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVudik7XG5cbiAgdmFyIG9yaWVudGF0aW9uID0gZW52Lm9yaWVudGF0aW9uIC0gMTtcbiAgaWYgKCFvcmllbnRhdGlvbikgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlbnYpO1xuXG4gIHZhciBjYW52YXM7XG5cbiAgaWYgKG9yaWVudGF0aW9uICYgNCkge1xuICAgIGNhbnZhcyA9IHRoaXMucGljYS5vcHRpb25zLmNyZWF0ZUNhbnZhcyhlbnYub3V0X2NhbnZhcy5oZWlnaHQsIGVudi5vdXRfY2FudmFzLndpZHRoKTtcbiAgfSBlbHNlIHtcbiAgICBjYW52YXMgPSB0aGlzLnBpY2Eub3B0aW9ucy5jcmVhdGVDYW52YXMoZW52Lm91dF9jYW52YXMud2lkdGgsIGVudi5vdXRfY2FudmFzLmhlaWdodCk7XG4gIH1cblxuICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgY3R4LnNhdmUoKTtcblxuICBpZiAob3JpZW50YXRpb24gJiAxKSBjdHgudHJhbnNmb3JtKC0xLCAwLCAwLCAxLCBjYW52YXMud2lkdGgsIDApO1xuICBpZiAob3JpZW50YXRpb24gJiAyKSBjdHgudHJhbnNmb3JtKC0xLCAwLCAwLCAtMSwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgaWYgKG9yaWVudGF0aW9uICYgNCkgY3R4LnRyYW5zZm9ybSgwLCAxLCAxLCAwLCAwLCAwKTtcblxuICBjdHguZHJhd0ltYWdlKGVudi5vdXRfY2FudmFzLCAwLCAwKTtcbiAgY3R4LnJlc3RvcmUoKTtcblxuICAvLyBTYWZhcmkgMTIgd29ya2Fyb3VuZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3BpY2EvaXNzdWVzLzE5OVxuICBlbnYub3V0X2NhbnZhcy53aWR0aCA9IGVudi5vdXRfY2FudmFzLmhlaWdodCA9IDA7XG5cbiAgZW52Lm91dF9jYW52YXMgPSBjYW52YXM7XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlbnYpO1xufVxuXG5cbmZ1bmN0aW9uIGpwZWdfYXR0YWNoX29yaWdfc2VnbWVudHMoZW52KSB7XG4gIGlmICghZW52LmlzX2pwZWcpIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW52KTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIHRoaXMuX2dldFVpbnQ4QXJyYXkoZW52LmJsb2IpLFxuICAgIHRoaXMuX2dldFVpbnQ4QXJyYXkoZW52Lm91dF9ibG9iKVxuICBdKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICB2YXIgZGF0YSA9IHJlc1swXTtcbiAgICB2YXIgZGF0YV9vdXQgPSByZXNbMV07XG5cbiAgICBpZiAoIWltYWdlX3RyYXZlcnNlLmlzX2pwZWcoZGF0YSkpIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW52KTtcblxuICAgIHZhciBzZWdtZW50cyA9IFtdO1xuXG4gICAgaW1hZ2VfdHJhdmVyc2UuanBlZ19zZWdtZW50c19lYWNoKGRhdGEsIGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICBpZiAoc2VnbWVudC5jb2RlID09PSAweERBIC8qIFNPUyAqLykgcmV0dXJuIGZhbHNlO1xuICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICB9KTtcblxuICAgIHNlZ21lbnRzID0gc2VnbWVudHNcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgLy8gRHJvcCBJQ0NfUFJPRklMRVxuICAgICAgICAvL1xuICAgICAgICBpZiAoc2VnbWVudC5jb2RlID09PSAweEUyKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLy8gS2VlcCBhbGwgQVBQbiBzZWdtZW50cyBleGNsdWRpbmcgQVBQMiAoSUNDX1BST0ZJTEUpLFxuICAgICAgICAvLyByZW1vdmUgb3RoZXJzIGJlY2F1c2UgbW9zdCBvZiB0aGVtIGRlcGVuZCBvbiBpbWFnZSBkYXRhIChEQ1QgYW5kIHN1Y2gpLlxuICAgICAgICAvL1xuICAgICAgICAvLyBBUFAwIC0gSkZJRiwgQVBQMSAtIEV4aWYsIHRoZSByZXN0IGFyZSBwaG90b3Nob3AgbWV0YWRhdGEgYW5kIHN1Y2hcbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2VlIGZ1bGwgbGlzdCBhdCBodHRwczovL3d3dy53My5vcmcvR3JhcGhpY3MvSlBFRy9pdHUtdDgxLnBkZiAodGFibGUgQi4xIG9uIHBhZ2UgMzIpXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChzZWdtZW50LmNvZGUgPj0gMHhFMCAmJiBzZWdtZW50LmNvZGUgPCAweEYwKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyBLZWVwIGNvbW1lbnRzXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChzZWdtZW50LmNvZGUgPT09IDB4RkUpIHJldHVybiB0cnVlO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pXG4gICAgICAubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBkYXRhLnNsaWNlKHNlZ21lbnQub2Zmc2V0LCBzZWdtZW50Lm9mZnNldCArIHNlZ21lbnQubGVuZ3RoKTtcbiAgICAgIH0pO1xuXG4gICAgZW52Lm91dF9ibG9iID0gbmV3IEJsb2IoXG4gICAgICAvLyBpbnRlbnRpb25hbGx5IG9taXR0aW5nIGV4cGVjdGVkIEpGSUYgc2VnbWVudCAob2Zmc2V0IDIgdG8gMjApXG4gICAgICBbIGRhdGFfb3V0LnNsaWNlKDAsIDIpIF0uY29uY2F0KHNlZ21lbnRzKS5jb25jYXQoWyBkYXRhX291dC5zbGljZSgyMCkgXSksXG4gICAgICB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9XG4gICAgKTtcblxuICAgIHJldHVybiBlbnY7XG4gIH0pO1xufVxuXG5cbmZ1bmN0aW9uIGFzc2lnbihyZWR1Y2VyKSB7XG4gIHJlZHVjZXIuYmVmb3JlKCdfYmxvYl90b19pbWFnZScsIGpwZWdfcGF0Y2hfZXhpZik7XG4gIHJlZHVjZXIuYWZ0ZXIoJ190cmFuc2Zvcm0nLCAgICAgIGpwZWdfcm90YXRlX2NhbnZhcyk7XG4gIHJlZHVjZXIuYWZ0ZXIoJ19jcmVhdGVfYmxvYicsICAgIGpwZWdfYXR0YWNoX29yaWdfc2VnbWVudHMpO1xufVxuXG5cbnZhciBqcGVnX3BhdGNoX2V4aWZfMSA9IGpwZWdfcGF0Y2hfZXhpZjtcbnZhciBqcGVnX3JvdGF0ZV9jYW52YXNfMSA9IGpwZWdfcm90YXRlX2NhbnZhcztcbnZhciBqcGVnX2F0dGFjaF9vcmlnX3NlZ21lbnRzXzEgPSBqcGVnX2F0dGFjaF9vcmlnX3NlZ21lbnRzO1xudmFyIGFzc2lnbl8xID0gYXNzaWduO1xuXG52YXIganBlZ19wbHVnaW5zID0ge1xuXHRqcGVnX3BhdGNoX2V4aWY6IGpwZWdfcGF0Y2hfZXhpZl8xLFxuXHRqcGVnX3JvdGF0ZV9jYW52YXM6IGpwZWdfcm90YXRlX2NhbnZhc18xLFxuXHRqcGVnX2F0dGFjaF9vcmlnX3NlZ21lbnRzOiBqcGVnX2F0dGFjaF9vcmlnX3NlZ21lbnRzXzEsXG5cdGFzc2lnbjogYXNzaWduXzFcbn07XG5cbmZ1bmN0aW9uIEltYWdlQmxvYlJlZHVjZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbWFnZUJsb2JSZWR1Y2UpKSByZXR1cm4gbmV3IEltYWdlQmxvYlJlZHVjZShvcHRpb25zKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLnBpY2EgPSBvcHRpb25zLnBpY2EgfHwgcGljYSh7fSk7XG4gIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICB0aGlzLnV0aWxzID0gdXRpbHM7XG59XG5cblxuSW1hZ2VCbG9iUmVkdWNlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luIC8qLCBwYXJhbXMsIC4uLiAqLykge1xuICB2YXIgYXJncyA9IFsgdGhpcyBdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgcGx1Z2luLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5JbWFnZUJsb2JSZWR1Y2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudXNlKGpwZWdfcGx1Z2lucy5hc3NpZ24pO1xufTtcblxuXG5JbWFnZUJsb2JSZWR1Y2UucHJvdG90eXBlLnRvQmxvYiA9IGZ1bmN0aW9uIChibG9iLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdXRpbHMuYXNzaWduKHsgbWF4OiBJbmZpbml0eSB9LCBvcHRpb25zKTtcbiAgdmFyIGVudiA9IHtcbiAgICBibG9iOiBibG9iLFxuICAgIG9wdHM6IG9wdHNcbiAgfTtcblxuICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW52KVxuICAgIC50aGVuKHRoaXMuX2Jsb2JfdG9faW1hZ2UpXG4gICAgLnRoZW4odGhpcy5fY2FsY3VsYXRlX3NpemUpXG4gICAgLnRoZW4odGhpcy5fdHJhbnNmb3JtKVxuICAgIC50aGVuKHRoaXMuX2NsZWFudXApXG4gICAgLnRoZW4odGhpcy5fY3JlYXRlX2Jsb2IpXG4gICAgLnRoZW4oZnVuY3Rpb24gKF9lbnYpIHtcbiAgICAgIC8vIFNhZmFyaSAxMiB3b3JrYXJvdW5kXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3BpY2EvaXNzdWVzLzE5OVxuICAgICAgX2Vudi5vdXRfY2FudmFzLndpZHRoID0gX2Vudi5vdXRfY2FudmFzLmhlaWdodCA9IDA7XG5cbiAgICAgIHJldHVybiBfZW52Lm91dF9ibG9iO1xuICAgIH0pO1xufTtcblxuXG5JbWFnZUJsb2JSZWR1Y2UucHJvdG90eXBlLnRvQ2FudmFzID0gZnVuY3Rpb24gKGJsb2IsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB1dGlscy5hc3NpZ24oeyBtYXg6IEluZmluaXR5IH0sIG9wdGlvbnMpO1xuICB2YXIgZW52ID0ge1xuICAgIGJsb2I6IGJsb2IsXG4gICAgb3B0czogb3B0c1xuICB9O1xuXG4gIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlbnYpXG4gICAgLnRoZW4odGhpcy5fYmxvYl90b19pbWFnZSlcbiAgICAudGhlbih0aGlzLl9jYWxjdWxhdGVfc2l6ZSlcbiAgICAudGhlbih0aGlzLl90cmFuc2Zvcm0pXG4gICAgLnRoZW4odGhpcy5fY2xlYW51cClcbiAgICAudGhlbihmdW5jdGlvbiAoX2VudikgeyByZXR1cm4gX2Vudi5vdXRfY2FudmFzOyB9KTtcbn07XG5cblxuSW1hZ2VCbG9iUmVkdWNlLnByb3RvdHlwZS5iZWZvcmUgPSBmdW5jdGlvbiAobWV0aG9kX25hbWUsIGZuKSB7XG4gIGlmICghdGhpc1ttZXRob2RfbmFtZV0pIHRocm93IG5ldyBFcnJvcignTWV0aG9kIFwiJyArIG1ldGhvZF9uYW1lICsgJ1wiIGRvZXMgbm90IGV4aXN0Jyk7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBcImZuXCIsIGZ1bmN0aW9uIGV4cGVjdGVkJyk7XG5cbiAgdmFyIG9sZF9mbiA9IHRoaXNbbWV0aG9kX25hbWVdO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpc1ttZXRob2RfbmFtZV0gPSBmdW5jdGlvbiAoZW52KSB7XG4gICAgcmV0dXJuIGZuLmNhbGwoc2VsZiwgZW52KS50aGVuKGZ1bmN0aW9uIChfZW52KSB7XG4gICAgICByZXR1cm4gb2xkX2ZuLmNhbGwoc2VsZiwgX2Vudik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbkltYWdlQmxvYlJlZHVjZS5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAobWV0aG9kX25hbWUsIGZuKSB7XG4gIGlmICghdGhpc1ttZXRob2RfbmFtZV0pIHRocm93IG5ldyBFcnJvcignTWV0aG9kIFwiJyArIG1ldGhvZF9uYW1lICsgJ1wiIGRvZXMgbm90IGV4aXN0Jyk7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBcImZuXCIsIGZ1bmN0aW9uIGV4cGVjdGVkJyk7XG5cbiAgdmFyIG9sZF9mbiA9IHRoaXNbbWV0aG9kX25hbWVdO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpc1ttZXRob2RfbmFtZV0gPSBmdW5jdGlvbiAoZW52KSB7XG4gICAgcmV0dXJuIG9sZF9mbi5jYWxsKHNlbGYsIGVudikudGhlbihmdW5jdGlvbiAoX2Vudikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwoc2VsZiwgX2Vudik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbkltYWdlQmxvYlJlZHVjZS5wcm90b3R5cGUuX2Jsb2JfdG9faW1hZ2UgPSBmdW5jdGlvbiAoZW52KSB7XG4gIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkw7XG5cbiAgZW52LmltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gIGVudi5pbWFnZV91cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGVudi5ibG9iKTtcbiAgZW52LmltYWdlLnNyYyA9IGVudi5pbWFnZV91cmw7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBlbnYuaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmVqZWN0KG5ldyBFcnJvcignSW1hZ2VCbG9iUmVkdWNlOiBmYWlsZWQgdG8gY3JlYXRlIEltYWdlKCkgZnJvbSBibG9iJykpOyB9O1xuICAgIGVudi5pbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7IHJlc29sdmUoZW52KTsgfTtcbiAgfSk7XG59O1xuXG5cbkltYWdlQmxvYlJlZHVjZS5wcm90b3R5cGUuX2NhbGN1bGF0ZV9zaXplID0gZnVuY3Rpb24gKGVudikge1xuICAvL1xuICAvLyBOb3RlLCBpZiB5b3VyIG5lZWQgbm90IFwic3ltbWV0cmljXCIgcmVzaXplIGxvZ2ljLCB5b3UgTVVTVCBjaGVja1xuICAvLyBgZW52Lm9yaWVudGF0aW9uYCAoc2V0IGJ5IHBsdWdpbnMpIGFuZCBzd2FwIHdpZHRoL2hlaWdodCBhcHByb3ByaWF0ZWx5LlxuICAvL1xuICB2YXIgc2NhbGVfZmFjdG9yID0gZW52Lm9wdHMubWF4IC8gTWF0aC5tYXgoZW52LmltYWdlLndpZHRoLCBlbnYuaW1hZ2UuaGVpZ2h0KTtcblxuICBpZiAoc2NhbGVfZmFjdG9yID4gMSkgc2NhbGVfZmFjdG9yID0gMTtcblxuICBlbnYudHJhbnNmb3JtX3dpZHRoID0gTWF0aC5tYXgoTWF0aC5yb3VuZChlbnYuaW1hZ2Uud2lkdGggKiBzY2FsZV9mYWN0b3IpLCAxKTtcbiAgZW52LnRyYW5zZm9ybV9oZWlnaHQgPSBNYXRoLm1heChNYXRoLnJvdW5kKGVudi5pbWFnZS5oZWlnaHQgKiBzY2FsZV9mYWN0b3IpLCAxKTtcblxuICAvLyBJbmZvIGZvciB1c2VyIHBsdWdpbnMsIHRvIGNoZWNrIGlmIHNjYWxpbmcgYXBwbGllZFxuICBlbnYuc2NhbGVfZmFjdG9yID0gc2NhbGVfZmFjdG9yO1xuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW52KTtcbn07XG5cblxuSW1hZ2VCbG9iUmVkdWNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGVudikge1xuICBlbnYub3V0X2NhbnZhcyA9IHRoaXMucGljYS5vcHRpb25zLmNyZWF0ZUNhbnZhcyhlbnYudHJhbnNmb3JtX3dpZHRoLCBlbnYudHJhbnNmb3JtX2hlaWdodCk7XG5cbiAgLy8gRGltIGVudiB0ZW1wb3JhcnkgdmFycyB0byBwcm9oaWJpdCB1c2UgYW5kIGF2b2lkIGNvbmZ1c2lvbiB3aGVuIG9yaWVudGF0aW9uXG4gIC8vIGNoYW5nZWQuIFlvdSBzaG91bGQgdGFrZSByZWFsIHNpemUgZnJvbSBjYW52YXMuXG4gIGVudi50cmFuc2Zvcm1fd2lkdGggPSBudWxsO1xuICBlbnYudHJhbnNmb3JtX2hlaWdodCA9IG51bGw7XG5cbiAgLy8gQnkgZGVmYXVsdCB1c2UgYWxwaGEgZm9yIHBuZyBvbmx5XG4gIHZhciBwaWNhX29wdHMgPSB7IGFscGhhOiBlbnYuYmxvYi50eXBlID09PSAnaW1hZ2UvcG5nJyB9O1xuXG4gIC8vIEV4dHJhY3QgcGljYSBvcHRpb25zIGlmIGJlZW4gcGFzc2VkXG4gIHRoaXMudXRpbHMuYXNzaWduKHBpY2Ffb3B0cywgdGhpcy51dGlscy5waWNrX3BpY2FfcmVzaXplX29wdGlvbnMoZW52Lm9wdHMpKTtcblxuICByZXR1cm4gdGhpcy5waWNhXG4gICAgLnJlc2l6ZShlbnYuaW1hZ2UsIGVudi5vdXRfY2FudmFzLCBwaWNhX29wdHMpXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZW52OyB9KTtcbn07XG5cblxuSW1hZ2VCbG9iUmVkdWNlLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uIChlbnYpIHtcbiAgZW52LmltYWdlLnNyYyA9ICcnO1xuICBlbnYuaW1hZ2UgPSBudWxsO1xuXG4gIHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkw7XG4gIGlmIChVUkwucmV2b2tlT2JqZWN0VVJMKSBVUkwucmV2b2tlT2JqZWN0VVJMKGVudi5pbWFnZV91cmwpO1xuXG4gIGVudi5pbWFnZV91cmwgPSBudWxsO1xuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW52KTtcbn07XG5cblxuSW1hZ2VCbG9iUmVkdWNlLnByb3RvdHlwZS5fY3JlYXRlX2Jsb2IgPSBmdW5jdGlvbiAoZW52KSB7XG4gIHJldHVybiB0aGlzLnBpY2EudG9CbG9iKGVudi5vdXRfY2FudmFzLCBlbnYuYmxvYi50eXBlKVxuICAgIC50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICBlbnYub3V0X2Jsb2IgPSBibG9iO1xuICAgICAgcmV0dXJuIGVudjtcbiAgICB9KTtcbn07XG5cblxuSW1hZ2VCbG9iUmVkdWNlLnByb3RvdHlwZS5fZ2V0VWludDhBcnJheSA9IGZ1bmN0aW9uIChibG9iKSB7XG4gIGlmIChibG9iLmFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGJsb2IuYXJyYXlCdWZmZXIoKS50aGVuKGZ1bmN0aW9uIChidWYpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgZnIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG5cbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7IHJlc29sdmUobmV3IFVpbnQ4QXJyYXkoZnIucmVzdWx0KSk7IH07XG4gICAgZnIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0ltYWdlQmxvYlJlZHVjZTogZmFpbGVkIHRvIGxvYWQgZGF0YSBmcm9tIGlucHV0IGJsb2InKSk7XG4gICAgICBmci5hYm9ydCgpO1xuICAgIH07XG4gICAgZnIub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0ltYWdlQmxvYlJlZHVjZTogZmFpbGVkIHRvIGxvYWQgZGF0YSBmcm9tIGlucHV0IGJsb2IgKGFib3J0ZWQpJykpO1xuICAgIH07XG4gIH0pO1xufTtcblxuXG5JbWFnZUJsb2JSZWR1Y2UucGljYSA9IHBpY2E7XG5cbnZhciBpbWFnZUJsb2JSZWR1Y2UgPSBJbWFnZUJsb2JSZWR1Y2U7XG5cbmV4cG9ydCBkZWZhdWx0IGltYWdlQmxvYlJlZHVjZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/.pnpm/image-blob-reduce@3.0.1/node_modules/image-blob-reduce/dist/image-blob-reduce.esm.mjs\n");

/***/ })

}]);